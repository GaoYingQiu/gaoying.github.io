{"meta":{"title":"littleWhale","subtitle":"勇敢去做，大胆尝试。","description":"坚定信念，相信美好。","author":"QiuGaoYing","url":"https://www.littlewhale.xyz","root":"/"},"pages":[{"title":"商品海报技术实践","date":"2020-05-26T13:31:34.000Z","updated":"2020-05-26T13:51:56.000Z","comments":true,"path":"商品海报技术实践.html","permalink":"https://www.littlewhale.xyz/%E5%95%86%E5%93%81%E6%B5%B7%E6%8A%A5%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5.html","excerpt":"","text":"在一段话中方便插入各种颜色的标签，包括：红色、黄色、绿色、青色、蓝色、灰色。 Volantis A Wonderful Theme for Hexo 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 + 默认选中 黄色 + 默认选中 青色 + 默认选中 蓝色 + 默认选中 增加 减少 叉 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 黄色 青色 蓝色 不设置任何参数的 按钮 适合融入段落中。regular 按钮适合独立于段落之外：示例博客 large 按钮更具有强调作用，建议搭配 center 使用： 开始使用 添加描述： 指定宽度： 指定宽度并添加描述： Your browser does not support the video tag. xaoxuu xaoxuu xaoxuu xaoxuu xaoxuu"},{"title":"关于我","date":"2020-07-20T08:29:31.000Z","updated":"2021-07-20T04:01:00.455Z","comments":true,"path":"about/index.html","permalink":"https://www.littlewhale.xyz/about/index.html","excerpt":"","text":"嗨！很高兴缘分让我们相遇。我是邱高颖，94年，2015年大专毕业，目前在广州工作。开个人博客的目的是对工作生活的一个记录与阶段总结。 经历总结 追求前沿技术，紧跟强劲对手，调整市场动向。 扎实基础，务实工作。产品严格，体验极致，客户导向。 化繁为简，重用复用，面向对象，抽象，结构。 技术 技术栈：iOS,H5,Vue,微信小程序。 语言：Objective-C，Swift，Javascript，HTML，CSS，Sql，RX。 联系微信号： qiugaoying1994 冲破险阻，亲近生活"},{"title":"categories","date":"2016-01-21T08:37:59.000Z","updated":"2016-01-21T08:42:44.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.littlewhale.xyz/categories/index.html","excerpt":"","text":""},{"title":"胖橙的画廊","date":"2020-05-26T13:31:34.000Z","updated":"2020-06-05T10:48:58.000Z","comments":true,"path":"paint/index.html","permalink":"https://www.littlewhale.xyz/paint/index.html","excerpt":"","text":"胖橙画馆 只为爱好，一个私密的小藏馆 在喧嚣的世界，除了工作，生活，闲暇之余，有一个爱好是平生之所幸。每一次的自由地画作，让我感受生活柴米油盐浸透着星辰大海。这些画让我在不开心的时候感到愉悦，在低谷的时候给了我力量。 在视觉中国关注我"},{"title":"tags","date":"2016-01-21T08:39:20.000Z","updated":"2016-01-21T08:40:08.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.littlewhale.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Swift GCD","slug":"GCD","date":"2021-07-19T08:00:10.000Z","updated":"2021-07-19T10:08:06.383Z","comments":true,"path":"2021/07/19/GCD/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/19/GCD/","excerpt":"","text":"Grand Central Dispatch (GCD)，CPU多核处理，线程间异步高效地执行任务。在GCD的管理下，只需提供DispatchWorkItem作为单个任务，本质上是个swift 闭包。这些任务项item由GCD根据一定地规则排队自动执行。通过 queue.async(execute: workItem)。通过GCD可设置任务的优先级，以及执行顺序。几个任务项也可以作为一个group， 通过DispatchGroup组织多任务执行，最后将所有处理完毕的结果作为单一整体汇总。队列Queue管理着任务项的执行，可串行也可并发。串行队列一次执行一个任务，并发队列无需等待执行中的任务结束才开启下一个任务（即可同时执行多项任务）。两种队列都按照先进先出（FOFO）执行。内部，有GCD线程池服务所有的队列。当某任务执行完成后线程即销毁。当所有的线程属于busy状态，新的线程需要暂时挂起。GCD预备了五种队列可直接使用。一种串行队列：主队列。四种异步队列分别权限为：hign，default，low，background。 12345// Do work synchronouslyDispatchQueue.global().sync &#123; ... &#125;// Do work asynchronouslyDispatchQueue.global().async &#123; ... &#125; 自定义串行队列：1234567let queue = DispatchQueue(label: \"Some serial queue\")// Do work synchronouslyqueue.sync &#123; ... &#125;// Do work asynchronouslyqueue.async &#123; ... &#125;有时，我们需要对某个任务项取消执行，这个时候需要用workItem12345678910111213class Service &#123; private var pendingWorkItem: DispatchWorkItem? let queue = DispatchQueue(label: \"Some serial queue\") func doSomething() &#123; pendingWorkItem?.cancel() let newWorkItem = DispatchWorkItem &#123; ... &#125; pendingWorkItem = newWorkItem queue.async(execute: newWorkItem) &#125;&#125; 批量任务处理:12345678910111213141516let queue = DispatchQueue(label: \"Serial queue\")let group = DispatchGroup()queue.async(group: group) &#123; sleep(1) print(\"Task 1 done\")&#125;queue.async(group: group) &#123; sleep(2) print(\"Task 2 done\")&#125;group.wait()print(\"All tasks done\")Task 1 doneTask 2 doneAll tasks done 另外一种group.enter()方式不会阻塞当前任务12345678910111213141516171819202122let queue = DispatchQueue(label: \"Serial queue\")let group = DispatchGroup()group.enter()queue.async &#123; sleep(1) print(\"Task 1 done\") group.leave()&#125;group.enter()queue.async &#123; sleep(2) print(\"Task 2 done\") group.leave()&#125;group.notify(queue: queue) &#123; print(\"All tasks done\")&#125;print(\"Continue execution immediately\")Continue execution immediatelyTask 1 doneTask 2 doneAll tasks done 留意线程死锁死锁1:12345678let queue = DispatchQueue(label: \"my-queue\")queue.sync &#123; print(\"print this\") queue.sync &#123; print(\"deadlocked\") &#125;&#125;死锁2:12345678910111213141516/// Create concurrent queuelet queue = DispatchQueue(label: \"Concurrent queue\", attributes: .concurrent)for _ in 0..&lt;999 &#123; // 1 queue.async &#123; sleep(1000) &#125;&#125;// 2DispatchQueue.main.sync &#123; queue.sync &#123; print(\"Done\") &#125;&#125; 通过信号量控制线程数123456789101112let concurrentTasks = 3let queue = DispatchQueue(label: \"Concurrent queue\", attributes: .concurrent)let sema = DispatchSemaphore(value: concurrentTasks)for _ in 0..&lt;999 &#123; queue.async &#123; // Do work sema.signal() &#125; sema.wait()&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"Swift中的值类型和引用类型","slug":"ValueTypes","date":"2021-07-16T08:00:10.000Z","updated":"2021-07-16T09:35:56.332Z","comments":true,"path":"2021/07/16/ValueTypes/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/16/ValueTypes/","excerpt":"首先我们带着几点疑问去看文章： 值类型(结构体、枚举) 和 引用类型 class 在内存中是如何存储的？ 值类型和引用类型性能上有什么不同？ 如果两者混合，会发生什么？比如struct 包含了 class 对象。 到底该使用哪个呢？ 值类型的定义 值类型直接存储到栈中。每个值类型的变量持有自己的数据，之间互不影响。 引用类型通过指针引用数据（存储在堆中），多个变量可指向同一数据，当操作某一变量时会影响其他变量。 值类型涉及到值拷贝，引用类型涉及到内存分配，引用计数。接下来我们大致了解一下内存段。","text":"首先我们带着几点疑问去看文章： 值类型(结构体、枚举) 和 引用类型 class 在内存中是如何存储的？ 值类型和引用类型性能上有什么不同？ 如果两者混合，会发生什么？比如struct 包含了 class 对象。 到底该使用哪个呢？ 值类型的定义 值类型直接存储到栈中。每个值类型的变量持有自己的数据，之间互不影响。 引用类型通过指针引用数据（存储在堆中），多个变量可指向同一数据，当操作某一变量时会影响其他变量。 值类型涉及到值拷贝，引用类型涉及到内存分配，引用计数。接下来我们大致了解一下内存段。 内存段内存是一个很长的字节列表。字节被有序排列，每个字节有它自己的地址。地址空间逻辑上分为4段。Text，Data,Heap, Stack。 文本段包含机器指令。由编译器将Swift代码编译成机器码。文本段只读。 数据段用来存储Swift静态变量，常量，元数据。程序启动时，公共数据初始化值将存储在这个位置。 栈段粗才能临时数据。方法参数和本地变量。当我们调用方法时，将在栈区域开辟一段内存直到方法调用结束这段内存将释放。以及一些值类型数据将存储在Stack。 堆存储所有引用对象，以及一些“假”的值对象（定义的结构体里包含class对象）。 值类型装箱 当遵循某协议时 12protocol Bar &#123;&#125;struct Baz: Bar &#123;&#125; 当和引用类型混合时 12345678910111213class A &#123;&#125;struct B &#123; let a = A()&#125;struct C &#123; &#125;class D &#123; let c = C()&#125;//结构体B,C 都分配在堆内存中。 使用泛型 1234567struct Bas&lt;T&gt; &#123; var x: T init(xx: T) &#123; x = xx &#125;&#125; Swift的闭包模型是所有局部变量都被引用。 Inout 参数123func foo(x: inout Int) &#123; x += 1&#125; 拷贝成本私有类型如整形，浮点型拷贝时不需要花费RAM内存，一些扩展类型如字符串，数组，set集合，字典等拷贝时需要进行复制。而引用类型由于不直接存储数据，拷贝时候多数是指针拷贝，而不是真正地内容拷贝。如果一个结构体包含引用类型时，而打破了值语义，那么如果要维持值语义，拷贝时候需要针对该对象是否引用计数为1的情况下，重新创建一份对象进行赋值。 12345678910111213141516171819class Ref &#123;&#125;struct MyStruct &#123; let ref1 = Ref()&#125;class MyClass &#123; let ref1 = Ref()&#125;let a = MyStruct()let anotherA = aprint(\"struct self:\", CFGetRetainCount(a as CFTypeRef)) //1print(\"struct ref1:\", CFGetRetainCount(a.ref1)) //3let b = MyClass()let anotherB = bprint(\"class self:\", CFGetRetainCount(b)) //3print(\"class ref1:\", CFGetRetainCount(b.ref1)) //2 总结： 值类型内部包含引用类型，打破了值语义，结构体将存储在堆上。赋值时将带来引用计数更大花销，引用对象可能被多个地方引用。实际业务可能受到影响。 具有动态行为的值类型（如数组和字符串）应采用写时复制来分摊复制成本。写复制可重写get方法，根据是否引用唯一计数来决定是直接引用还是复制一份。 当使用泛型或者协议时的值类型将发生装箱操作给内存带来更大花销。 写复制12345678910111213141516171819202122232425262728293031323334353637383940class Foo: NSObject &#123; var bar: String = \"bar\"&#125;struct FooHolder &#123; private var _foo: Foo = Foo() var foo: Foo &#123; mutating get &#123; if isKnownUniquelyReferenced(&amp;_foo) &#123; return _foo &#125; else &#123; let newFoo = Foo() newFoo.bar = _foo.bar _foo = newFoo return _foo &#125; &#125; set &#123; _foo = newValue &#125; &#125; var intValue: Int = 1&#125;var fooHolder = FooHolder()var fooHolder2 = fooHolderfooHolder2.foo.bar = \"bar2\"fooHolder2.intValue = 2print(fooHolder.intValue)// 1print(fooHolder2.intValue)// 2print(fooHolder.foo.bar)// barprint(fooHolder2.foo.bar)// bar2","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"Property Wrappers","slug":"PropertyWrappers","date":"2021-07-16T03:00:10.000Z","updated":"2021-07-16T03:14:22.407Z","comments":true,"path":"2021/07/16/PropertyWrappers/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/16/PropertyWrappers/","excerpt":"Property Wrappers 是 Swift5.1语言的一个功能点，允许我们定义一个自定义的类型，实现get,set方法的一些包装，以便重用。那接下来你可能会提出几个问题？ 它是用来解决什么问题？ 怎样实现一个属性包裹？ 怎样去接收一个属性变量？ 属性包裹器被Swift编译器编译成什么了？ 属性包裹器有什么限制？ 理解属性包裹1234567891011121314struct Bar &#123; private var _x = 0 var x: Int &#123; get &#123; _x &#125; set &#123; _x = newValue print(\"New value is \\(newValue)\") &#125; &#125;&#125;var bar = Bar()bar.x = 1 // Prints 'New value is 1' 为了复用，我们将变量定义成泛型。123456789101112131415struct ConsoleLogged&lt;Value&gt; &#123; private var value: Value init(wrappedValue: Value) &#123; self.value = wrappedValue &#125; var wrappedValue: Value &#123; get &#123; value &#125; set &#123; value = newValue print(\"New value is \\(newValue)\") &#125; &#125;&#125;Ok，我们用ConsoleLogged重写Bar1234567891011struct Bar &#123; private var _x = ConsoleLogged&lt;Int&gt;(wrappedValue: 0) var x: Int &#123; get &#123; _x.wrappedValue &#125; set &#123; _x.wrappedValue = newValue &#125; &#125;&#125;var bar = Bar()bar.x = 1 // Prints 'New value is 1'Swift提供@propertyWrapper关键字对以上封装。1234@propertyWrapperstruct ConsoleLogged&lt;Value&gt; &#123; // The rest of the code is unchanged&#125;","text":"Property Wrappers 是 Swift5.1语言的一个功能点，允许我们定义一个自定义的类型，实现get,set方法的一些包装，以便重用。那接下来你可能会提出几个问题？ 它是用来解决什么问题？ 怎样实现一个属性包裹？ 怎样去接收一个属性变量？ 属性包裹器被Swift编译器编译成什么了？ 属性包裹器有什么限制？ 理解属性包裹1234567891011121314struct Bar &#123; private var _x = 0 var x: Int &#123; get &#123; _x &#125; set &#123; _x = newValue print(\"New value is \\(newValue)\") &#125; &#125;&#125;var bar = Bar()bar.x = 1 // Prints 'New value is 1' 为了复用，我们将变量定义成泛型。123456789101112131415struct ConsoleLogged&lt;Value&gt; &#123; private var value: Value init(wrappedValue: Value) &#123; self.value = wrappedValue &#125; var wrappedValue: Value &#123; get &#123; value &#125; set &#123; value = newValue print(\"New value is \\(newValue)\") &#125; &#125;&#125;Ok，我们用ConsoleLogged重写Bar1234567891011struct Bar &#123; private var _x = ConsoleLogged&lt;Int&gt;(wrappedValue: 0) var x: Int &#123; get &#123; _x.wrappedValue &#125; set &#123; _x.wrappedValue = newValue &#125; &#125;&#125;var bar = Bar()bar.x = 1 // Prints 'New value is 1'Swift提供@propertyWrapper关键字对以上封装。1234@propertyWrapperstruct ConsoleLogged&lt;Value&gt; &#123; // The rest of the code is unchanged&#125;然后我们可以将bar的变量修改一下。123456struct Bar &#123; @ConsoleLogged var x = 0&#125;var bar = Bar()bar.x = 1 // Prints 'New value is 1' 定义属性包裹器 必须有@propertyWrapper关键字。 必须有wrappedValue属性。1234@propertyWrapperstruct Wrapper&lt;T&gt; &#123; var wrappedValue: T&#125; 那么使用的时候就简单了12345struct HasWrapper &#123; @Wrapper var x: Int&#125;let a = HasWrapper(x: 0) 定义属性时候，我们有两种方式将属性传递给属性包裹器。1234struct HasWrapperWithInitialValue &#123; @Wrapper var x = 0 // 方式一 @Wrapper(wrappedValue: 0) var y // 方式二&#125; 接收属性我们可以在包裹器中扩展新增方法。123456789101112@propertyWrapperstruct Wrapper&lt;T&gt; &#123; var wrappedValue: T func foo() &#123; print(\"Foo\") &#125;&#125;struct HasWrapper &#123; @Wrapper var x = 0 func foo() &#123; _x.foo() &#125; //_x 是 Wrapper&lt;T&gt;的一个实例，我们可以在内部访问，但是不能再HasWrapper外部访问_x变量的。&#125; 属性包裹器可以通过projectedValue提供更多的API12345678@propertyWrapperstruct Wrapper&lt;T&gt; &#123; var wrappedValue: T var projectedValue: Wrapper&lt;T&gt; &#123; return self &#125; func foo() &#123; print(\"Foo\") &#125;&#125; 123456789struct HasWrapper &#123; @Wrapper var x = 0 func foo() &#123; print(x) // `wrappedValue` print(_x) // wrapper type itself print($x) // `projectedValue` &#125;&#125; 用例限制 属性包裹器从Swift 5.1开始支持。 属性包裹器修饰的属性不可被子类重写。 属性包裹器修饰的属性不能与这些关键字一起使用 lazy, @NSCopying, @NSManaged, weak, or unowned. 属性包裹器不能再有自己的get,set方法了。 属性包裹器不能用于枚举，协议。 用例UserDefaultsValidatedPropertyKit123456789101112131415161718192021222324252627struct LoginView: View &#123; @Validated(!.isEmpty &amp;&amp; .isEmail) var mailAddress = String() @Validated(.range(8...)) var password = String() var body: some View &#123; List &#123; TextField(\"E-Mail\", text: self.$mailAddress) TextField(\"Password\", text: self.$password) Button( action: &#123; print(\"Login\", self.mailAddress, self.password) &#125;, label: &#123; Text(\"Submit\") &#125; ) .validated( self._mailAddress, self._password ) &#125; &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"依赖注入","slug":"DependencyInjection","date":"2021-07-15T09:30:10.000Z","updated":"2021-07-16T03:11:52.850Z","comments":true,"path":"2021/07/15/DependencyInjection/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/15/DependencyInjection/","excerpt":"依赖注入是一种让代码低耦合的设计模式。有四种实现方式： 初始化注入 属性赋值注入 接口注入 容器注入 初始化注入123456789101112131415161718192021222324protocol Dependency &#123; func foo()&#125;struct DependencyImplementation: Dependency &#123; func foo() &#123; // Does something &#125;&#125;class Client &#123; let dependency: Dependency init(dependency: Dependency) &#123; self.dependency = dependency //注入后不可再次更改。 &#125; func foo() &#123; dependency.foo() &#125;&#125;let client = Client(dependency: DependencyImplementation())client.foo() 初始化注入后，属性不可再被更改。当超过三个以上的属性需要注入，那么这个时候适合用属性注入的方式。","text":"依赖注入是一种让代码低耦合的设计模式。有四种实现方式： 初始化注入 属性赋值注入 接口注入 容器注入 初始化注入123456789101112131415161718192021222324protocol Dependency &#123; func foo()&#125;struct DependencyImplementation: Dependency &#123; func foo() &#123; // Does something &#125;&#125;class Client &#123; let dependency: Dependency init(dependency: Dependency) &#123; self.dependency = dependency //注入后不可再次更改。 &#125; func foo() &#123; dependency.foo() &#125;&#125;let client = Client(dependency: DependencyImplementation())client.foo() 初始化注入后，属性不可再被更改。当超过三个以上的属性需要注入，那么这个时候适合用属性注入的方式。 属性注入123456789101112131415161718192021protocol Dependency &#123; func foo()&#125;struct DependencyImplementation: Dependency &#123; func foo() &#123; // Does something &#125;&#125;class Client &#123; var dependency: Dependency! func foo() &#123; dependency.foo() &#125;&#125;let client = Client()client.dependency = DependencyImplementation()client.foo() 这种方式允许延后注入，但存在因某属性未注入而调用失败的问题。为了防止对象未注入的情况造成业务失败或者程序异常，接下来需要用接口对注入进行协议约定。 接口注入1234567891011121314151617181920212223242526272829303132333435363738394041protocol Dependency &#123;&#125;protocol HasDependency &#123; func setDependency(_ dependency: Dependency)&#125;protocol DoesSomething &#123; func doSomething()&#125;class Client: HasDependency, DoesSomething &#123; private var dependency: Dependency! func setDependency(_ dependency: Dependency) &#123; self.dependency = dependency &#125; func doSomething() &#123; // Does something with a dependency &#125;&#125;class Injector &#123; typealias Client = HasDependency &amp; DoesSomething private var clients: [Client] = [] func inject(_ client: Client) &#123; clients.append(client) client.setDependency(SomeDependency()) // Dependency applies its policies over clients client.doSomething() &#125; // Switch dependencies under certain conditions func switchToAnotherDependency() &#123; clients.forEach &#123; $0.setDependency(AnotherDependency()) &#125; &#125;&#125;class SomeDependency: Dependency &#123;&#125;class AnotherDependency: Dependency &#123;&#125; 但client本身就是一个依赖项，使得控制流变得复杂了。 Ambient Context单个全局可访问的依赖项，通过协议公开。这允许在需要时替代实现，例如在测试中。我们可以根据需要灵活地替换DateTimeProvider1234567891011121314151617protocol DateTimeProvider &#123; var now: Date &#123; get &#125;&#125;struct SystemDateTimeProvider: DateTimeProvider &#123; var now: Date &#123; return Date() &#125;&#125;class DateTime &#123; static var provider: DateTimeProvider = SystemDateTimeProvider() static var now: Date &#123; return provider.now &#125;&#125; 工厂模式构建依赖123456789101112131415protocol Client &#123;&#125;enum ClientFactory &#123; static func make() -&gt; Client &#123; return ClientImplementation(dependency: DependencyImplementation()) &#125;&#125;class ClientImplementation: Client &#123; init(dependency: Dependency) &#123;&#125;&#125;protocol Dependency &#123; &#125;struct DependencyImplementation: Dependency &#123;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"UserDefaults with PropertyWrapper","slug":"UserDefaults","date":"2021-07-15T03:30:10.000Z","updated":"2021-07-15T08:09:43.238Z","comments":true,"path":"2021/07/15/UserDefaults/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/15/UserDefaults/","excerpt":"","text":"UserDefaults可以存储一些基础数据类型，如：Data，String，Date，Bool，Int，Double，Float，Array，Dictionary，URL，等基础对象。也可以存储自定义对象(但需要实现编码成Data进行存储)。尽管如此，我们还是不推荐使用UserDefaults来存储数据量大的数据。因为读写非常昂贵，userDefaults最终用.plist文件进行存储。存储大数据会使此文件变得臃肿。对于自定义的对象，我们可以通过写文件方式将json写到沙盒文件中。或者存储到coreData. Sqlite等。UserDefaults一般用于存储一些简单的数据类型，存储用户的偏好设置等。在写少读多的情况下，性能才会高。底层是通过读写xml文件方式都数据进行读写。 接下来我们用PropertyWrapper对UserDefaults进行封装。123456789@propertyWrapperstruct UserDefault&lt;T: PropertyListValue&gt; &#123; let key: Key var wrappedValue: T? &#123; get &#123; UserDefaults.standard.value(forKey: key.rawValue) as? T &#125; set &#123; UserDefaults.standard.set(newValue, forKey: key.rawValue) &#125; &#125;&#125;需要对传入的泛型数据做约束，遵循PropertyListValue协议1234567891011121314//定义约束协议protocol PropertyListValue &#123;&#125;extension Data: PropertyListValue &#123;&#125;extension String: PropertyListValue &#123;&#125;extension Date: PropertyListValue &#123;&#125;extension Bool: PropertyListValue &#123;&#125;extension Int: PropertyListValue &#123;&#125;extension Double: PropertyListValue &#123;&#125;extension Float: PropertyListValue &#123;&#125;// 每个元素必须是 PropertyListValue 类型extension Array: PropertyListValue where Element: PropertyListValue &#123;&#125;extension Dictionary: PropertyListValue where Key == String, Value: PropertyListValue &#123;&#125;然后我们定义Key的结构体，遵循 RawRepresentable 协议。123struct Key: RawRepresentable &#123; let rawValue: String&#125;使用:1234public struct StorageTest &#123; @UserDefault(key: Key(rawValue: \"isFirstLaunch\")) var isFirstLaunchFlag: Bool?&#125;为了达到@UserDefault(key: “isFirstLaunch”)这样的简写效果，我们让Key实现ExpressibleByStringLiteral协议。12345678910extension Key: ExpressibleByStringLiteral &#123; init(stringLiteral: String) &#123; rawValue = stringLiteral &#125;&#125;public struct StorageTest &#123; @UserDefault(key: \"isFirstLaunch\") var isFirstLaunchFlag: Bool?&#125;为了统一的管理，我们将存储键写在Key结构体中。1234567extension Key &#123; static let isFirstLaunch: Key = \"isFirstLaunch\"&#125;public struct StorageTest &#123; @UserDefault(key: .isFirstLaunch) var isFirstLaunchFlag: Bool?&#125; KVO123456789101112131415161718192021222324252627282930313233343536class DefaultsObservation: NSObject &#123; let key: Key private var onChange: (Any, Any) -&gt; Void // 1 init(key: Key, onChange: @escaping (Any, Any) -&gt; Void) &#123; self.onChange = onChange self.key = key super.init() UserDefaults.standard.addObserver(self, forKeyPath: key.rawValue, options: [.old, .new], context: nil) &#125; // 2 override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey: Any]?, context: UnsafeMutableRawPointer?) &#123; guard let change = change, object != nil, keyPath == key.rawValue else &#123; return &#125; onChange(change[.oldKey] as Any, change[.newKey] as Any) &#125; // 3 deinit &#123; UserDefaults.standard.removeObserver(self, forKeyPath: key.rawValue, context: nil) &#125;&#125;@propertyWrapperstruct UserDefault&lt;T: PropertyListValue&gt; &#123; var projectedValue: UserDefault&lt;T&gt; &#123; return self &#125; func observe(change: @escaping (T?, T?) -&gt; Void) -&gt; NSObject &#123; return DefaultsObservation(key: key) &#123; old, new in change(old as? T, new as? T) &#125; &#125; // The rest of the code is unchanged&#125; 用法:12345678var storage = Storage()var observation = storage.$isFirstLaunch.observe &#123; old, new in print(\"Changed from: \\(old) to \\(new)\")&#125;storage.isFirstLaunch = truestorage.isFirstLaunch?.toggle()","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"单元测试-异步篇","slug":"UnitTestAsync","date":"2021-07-14T09:30:10.000Z","updated":"2021-07-14T10:10:01.040Z","comments":true,"path":"2021/07/14/UnitTestAsync/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/14/UnitTestAsync/","excerpt":"SUT12345678910111213141516171819202122232425262728293031extension URLRequest &#123; static func search(term: String) -&gt; URLRequest &#123; var components = URLComponents(string: \"https://itunes.apple.com/search\") components?.queryItems = [ .init(name: \"media\", value: \"music\"), .init(name: \"entity\", value: \"song\"), .init(name: \"term\", value: \"\\(term)\") ] return URLRequest(url: components!.url!) &#125;&#125;struct MusicService &#123; func search(_ term: String, completion: @escaping (Result&lt;[Track], Error&gt;) -&gt; Void) &#123; URLSession.shared.dataTask(with: .search(term: term)) &#123; data, response, error in DispatchQueue.main.async &#123; completion(self.parse(data: data, error: error)) &#125; &#125;.resume() &#125; func parse(data: Data?, error: Error?) -&gt; Result&lt;[Track], Error&gt; &#123; if let data = data &#123; return Result &#123; try JSONDecoder().decode(SearchMediaResponse.self, from: data).results &#125; &#125; else &#123; return .failure(error ?? URLError(.badServerResponse)) &#125; &#125;&#125;","text":"SUT12345678910111213141516171819202122232425262728293031extension URLRequest &#123; static func search(term: String) -&gt; URLRequest &#123; var components = URLComponents(string: \"https://itunes.apple.com/search\") components?.queryItems = [ .init(name: \"media\", value: \"music\"), .init(name: \"entity\", value: \"song\"), .init(name: \"term\", value: \"\\(term)\") ] return URLRequest(url: components!.url!) &#125;&#125;struct MusicService &#123; func search(_ term: String, completion: @escaping (Result&lt;[Track], Error&gt;) -&gt; Void) &#123; URLSession.shared.dataTask(with: .search(term: term)) &#123; data, response, error in DispatchQueue.main.async &#123; completion(self.parse(data: data, error: error)) &#125; &#125;.resume() &#125; func parse(data: Data?, error: Error?) -&gt; Result&lt;[Track], Error&gt; &#123; if let data = data &#123; return Result &#123; try JSONDecoder().decode(SearchMediaResponse.self, from: data).results &#125; &#125; else &#123; return .failure(error ?? URLError(.badServerResponse)) &#125; &#125;&#125; 前几篇单元测试文章我们有讲到依赖注入，我们继续将MusicService通过依赖项：我们继续改进:1234567891011121314151617181920212223242526272829protocol HTTPClient &#123; func execute(request: URLRequest, completion: @escaping (Result&lt;Data, Error&gt;) -&gt; Void)&#125;struct MusicService &#123; let httpClient: HTTPClient func search(_ term: String, completion: @escaping (Result&lt;[Track], Error&gt;) -&gt; Void) &#123; httpClient.execute(request: .search(term: term)) &#123; result in completion(self.parse(result)) &#125; &#125; private func parse(_ result: Result&lt;Data, Error&gt;) -&gt; Result&lt;[Track], Error&gt; &#123; ... &#125;&#125;class RealHTTPClient: HTTPClient &#123; func execute(request: URLRequest, completion: @escaping (Result&lt;Data, Error&gt;) -&gt; Void) &#123; URLSession.shared.dataTask(with: request) &#123; data, response, error in DispatchQueue.main.async &#123; if let data = data &#123; completion(.success(data)) &#125; else &#123; completion(.failure(error!)) &#125; &#125; &#125;.resume() &#125;&#125; Mocking Data1234567891011121314151617181920212223242526class MockHTTPClient: HTTPClient &#123; var inputRequest: URLRequest? var executeCalled = false var result: Result&lt;Data, Error&gt;? func execute(request: URLRequest, completion: @escaping (Result&lt;Data, Error&gt;) -&gt; Void) &#123; executeCalled = true inputRequest = request result.map(completion) &#125;&#125;//ok,我们接下来用假数据mock真数据构建测试用例func testSearch() &#123; // 1. let httpClient = MockHTTPClient() let sut = MusicService(httpClient: httpClient) // 2. sut.search(\"A\") &#123; _ in &#125; // 3. 检查方法执行情况 XCTAssertTrue(httpClient.executeCalled) // 4. 校验请求的api是否一致 XCTAssertEqual(httpClient.inputRequest, .search(term: \"A\"))&#125; 接下来，我们校验结果集是否一致12345678910111213141516171819func testSearchWithSuccessResponse() throws &#123; // 1.准备测试数据 let expectedTracks = [Track(trackName: \"A\", artistName: \"B\")] let response = try JSONEncoder().encode(SearchMediaResponse(results: expectedTracks)) // 2.构建mock对象 let httpClient = MockHTTPClient() httpClient.result = .success(response) let sut = MusicService(httpClient: httpClient) var result: Result&lt;[Track], Error&gt;? // 3.调用search方法，将结果映射给result sut.search(\"A\") &#123; result = $0 &#125; // 4.断言比较预期值和结果值 XCTAssertEqual(result?.value, expectedTracks)&#125;我们也可验证请求失败的情况：1234567891011121314151617func testSearchWithFailureResponse() throws &#123; // 1. let httpClient = MockHTTPClient() httpClient.result = .failure(DummyError()) let sut = MusicService(httpClient: httpClient) var result: Result&lt;[Track], Error&gt;? // 2. sut.search(\"A\") &#123; result = $0 &#125; // 4. XCTAssertTrue(result?.error is DummyError)&#125;struct DummyError: Error &#123;&#125; Testing Before &amp; After我们可以将异步业务分为异步处理之前，异步处理之后例如刚刚的SUI,我们分为test before123456789101112131415161718192021222324func testSearchBefore() &#123; let sut = MusicService() // 1. sut.search(\"A\") &#123; _ in &#125; // 2. let lastRequest = URLSession.shared.tasks.last?.currentRequest XCTAssertEqual(lastRequest?.url, URLRequest.search(term: \"A\").url)&#125;extension URLSession &#123; var tasks: [URLSessionTask] &#123; var tasks: [URLSessionTask] = [] let group = DispatchGroup() group.enter() getAllTasks &#123; tasks = $0 group.leave() &#125; group.wait() return tasks &#125;&#125;在处理异步业务之后，MusicService需要处理数据解析。那么可以把这一块作为一个小的UST来进行测试。12345678910func testSearchAfterWithSuccess() throws &#123; let expectedTracks = [Track(trackName: \"A\", artistName: \"B\")] let response = try JSONEncoder().encode(SearchMediaResponse(results: expectedTracks)) let sut = MusicService() let result = sut.parse(data: response, error: nil) XCTAssertEqual(result.value, expectedTracks)&#125;123456789func testSearchAfterWithFailure() &#123; let sut = MusicServiceWithoutDependency() let result = sut.parse(data: nil, error: DummyError()) XCTAssertTrue(result.error is DummyError)&#125;struct DummyError: Error &#123;&#125;这么一看，好像写了一堆废代码。咋看都错误匹配。但就是校验错误异常是否为DummyError。看起来有点傻。 Expectations以上Mock测试方法和Test Before &amp; After 虽然也管用，但始终没有测试到异步代码。XCTest框架提供XCTestExpectation。 这个模式方法总结出以下几个步骤。 创建XCTestExpectation实例。 当异步任务结束时候完成此期望。 等待期望被兑现。 断言期望的结果 ok，回到HttpClient的版本，看我们如何编写这个单元测试。12345678910111213141516171819func testSearch() &#123; // 1.构建期望 let didReceiveResponse = expectation(description: #function) // 与mock不同的是，这里不做mock，直接给真实数据对象 let sut = MusicService(httpClient: RealHTTPClient()) var result: Result&lt;[Track], Error&gt;? sut.search(\"ANYTHING\") &#123; result = $0 didReceiveResponse.fulfill() //2. 填充期望 &#125; // 3.等待期望值....,这一步非常重要。在5秒等待响应结果，内部应该有个loop检查结果是否返回 wait(for: [didReceiveResponse], timeout: 5) // 4.输出期望结果 XCTAssertNotNil(result?.value)&#125; XCTestExpectation 是一个多用途的工具，可以应用于许多场景。12345678910111213func testInvertedExpectation() &#123; // 1. let exp = expectation(description: #function) exp.isInverted = true // 2. sut.maybeComplete &#123; exp.fulfill() &#125; // 3. wait(for: [exp], timeout: 0.1)&#125; Notification Expectation 可用作当通知被接收的校验12345678func testExpectationForNotification() &#123; let exp = XCTNSNotificationExpectation(name: .init(\"MyNotification\"), object: nil) ... sut.postNotification() wait(for: [exp], timeout: 1)&#125;以及通过expectedFulfillmentCount属性，可验证fulfill()被调用的次数。12345678910func testExpectationFulfillmentCount() &#123; let exp = expectation(description: #function) exp.expectedFulfillmentCount = 3 exp.assertForOverFulfill = true ... sut.doSomethingThreeTimes() wait(for: [exp], timeout: 1)&#125; Busy Assertion1234567891011121314151617181920212223通过开启一个runloop，在一定时间范围内循环判断isFulfilled的状态，如果是则退出循环。extension XCTest &#123; func expectToEventually( _ isFulfilled: @autoclosure () -&gt; Bool, timeout: TimeInterval, message: String = \"\", file: StaticString = #filePath, line: UInt = #line ) &#123; func wait() &#123; RunLoop.current.run(until: Date(timeIntervalSinceNow: 0.01)) &#125; let timeout = Date(timeIntervalSinceNow: timeout) func isTimeout() -&gt; Bool &#123; Date() &gt;= timeout &#125; repeat &#123; if isFulfilled() &#123; return &#125; wait() &#125; while !isTimeout() XCTFail(message, file: file, line: line) //当超时未拿到结果，抛出失败。 &#125;&#125; 用法：123456789func testSearchBusyAssert() &#123; let sut = MusicService(httpClient: RealHTTPClient()) var result: Result&lt;[Track], Error&gt;? sut.search(\"ANYTHING\") &#123; result = $0 &#125; expectToEventually(result?.value != nil, timeout: 5)&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"单元测试-视图篇","slug":"unitest","date":"2021-07-14T03:30:10.000Z","updated":"2021-07-14T08:16:50.441Z","comments":true,"path":"2021/07/14/unitest/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/14/unitest/","excerpt":"","text":"视图测试关注点： tableview的行数是否正确？ label的文本显示是否正确？ button 是否启用或禁用？ view的frame是否正确？ viewController如果可以从他们依赖项隔离出来，那么就可以测试。依赖注入是一种可以把视图控制器隔离出来的技术。在测试中，我们可以用假数据替换依赖项，模拟真实数据的行为。viewController有两个职责：渲染数据、响应用户交互。在MVVM设计模式中，控制器不主动从model中拉数据，也不负责从model中取出数据来更新控制器。 我们定义好要显示的状态属性等，然后通过协议来约束控制器实现渲染数据的动作。12345678910struct ArtistDetailProps &#123; let title: String let fullName: String let numberOfAlbums: String let numberOfFollowers: String&#125;protocol ArtistDetailComponent: AnyObject &#123; func render(_ props: ArtistDetailProps)&#125;viewController遵循该协议，实现渲染数据的动作12345678extension ArtistDetailViewController: ArtistDetailComponent &#123; func render(_ props: ArtistDetailProps) &#123; navigationItem.title = props.title fullNameLabel.text = props.fullName numberOfAlbumsLabel.text = props.numberOfAlbums numberOfFollowersLabel.text = props.numberOfFollowers &#125;&#125; 测试ViewController控制器的render是由presenter决定，我我们可以定义一个presenter的mockPresenter子类。123456789101112131415//定义好交互方法class ArtistDetailPresenterMock: ArtistDetailPresenter &#123; private(set) var onViewLoadedCalled = false func onViewLoaded() &#123; onViewLoadedCalled = true &#125; private(set) var onEditCalled = false func onEdit() &#123; onEditCalled = true &#125;&#125;准备好测试数据:12345678910111213141516171819202122232425262728293031323334353637383940414243class ArtistDetailViewControllerTests: XCTestCase &#123; let presenter = ArtistDetailPresenterMock() func makeSUT() -&gt; ArtistDetailViewController &#123; let storyboard = UIStoryboard(name: \"Main\", bundle: nil) let sut = storyboard.instantiateViewController(identifier: \"ArtistDetailViewController\") as! ArtistDetailViewController sut.presenter = presenter sut.loadViewIfNeeded() return sut &#125; //验证交互： func testViewDidLoadCallsPresenter() &#123; let sut = makeSUT() sut.viewDidLoad() XCTAssertTrue(presenter.onViewLoadedCalled) &#125; func testOnEditCallsPresenter() &#123; let sut = makeSUT() sut.onEdit(.init()) XCTAssertTrue(presenter.onEditCalled) &#125; //验证测试数据是否正确 func testRender() &#123; let props = ArtistDetailProps(title: \"TITLE\", fullName: \"NAME\", numberOfAlbums: \"1\", numberOfFollowers: \"2\") let sut = makeSUT() sut.render(props) XCTAssertEqual(sut.navigationItem.title, \"TITLE\") XCTAssertEqual(sut.fullNameLabel.text, \"NAME\") XCTAssertEqual(sut.numberOfAlbumsLabel.text, \"1\") XCTAssertEqual(sut.numberOfFollowersLabel.text, \"2\") &#125;&#125;ok，以上测试用例我们验证了用户交互行为是否触发 以及 渲染数据的正确与否。总结：如果要让viewController可测试，我们需要让viewController数据渲染被动而非主动(MVVM模式或者MVP模式)，可以通过依赖注入来定义mock模型，实现可测试化。控制器和视图的测试不是测试颜色、布局等样式，而是测试交互以及数据渲染的准确性！","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"Swift单元测试","slug":"swiftUnitTest","date":"2021-07-14T02:30:10.000Z","updated":"2021-07-14T08:13:22.644Z","comments":true,"path":"2021/07/14/swiftUnitTest/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/14/swiftUnitTest/","excerpt":"什么是单元测试单元测试是运行一个方法（程序的已部分功能代码）验证其输入和输出结果的正确性。通过调用开放的API和行为属性，一般有: 方法返回值 改变Class的属性 缓存数据的CURD 发送通知 为什么需要写单元测试单元测试可有效减少程序bug，保证程序结果的准确性，改善代码结构。 定义一个好的单元测试一个好的单元测试具有以下特点： 可读性高 可维护性 可靠的 可读性当单元测试失败的时候，你能够快速找到失败的原因代码。单元测试需要符合代码规范，格式、命名、模式等等。 简洁的命名、变量 清晰的异常信息 遵循合适的断言结构 可维护性 只测试public,或者internals变量或者方法。不要仅仅为了验证私有和文件私有属性或方法而削弱封装。 不要把测试代码放到生成环境 每项测试只测试一个业务功能 重用代码。如果测试用例包含很多复制重复的代码，需要进行抽象封装，创建一个共享共用的方法如下片段UserStorageTests代码。12345678910111213141516171819class UserStorageTests: XCTestCase &#123; let userDefaults = UserDefaultsMock() let keychain = KeychainMock() let user = User(id: 1, username: \"U1\", password: \"P1\") func testUsernameSavedToStorage() &#123; makeSUT().save(user) XCTAssertNotNil(userDefaults.inputUsername) &#125; func testPasswordSavedToSecureStorage() &#123; makeSUT().save(user) XCTAssertNotNil(keychain.inputPassword) &#125; func makeSUT() -&gt; UserStorage &#123; return UserStorage(storage: userDefaults, secureStorage: keychain) &#125;&#125; 可靠性 100%的通过率 测试用例可以重现步骤。 避免在编写单元测试时候写测试逻辑。不要写for,while等循环，不要写if,else,Switch等条件语句，不要写do{}catch{}异常捕获(例如下列片段代码，我们可以用throws将异常抛出)。 123456789101112131415struct Item:Codable,Equatable &#123; let id:Int&#125;//`Item` has custom Codable implementations that we want to testclass SwiftTestUITests: XCTestCase &#123; func testItemCodable() throws &#123; let expected = Item(id: 1) let encoded = try JSONEncoder().encode(expected) let decoded = try JSONDecoder().decode(Item.self, from: encoded) XCTAssertEqual(decoded, expected) &#125;&#125;","text":"什么是单元测试单元测试是运行一个方法（程序的已部分功能代码）验证其输入和输出结果的正确性。通过调用开放的API和行为属性，一般有: 方法返回值 改变Class的属性 缓存数据的CURD 发送通知 为什么需要写单元测试单元测试可有效减少程序bug，保证程序结果的准确性，改善代码结构。 定义一个好的单元测试一个好的单元测试具有以下特点： 可读性高 可维护性 可靠的 可读性当单元测试失败的时候，你能够快速找到失败的原因代码。单元测试需要符合代码规范，格式、命名、模式等等。 简洁的命名、变量 清晰的异常信息 遵循合适的断言结构 可维护性 只测试public,或者internals变量或者方法。不要仅仅为了验证私有和文件私有属性或方法而削弱封装。 不要把测试代码放到生成环境 每项测试只测试一个业务功能 重用代码。如果测试用例包含很多复制重复的代码，需要进行抽象封装，创建一个共享共用的方法如下片段UserStorageTests代码。12345678910111213141516171819class UserStorageTests: XCTestCase &#123; let userDefaults = UserDefaultsMock() let keychain = KeychainMock() let user = User(id: 1, username: \"U1\", password: \"P1\") func testUsernameSavedToStorage() &#123; makeSUT().save(user) XCTAssertNotNil(userDefaults.inputUsername) &#125; func testPasswordSavedToSecureStorage() &#123; makeSUT().save(user) XCTAssertNotNil(keychain.inputPassword) &#125; func makeSUT() -&gt; UserStorage &#123; return UserStorage(storage: userDefaults, secureStorage: keychain) &#125;&#125; 可靠性 100%的通过率 测试用例可以重现步骤。 避免在编写单元测试时候写测试逻辑。不要写for,while等循环，不要写if,else,Switch等条件语句，不要写do{}catch{}异常捕获(例如下列片段代码，我们可以用throws将异常抛出)。 123456789101112131415struct Item:Codable,Equatable &#123; let id:Int&#125;//`Item` has custom Codable implementations that we want to testclass SwiftTestUITests: XCTestCase &#123; func testItemCodable() throws &#123; let expected = Item(id: 1) let encoded = try JSONEncoder().encode(expected) let decoded = try JSONDecoder().decode(Item.self, from: encoded) XCTAssertEqual(decoded, expected) &#125;&#125; 单元测试举例12345struct UsernameValidator &#123; func isValid(_ username: String) -&gt; Bool &#123; return username.count &gt; 4 &#125;&#125; 根据之前提到的，我们需要怎么样去测试这个方法呢？首先： 定义对象，根据需求设置测试对象。 调用测试对象的方法 断言反馈测试结果1234567891011 class UsernameValidatorTests: XCTestCase &#123; func testTooShortUsername() &#123; let sut = UsernameValidator() let result = sut.isValid(\"U1\") XCTAssertFalse(result) //XCTAssert是XCTest.framework框架里的断言方法 //当然以上代码是没问题，但推荐尽量用一两行代码让测试用例结果更显而易见 XCTAssertFalse(UsernameValidator().isValid(\"U1\")) &#125;&#125; 特殊断言有一些特殊断言，比如比较相等XCTAssertEqual(x,y)，判断非空XCTAssertNotNil(x)。在你犹豫用XCTAssert还是XCTAssertNil的时候，显然用特殊断言比较方便。1234567891011// EqualityXCTAssert(x == y) // ❌XCTAssertEqual(x, y) // ✅//浮点数的比较，accuracy为精确到小数点let epsilon = 0.0001XCTAssertEqual(x, y, accuracy: epsilon)// Nil and Non-nilXCTAssert(x != nil) // ❌XCTAssertNotNil(x) // ✅ 模拟假数据当我们调用的方法包含大量依赖项时候，将导致不可控的变化。比如测试UIApplicationDelegate的 application(:, didFinishLaunchingWithOptions:)方法。为了阻止依赖项的影响，我们需要隔离所有依赖，通过依赖注入等技术可以有效解决。比如App的登录逻辑，我们想测试用户名密码登录的权限，以下代码片段:123456789class AuthService &#123; func login(with username: String, password: String, completion: @escaping (Result&lt;User, Error&gt;) -&gt; Void) &#123; let request = URLRequest.login(username: username, password: password) URLSession.shared.dataTask(with: request) &#123; data, response, error in // Handle response &#125;.resume() &#125;&#125;调用login方法有不可控的影响：它执行了一个网络请求。我们在编写单元测试的时候需要隔离AuthService从网络请求的依赖。首先我们在做顶层网络请求的时候就需要设计一个抽象，然后将它作为一个依赖注入到所需要的服务中，经过改进如下：1234567891011121314151617protocol HTTPClient &#123; func execute(request: URLRequest, completion: @escaping (Result&lt;Data, Error&gt;) -&gt; Void)&#125;class AuthService &#123; let httpClient: HTTPClient // Initialization code func login(with username: String, password: String, completion: @escaping (Result&lt;User, Error&gt;) -&gt; Void) &#123; let request = URLRequest.login(username: username, password: password) httpClient.execute(request: request) &#123; result in // Handle response &#125; &#125;&#125;那么我们在mock数据的时候，我们就可以对这个依赖项做一个mock，因为httpClient是个协议，那么我么构建一个MockHtttpClient:123456789class HTTPClientMock: HTTPClient &#123; var inputRequest: URLRequest? var executeCalled = false func execute(request: URLRequest, completion: @escaping (Result&lt;Data, Error&gt;) -&gt; Void) &#123; executeCalled = true inputRequest = request &#125;&#125;那么我们在做单元测试的时候，就可以很好地利用这个mock,模拟真实的网络请求。我们来验证是否被调用，以及验证请求的api是否正确。1234567891011class AuthServiceTests: XCTestCase &#123; func testLogin() &#123; let httpClient = HTTPClientMock() let sut = AuthService(httpClient: httpClient) sut.login(with: \"U1\", password: \"P1\") &#123; _ in &#125; XCTAssertTrue(httpClient.executeCalled) XCTAssertEqual(httpClient.inputRequest?.url, .login) &#125;&#125;这样，我们就完成了一个用户名密码登录这样一个单元测试，校验了请求API的正确性。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"数据驱动TableViewController","slug":"tableDriver","date":"2021-07-13T08:01:10.000Z","updated":"2021-07-13T08:28:03.681Z","comments":true,"path":"2021/07/13/tableDriver/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/13/tableDriver/","excerpt":"iOS工程师都知道tableview 在开发中是用得最多的，大部分页面几乎都可以用列表来做。但有没发现大量工作其实是重复的比如cell的注册，delegate数据源的匹配，cell的类型转换。接下来，我们需要将这些代理方法为tableview提供数据封装成数据模型。数据源：dataSource[section[ rows],section[ rows]] 封装DataSource1234567891011121314151617181920struct Section&lt;Item&gt; &#123; var items: [Item]&#125;struct DataSource&lt;Item&gt; &#123; var sections: [Section&lt;Item&gt;] func numberOfSections() -&gt; Int &#123; return sections.count &#125; func numberOfItems(in section: Int) -&gt; Int &#123; guard section &lt; sections.count else &#123; return 0 &#125; return sections[section].items.count &#125; func item(at indexPath: IndexPath) -&gt; Item &#123; return sections[indexPath.section].items[indexPath.row] &#125;&#125;","text":"iOS工程师都知道tableview 在开发中是用得最多的，大部分页面几乎都可以用列表来做。但有没发现大量工作其实是重复的比如cell的注册，delegate数据源的匹配，cell的类型转换。接下来，我们需要将这些代理方法为tableview提供数据封装成数据模型。数据源：dataSource[section[ rows],section[ rows]] 封装DataSource1234567891011121314151617181920struct Section&lt;Item&gt; &#123; var items: [Item]&#125;struct DataSource&lt;Item&gt; &#123; var sections: [Section&lt;Item&gt;] func numberOfSections() -&gt; Int &#123; return sections.count &#125; func numberOfItems(in section: Int) -&gt; Int &#123; guard section &lt; sections.count else &#123; return 0 &#125; return sections[section].items.count &#125; func item(at indexPath: IndexPath) -&gt; Item &#123; return sections[indexPath.section].items[indexPath.row] &#125;&#125; Table Config列表配置基本包含三项：重用标识，注册cell，配置cell1234567891011121314151617181920212223242526272829303132333435363738394041//table configprotocol ConfiguratorType &#123; associatedtype Item associatedtype Cell: UITableViewCell func reuseIdentifier(for item: Item, indexPath: IndexPath) -&gt; String func configuredCell(for item: Item, tableView: UITableView, indexPath: IndexPath) -&gt; Cell func registerCells(in tableView: UITableView)&#125;//构建配置器。泛型Item, Cellstruct Configurator&lt;Item, Cell: UITableViewCell&gt;: ConfiguratorType &#123; typealias CellConfigurator = (Cell, Item, UITableView, IndexPath) -&gt; Cell let configurator: CellConfigurator let reuseIdentifier = \"\\(Cell.self)\" func reuseIdentifier(for item: Item, indexPath: IndexPath) -&gt; String &#123; return reuseIdentifier &#125; func configure(cell: Cell, item: Item, tableView: UITableView, indexPath: IndexPath) -&gt; Cell &#123; return configurator(cell, item, tableView, indexPath) &#125; func registerCells(in tableView: UITableView) &#123; if let path = Bundle.main.path(forResource: \"\\(Cell.self)\", ofType: \"nib\"), FileManager.default.fileExists(atPath: path) &#123; let nib = UINib(nibName: \"\\(Cell.self)\", bundle: .main) tableView.register(nib, forCellReuseIdentifier: reuseIdentifier) &#125; else &#123; tableView.register(Cell.self, forCellReuseIdentifier: reuseIdentifier) &#125; &#125; func configuredCell(for item: Item, tableView: UITableView, indexPath: IndexPath) -&gt; Cell &#123; let reuseIdentifier = self.reuseIdentifier(for: item, indexPath: indexPath) let cell = tableView.dequeueReusableCell(withIdentifier: reuseIdentifier, for: indexPath) as! Cell return self.configure(cell: cell, item: item, tableView: tableView, indexPath: indexPath) &#125;&#125; 多类型cell配置器假如我们的一个业务列表由两种cell组成:TableCell,NibCell。那么我们提供重用标识，配置cell时候就需要做好枚举判断。123456789101112131415161718192021222324252627282930313233343536373839404142enum CellType &#123; typealias Model = String typealias AnotherModel = String case cell(Model) case anotherCell(AnotherModel)&#125;class TableCell: UITableViewCell &#123;&#125;class NibCell: UITableViewCell &#123;&#125;struct MoreCellsConfigurator: ConfiguratorType &#123; let cellConfigurator: Configurator&lt;CellType.Model, TableCell&gt; let anotherCellConfigurator: Configurator&lt;CellType.AnotherModel, NibCell&gt; func reuseIdentifier(for item: CellType, indexPath: IndexPath) -&gt; String &#123; switch item &#123; case .cell: return cellConfigurator.reuseIdentifier case .anotherCell: return anotherCellConfigurator.reuseIdentifier &#125; &#125; func configuredCell(for item: CellType, tableView: UITableView, indexPath: IndexPath) -&gt; UITableViewCell &#123; switch item &#123; case .cell(let model): return cellConfigurator.configuredCell(for: model, tableView: tableView, indexPath: indexPath) case .anotherCell(let model): return anotherCellConfigurator.configuredCell(for: model, tableView: tableView, indexPath: indexPath) &#125; &#125; func registerCells(in tableView: UITableView) &#123; cellConfigurator.registerCells(in: tableView) anotherCellConfigurator.registerCells(in: tableView) &#125;&#125; 使用多cells配置器1234567891011121314151617181920212223242526272829class ExampleTableViewController&lt;Item, Cell: UITableViewCell&gt;: UITableViewController&#123; let dataSource: DataSource&lt;Item&gt; let configurator: MoreCellsConfigurator init(dataSource: DataSource&lt;Item&gt;, configurator: MoreCellsConfigurator) &#123; self.dataSource = dataSource self.configurator = configurator super.init(nibName: nil, bundle: nil) configurator.registerCells(in: tableView) &#125; @available(*, unavailable) required init?(coder aDecoder: NSCoder) &#123; fatalError() &#125; override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return dataSource.numberOfSections() &#125; override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return dataSource.numberOfItems(in: section) &#125; override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let item = dataSource.item(at: indexPath) as! CellType return configurator.configuredCell(for: item, tableView: tableView, indexPath: indexPath) &#125;&#125; demo控制器举例1234567891011121314151617181920212223242526272829303132333435363738394041424344extension UIViewController &#123; func add(child: UIViewController, container: UIView, configure: (_ childView: UIView) -&gt; Void = &#123; _ in &#125;) &#123; addChild(child) container.addSubview(child.view) configure(child.view) child.didMove(toParent: self) &#125;&#125;class GYViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() setupTable() &#125; func setupTable() &#123; let section0 = Section&lt;CellType&gt;(items: [.cell(\"a\"), .anotherCell(\"2\"), .cell(\"c\")]) let section1 = Section&lt;CellType&gt;(items: [.anotherCell(\"1\"), .cell(\"b\"), .anotherCell(\"3\")]) let dataSource = DataSource(sections: [section0, section1]) //TableCell配置器 let configurator1 = Configurator &#123; (cell, model: CellType.Model, tableView, indexPath) -&gt; TableCell in cell.textLabel?.text = model return cell &#125; //NibCell配置器 let configurator2 = Configurator &#123; (cell, model: CellType.AnotherModel, tableView, indexPath) -&gt; NibCell in cell.textLabel?.text = model return cell &#125; //配置多种cell配置器 let aggregate = MoreCellsConfigurator(cellConfigurator: configurator1, anotherCellConfigurator: configurator2) let table = ExampleTableViewController(dataSource: dataSource, configurator: aggregate) add(child: table, container: view) &#123; childView in //布局约束 childView.frame = view.frame &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"multicast delegates","slug":"multicast","date":"2021-07-12T10:30:10.000Z","updated":"2021-07-12T10:19:35.110Z","comments":true,"path":"2021/07/12/multicast/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/12/multicast/","excerpt":"我们知道delegate在OC中是比较经常使用的代理模式。主要作用是将某对象的行为属性传递到另一个对象。以及绑定代理都用用weak弱引用。1234567891011protocol MyClassDelegate: class &#123; func doFoo()&#125;class MyClass &#123; weak var delegate: MyClassDelegate? func foo() &#123; delegate?.doFoo() &#125;&#125;问题：假如我不用埋点方法替换foo等,在用户调用触发doFoo()方法，可以怎样做日志行为分析？前提是delegate又不能强制破坏或替换。1234567891011121314151617181920212223242526272829303132333435class MulticastDelegate&lt;T&gt; &#123; private let delegates: NSHashTable&lt;AnyObject&gt; = NSHashTable.weakObjects() func add(_ delegate: T) &#123; delegates.add(delegate as AnyObject) &#125; func remove(_ delegateToRemove: T) &#123; for delegate in delegates.allObjects.reversed() &#123; if delegate === delegateToRemove as AnyObject &#123; delegates.remove(delegate) &#125; &#125; &#125; func invoke(_ invocation: (T) -&gt; Void) &#123; for delegate in delegates.allObjects.reversed() &#123; invocation(delegate as! T) &#125; &#125;&#125;class MyClassMulticastDelegate: MyClassDelegate &#123; private let multicast = MulticastDelegate&lt;MyClassDelegate&gt;() init(_ delegates: [MyClassDelegate]) &#123; delegates.forEach(multicast.add) &#125; func doFoo() &#123; multicast.invoke &#123; $0.doFoo() &#125; //调用代理对象的doFoo方法 &#125;&#125; 12345678910111213141516class AnalyticsEngine &#123;&#125;extension AnalyticsEngine: MyClassDelegate &#123; func doFoo() &#123; print(\"Track foo event\") &#125;&#125;let logger = Logger()let analyticsEngine = AnalyticsEngine()let delegate = MyClassMulticastDelegate([logger, analyticsEngine])let myClass = MyClass()myClass.delegate = delegatemyClass.foo()","text":"我们知道delegate在OC中是比较经常使用的代理模式。主要作用是将某对象的行为属性传递到另一个对象。以及绑定代理都用用weak弱引用。1234567891011protocol MyClassDelegate: class &#123; func doFoo()&#125;class MyClass &#123; weak var delegate: MyClassDelegate? func foo() &#123; delegate?.doFoo() &#125;&#125;问题：假如我不用埋点方法替换foo等,在用户调用触发doFoo()方法，可以怎样做日志行为分析？前提是delegate又不能强制破坏或替换。1234567891011121314151617181920212223242526272829303132333435class MulticastDelegate&lt;T&gt; &#123; private let delegates: NSHashTable&lt;AnyObject&gt; = NSHashTable.weakObjects() func add(_ delegate: T) &#123; delegates.add(delegate as AnyObject) &#125; func remove(_ delegateToRemove: T) &#123; for delegate in delegates.allObjects.reversed() &#123; if delegate === delegateToRemove as AnyObject &#123; delegates.remove(delegate) &#125; &#125; &#125; func invoke(_ invocation: (T) -&gt; Void) &#123; for delegate in delegates.allObjects.reversed() &#123; invocation(delegate as! T) &#125; &#125;&#125;class MyClassMulticastDelegate: MyClassDelegate &#123; private let multicast = MulticastDelegate&lt;MyClassDelegate&gt;() init(_ delegates: [MyClassDelegate]) &#123; delegates.forEach(multicast.add) &#125; func doFoo() &#123; multicast.invoke &#123; $0.doFoo() &#125; //调用代理对象的doFoo方法 &#125;&#125; 12345678910111213141516class AnalyticsEngine &#123;&#125;extension AnalyticsEngine: MyClassDelegate &#123; func doFoo() &#123; print(\"Track foo event\") &#125;&#125;let logger = Logger()let analyticsEngine = AnalyticsEngine()let delegate = MyClassMulticastDelegate([logger, analyticsEngine])let myClass = MyClass()myClass.delegate = delegatemyClass.foo() 统计搜索文字点击按钮日志分析1234567891011121314151617final class SearchBarMulticastDelegate: NSObject, UISearchBarDelegate &#123; private let multicast = MulticastDelegate&lt;UISearchBarDelegate&gt;() init(delegates: [UISearchBarDelegate]) &#123; super.init() delegates.forEach(multicast.add) &#125; func searchBarSearchButtonClicked(_ searchBar: UISearchBar) &#123; multicast.invoke &#123; $0.searchBarSearchButtonClicked?(searchBar) &#125; &#125; func searchBarCancelButtonClicked(_ searchBar: UISearchBar) &#123; multicast.invoke &#123; $0.searchBarCancelButtonClicked?(searchBar) &#125; &#125;&#125; 1234567891011121314151617181920class SearchViewController: UIViewController &#123; let searchBar = UISearchBar()&#125;class SearchResultsController: UIViewController, UISearchBarDelegate &#123; private unowned var svc: SearchViewController init(_ svc: SearchViewController) &#123; self.svc = svc super.init(nibName: nil, bundle: nil) &#125; func searchBarSearchButtonClicked(_ searchBar: UISearchBar) &#123; // Show over `SearchViewController` &#125; func searchBarCancelButtonClicked(_ searchBar: UISearchBar) &#123; // Hide from `SearchViewController` &#125;&#125; 构建多个delegate,组合组装成NSHashTable,再SearchBarMulticastDelegate内部实现每个delegate手动invoke调用方法。1234567891011extension AnalyticsEngine: UISearchBarDelegate &#123;&#125;extension Logger: UISearchBarDelegate &#123;&#125;let search = SearchViewController()let logger = Logger()let analyticsEngine = AnalyticsEngine()let searchResults = SearchResultsViewController(search)let searchBarMulticastDelegate = SearchBarMulticastDelegate(delegates: [logger, analyticsEngine, searchResults])search.searchBar.delegate = searchBarMulticastDelegate","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.littlewhale.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"中介者(mediator)模式","slug":"mediator","date":"2021-07-12T08:50:10.000Z","updated":"2021-07-12T08:10:19.167Z","comments":true,"path":"2021/07/12/mediator/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/12/mediator/","excerpt":"","text":"中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。在MVC 框架中，其中C（控制器）就是 M（模型）和 V（视图）的中介者。我们接下来用一个搜索视图来展示中介者模式:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667protocol HistoryView &#123; var isHidden: Bool &#123; get set &#125; func setHistory(_ history: [String])&#125;protocol HistoryRepository &#123; var history: [String] &#123; get &#125; func addSearchTerm(_ term: String)&#125;class SearchHistoryMediator: NSObject &#123; private let searchBar: UISearchBar private var historyView: HistoryView private var observasion: NSKeyValueObservation? private let historyRepository: HistoryRepository init(searchBar: UISearchBar, historyView: HistoryView, historyRepository: HistoryRepository) &#123; self.searchBar = searchBar self.historyView = historyView self.historyRepository = historyRepository super.init() self.historyView.isHidden = true self.historyView.setHistory(historyRepository.history) searchBar.delegate = self observasion = searchBar.observe(\\.text) &#123; [weak self] (searchBar, _) in self?.historyView.isHidden = searchBar.text?.isEmpty ?? false &#125; &#125;&#125;extension SearchHistoryMediator: UISearchBarDelegate &#123; func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) &#123; historyView.isHidden = false &#125; func searchBarTextDidEndEditing(_ searchBar: UISearchBar) &#123; historyView.isHidden = true &#125; func searchBarSearchButtonClicked(_ searchBar: UISearchBar) &#123; historyView.isHidden = true if let text = searchBar.text, !text.isEmpty &#123; historyRepository.addSearchTerm(text) historyView.setHistory(historyRepository.history) searchBar.text = nil &#125; searchBar.resignFirstResponder() &#125; func searchBarCancelButtonClicked(_ searchBar: UISearchBar) &#123; historyView.isHidden = true searchBar.resignFirstResponder() &#125;&#125;//在控制器中使用中介者private(set) lazy var mediator: SearchHistoryMediator = &#123; return SearchHistoryMediator(searchBar: searchBar, historyView: historyView, historyRepository: historyRepository)&#125;()override func viewDidLoad() &#123; super.viewDidLoad() _ = mediator&#125; 优点：降低了类的复杂度，将一对多转化成了一对一。各个类之间的解耦，减少对象之间的关联性，让每一个对象都能够独立","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.littlewhale.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"有限状态机驱动设计","slug":"controllersStates","date":"2021-07-12T07:50:10.000Z","updated":"2021-07-12T07:09:03.885Z","comments":true,"path":"2021/07/12/controllersStates/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/12/controllersStates/","excerpt":"有限状态自动机（FSM “finite state machine” 或者FSA “finite state automaton” ）是为研究有限内存的计算过程和某些语言类而抽象出的一种计算模型。有限状态自动机拥有有限数量的状态，每个状态可以迁移到零个或多个状态，输入字串决定执行哪个状态的迁移。有限状态自动机可以表示为一个有向图。有限状态自动机是自动机理论的研究对象。我们来看以下片段代码：1234567class ViewController &#123; @IBOutlet var tableView: UITableView! @IBOutlet var errorLabel: UILabel! @IBOutlet var emptyStateLabel: UILabel! @IBOutlet var activityIndicator: UIActivityIndicatorView! // Some implementation&#125;我们得出4种状态，且每种独立存在: 显示数据 是否在加载数据中 是否显示错误 空状态我们在控制器中定义该枚举：12345678extension ViewController &#123; enum State &#123; case loading case showingData([Item]) case empty case error(Error) &#125;&#125;","text":"有限状态自动机（FSM “finite state machine” 或者FSA “finite state automaton” ）是为研究有限内存的计算过程和某些语言类而抽象出的一种计算模型。有限状态自动机拥有有限数量的状态，每个状态可以迁移到零个或多个状态，输入字串决定执行哪个状态的迁移。有限状态自动机可以表示为一个有向图。有限状态自动机是自动机理论的研究对象。我们来看以下片段代码：1234567class ViewController &#123; @IBOutlet var tableView: UITableView! @IBOutlet var errorLabel: UILabel! @IBOutlet var emptyStateLabel: UILabel! @IBOutlet var activityIndicator: UIActivityIndicatorView! // Some implementation&#125;我们得出4种状态，且每种独立存在: 显示数据 是否在加载数据中 是否显示错误 空状态我们在控制器中定义该枚举：12345678extension ViewController &#123; enum State &#123; case loading case showingData([Item]) case empty case error(Error) &#125;&#125; 我们在控制器中加载数据的过程，状态的变化:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263protocol ItemService &#123; func loadItems(completion: @escaping (Result&lt;[Item]&gt;) -&gt; Void)&#125;class ViewController: UIViewController &#123; @IBOutlet var tableView: UITableView! @IBOutlet var errorLabel: UILabel! @IBOutlet var emptyStateLabel: UILabel! @IBOutlet var activityIndicator: UIActivityIndicatorView! private var items: [Item] = [] var itemService: ItemService! private var state: State = .empty &#123; didSet &#123; hideAll() switch state &#123; case .empty: emptyStateLabel.isHidden = false case .error(let error): errorLabel.isHidden = false errorLabel.text = error.localizedDescription case .loading: activityIndicator.isHidden = false activityIndicator.startAnimating() case .showingData(let items): self.items = items tableView.isHidden = false tableView.reloadData() &#125; &#125; &#125; override func viewDidLoad() &#123; super.viewDidLoad() loadData() &#125; private func loadData() &#123; state = .loading itemService.loadItems &#123; [weak self] result in switch result &#123; case .success(let items) where items.isEmpty: self?.state = .empty case .success(let items): self?.state = .showingData(items) case .failure(let error): self?.state = .error(error) &#125; &#125; &#125; private func hideAll() &#123; tableView.isHidden = true errorLabel.isHidden = true activityIndicator.isHidden = true activityIndicator.stopAnimating() emptyStateLabel.isHidden = true &#125;&#125; 用状态设计模式实现有限状态机用状态设计模式来改进viewcontroller 中的状态机: 为每个状态独立一个子类，分别控制状态对应的响应变化。 首先应该定义一个State根class, 提供一个静态工厂方法，构建当前传递进来的枚举状态构建所对应的状态子类。 状态方法enter()为标记且响应每一个状态进入后所响应执行的业务变化。123456789101112131415161718192021222324252627282930313233343536373839class State &#123; weak var viewController: ViewController! init(viewController: ViewController) &#123; self.viewController = viewController &#125; static func state(_ state: Kind, viewController: ViewController) -&gt; State &#123; switch state &#123; case .showingData(let items): return ShowingDataState(items: items, viewController: viewController) case .loading: return LoadingState(viewController: viewController) case .empty: return EmptyState(viewController: viewController) case .error(let error): return ErrorState(error: error, viewController: viewController) &#125; &#125; func enter() &#123; viewController.tableView.isHidden = true viewController.errorLabel.isHidden = true viewController.activityIndicator.isHidden = true viewController.activityIndicator.stopAnimating() viewController.emptyStateLabel.isHidden = true &#125;&#125;extension State &#123; enum Kind &#123; case loading case showingData([Item]) case empty case error(Error) &#125;&#125; 分别实现不同状态的子类，并且final修饰，保证子类不可再继承。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748final class ShowingDataState: State &#123; let items: [Item] init(items: [Item], viewController: ViewController) &#123; self.items = items super.init(viewController: viewController) &#125; override func enter() &#123; super.enter() viewController.items = items viewController.tableView.isHidden = false viewController.tableView.reloadData() &#125;&#125;final class LoadingState: State &#123; override func enter() &#123; super.enter() viewController.emptyStateLabel.isHidden = false &#125;&#125;final class EmptyState: State &#123; override func enter() &#123; super.enter() viewController.emptyStateLabel.isHidden = false &#125;&#125;final class ErrorState: State &#123; let error: Error init(error: Error, viewController: ViewController) &#123; self.error = error super.init(viewController: viewController) &#125; override func enter() &#123; super.enter() viewController.errorLabel.isHidden = false viewController.errorLabel.text = error.localizedDescription &#125;&#125; OK,接下来我们看一些viewController如何使用有限状态机:12345678910111213141516171819202122232425262728293031323334353637class ViewController: UIViewController &#123; @IBOutlet var tableView: UITableView! @IBOutlet var errorLabel: UILabel! @IBOutlet var emptyStateLabel: UILabel! @IBOutlet var activityIndicator: UIActivityIndicatorView! var items: [Item] = [] var itemService: ItemService! lazy var state = State.state(.empty, viewController: self) override func viewDidLoad() &#123; super.viewDidLoad() loadData() &#125; private func loadData() &#123; state = .state(.loading, viewController: self) state.enter() itemService.loadItems &#123; [weak self] result in guard let self = self else &#123; return &#125; switch result &#123; case .success(let items) where items.isEmpty: self.state = .state(.empty, viewController: self) case .success(let items): self.state = .state(.showingData(items), viewController: self) case .failure(let error): self.state = .state(.error(error), viewController: self) &#125; self.state.enter() &#125; &#125;&#125; 这样对于状态机状态发生变化的时候，self.state.enter()方法响应状态变更后发生的事情，这样代码是不是很简洁？haha。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"在Swift中实现“多继承”","slug":"inheritance","date":"2021-07-12T02:50:10.000Z","updated":"2021-07-12T03:08:19.125Z","comments":true,"path":"2021/07/12/inheritance/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/12/inheritance/","excerpt":"Swift能实现多继承吗？虽然多继承在C++中可以实现，但在Swift中，是不能够实现多继承的。但一个class可以遵循多个协议，只能继承一个父类。但值类型比如 struct , enum 就不存在继承这么一说，但还是可以遵循多个协议的。Swift只支持协议多继承如：1234567protocol ChildAB:ChildA,ChildB &#123;&#125;class MyClass: ChildAB &#123; func method() &#123; &#125;&#125; struct或class可遵循多个协议实现假“多继承”比如以下片段给UIView扩展实现多个协议的方法：12345678910111213141516171819202122232425262728293031323334353637protocol Blinkable &#123; func blink()&#125;extension Blinkable where Self: UIView &#123; func blink() &#123; alpha = 1 UIView.animate( withDuration: 0.5, delay: 0.25, options: [.repeat, .autoreverse], animations: &#123; self.alpha = 0 &#125;) &#125;&#125;// MARK: - Scalableprotocol Scalable &#123; func scale()&#125;extension Scalable where Self: UIView &#123; func scale() &#123; transform = .identity UIView.animate( withDuration: 0.5, delay: 0.25, options: [.repeat, .autoreverse], animations: &#123; self.transform = CGAffineTransform(scaleX: 1.5, y: 1.5) &#125;) &#125;&#125;这样，我们申明一个View的实例，那么可以调用blink,scale 等方法。123extension UIView: Scalable, Blinkable &#123;&#125;aView.blink()aView.scale()","text":"Swift能实现多继承吗？虽然多继承在C++中可以实现，但在Swift中，是不能够实现多继承的。但一个class可以遵循多个协议，只能继承一个父类。但值类型比如 struct , enum 就不存在继承这么一说，但还是可以遵循多个协议的。Swift只支持协议多继承如：1234567protocol ChildAB:ChildA,ChildB &#123;&#125;class MyClass: ChildAB &#123; func method() &#123; &#125;&#125; struct或class可遵循多个协议实现假“多继承”比如以下片段给UIView扩展实现多个协议的方法：12345678910111213141516171819202122232425262728293031323334353637protocol Blinkable &#123; func blink()&#125;extension Blinkable where Self: UIView &#123; func blink() &#123; alpha = 1 UIView.animate( withDuration: 0.5, delay: 0.25, options: [.repeat, .autoreverse], animations: &#123; self.alpha = 0 &#125;) &#125;&#125;// MARK: - Scalableprotocol Scalable &#123; func scale()&#125;extension Scalable where Self: UIView &#123; func scale() &#123; transform = .identity UIView.animate( withDuration: 0.5, delay: 0.25, options: [.repeat, .autoreverse], animations: &#123; self.transform = CGAffineTransform(scaleX: 1.5, y: 1.5) &#125;) &#125;&#125;这样，我们申明一个View的实例，那么可以调用blink,scale 等方法。123extension UIView: Scalable, Blinkable &#123;&#125;aView.blink()aView.scale() 多个协议扩展相同方法：对象方法调用时的菱形问题123456789101112131415161718192021222324252627282930protocol Root &#123; func method()&#125;extension Root &#123; func method() &#123; print(\"Method from Root\") &#125;&#125;protocol ChildA: Root &#123;&#125;extension ChildA &#123; func method() &#123; print(\"Method from ChildA\") &#125;&#125;protocol ChildB: Root &#123;&#125;extension ChildB &#123; func method() &#123; print(\"Method from ChildB\") &#125;&#125;class MyClass: ChildA, ChildB &#123;&#125; // Error: Type 'MyClass' does not conform to protocol 'Root'let classA = MyClass()classA.method() //此刻会发生什么？ 很明显编译不通过，由于ChildA ,ChildB 两协议都扩展了协议method方法，此刻模棱两可，程序不知道method方法被调用的时候执行的是哪个协议扩展的方法。 如何解决问题菱形？在遵循该方法的类里，实现该协议的方法。不使用协议ChildA,ChildB默认的扩展方法，这样编译器就知道调用的是自身的method()方法12345class MyClass: ChildA, ChildB &#123; func method() &#123; print(\"hello,it's MyClass\") &#125;&#125;尽量让协议的方法名不重名。在ChildA或者ChildB中扩展不同的实现方法，然后遵循协议的类或者结构体实现method方法根据需要调用methodA 还是methodB123456789101112131415161718192021extension ChildA &#123; func methodA() &#123; print(\"Method from ChildA\") &#125;&#125;extension ChildB &#123; func methodB() &#123; print(\"Method from ChildB\") &#125;&#125;class MyClass: ChildA, ChildB &#123; func method() &#123; if 条件 &#123; methodA() &#125;else&#123; methodB() &#125; &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"创建一个线程安全的字典","slug":"safeDic","date":"2021-07-09T09:30:10.000Z","updated":"2021-07-12T03:01:33.187Z","comments":true,"path":"2021/07/09/safeDic/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/09/safeDic/","excerpt":"Swift与OC最大的区别就是新增了值类型Struct, let变量修饰后无法再次被赋值实现真正的immutable，也就是说一旦赋值不能再次修改。虽然OC中定义NSArray *arr 也是一个immutable，但是arr对象指针指向还可以被再次重新赋值。OC是一门运行时语言，arr所指向的变量都是运行时获取对象。OC中使用immutable不直接等同于线程安全。Objective-C中存在深拷贝、浅拷贝，即使你调用一个[NSMutableArray Copy]得到的NSArray也不代表这个数组中的对象都是经过深拷贝。 我们先看一下如下代码会造成线程安全问题？：123if (self.xxx) &#123; [self.dict setObject:@\"ah\" forKey:self.xxx];&#125;在单线程模式下肯定是没啥问题，但在多线程情况下比如线程A,线程B两者都同时进入了if条件，当A正要执行set操作,B已经对self.dict = nil。那么线程A肯定是不能设置成功的。还有另外一种情况，当我们的数据资源比如集合，多线程对资源进行争夺。如添加和移除操作。为了保证最终结果的准确性，我们通常会给操作代码加锁。123OSSpinLock(&amp;_lock);[self.array addObject:@\"data1\"];OSSpinUnlock(&amp;_lock);","text":"Swift与OC最大的区别就是新增了值类型Struct, let变量修饰后无法再次被赋值实现真正的immutable，也就是说一旦赋值不能再次修改。虽然OC中定义NSArray *arr 也是一个immutable，但是arr对象指针指向还可以被再次重新赋值。OC是一门运行时语言，arr所指向的变量都是运行时获取对象。OC中使用immutable不直接等同于线程安全。Objective-C中存在深拷贝、浅拷贝，即使你调用一个[NSMutableArray Copy]得到的NSArray也不代表这个数组中的对象都是经过深拷贝。 我们先看一下如下代码会造成线程安全问题？：123if (self.xxx) &#123; [self.dict setObject:@\"ah\" forKey:self.xxx];&#125;在单线程模式下肯定是没啥问题，但在多线程情况下比如线程A,线程B两者都同时进入了if条件，当A正要执行set操作,B已经对self.dict = nil。那么线程A肯定是不能设置成功的。还有另外一种情况，当我们的数据资源比如集合，多线程对资源进行争夺。如添加和移除操作。为了保证最终结果的准确性，我们通常会给操作代码加锁。123OSSpinLock(&amp;_lock);[self.array addObject:@\"data1\"];OSSpinUnlock(&amp;_lock);在OC中，修饰属性通常会用非原子性nonatomic。当属性设置在多线程并发情况下，有可能会崩溃。 self.xxx = “111” 其实是调用了xxx属性的setter方法。1234567- (void)setXxx:(NSString *)newXXX &#123; if (newXXX != _xxx) &#123; [newXXX retain]; [_xxx release]; _userName = newXXX; &#125;&#125;由于没有加锁，当多个线程都进入if条件判断后，会对_xxx多次release,这就直接crash掉。可以用以下代码试验,在多次执行后，随机地可能crash掉：12345for (int i = 0; i &lt; 5000; i++) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; self.data = [[NSMutableData alloc] init]; &#125;);&#125;而修饰词atomic修饰保证属性的原子性，系统给属性的get、set方法包装一层互斥锁。但苹果不建议我们使用，因为频繁读取性能损耗非常大。并且也只能保证set,get的安全性。如果属性对象是数组，假设在子线程A中对数组写操作，而主线程一直在读数据，[self.arr objectAtIndex:index] 就很容易出现越界崩溃。 atomic并不能起到线程安全性作用。 那么，我们要怎么样才能保证可变数组的线程安全问题呢？通过栅栏函数dispatch_barrier可保证集合的线程安全。123456789101112131415161718192021222324252627282930313233343536@interface QGYSafeDic: NSObject- (void)qgy_setSafeObject: (id)object forKey:(NSString *)key;- (id)qgy_safeObjectForKey: (NSString *)key;@end@implementation QGYSafeDic&#123; NSMutableDictionary* _dic; dispatch_queue_t _concurrentQueue ;&#125; - (instancetype)init &#123; if (self = [super init])&#123; _concurrentQueue = dispatch_queue_create(\"com.qgy.syncQueue\", DISPATCH_QUEUE_CONCURRENT); _dic = [NSMutableDictionary dictionary]; &#125; return self; &#125;- (void)qgy_setSafeObject: (id)object forKey:(NSString *)key&#123; key = [key copy]; dispatch_barrier_async(_concurrentQueue, ^&#123; [_dic setObject:object forKey:key]; &#125;);&#125;- (id)qgy_safeObjectForKey: (NSString *)key&#123; __block NSString *tempObj; dispatch_sync(_concurrentQueue, ^&#123; tempObj = [_dic objectForKey:key]; &#125;); return tempObj;&#125;@end Swift 版本：123456789101112131415161718192021222324public class SafeDict&lt;Key: Hashable, Value&gt;: CustomDebugStringConvertible &#123; private var dictStorage = [Key: Value]() private let queue = DispatchQueue(label: \"com.qgy.\\(UUID().uuidString)\", qos: .utility, attributes: .concurrent, autoreleaseFrequency: .inherit, target: .global()) public init() &#123;&#125; public subscript(key: Key) -&gt; Value? &#123; get &#123; queue.sync &#123; dictStorage[key] &#125; &#125; set &#123; queue.async(flags: .barrier) &#123; [weak self] in self?.dictStorage[key] = newValue &#125; &#125; &#125; public var debugDescription: String &#123; return dictStorage.debugDescription &#125;&#125;测试：1234567891011121314151617181920212223class MyTest &#123; var atomicDict = SafeDict&lt;String, Int&gt;() func test()&#123; let g = DispatchGroup() for index in (0..&lt;10) &#123; g.enter() DispatchQueue.global().async &#123; self.atomicDict[\"key\\(index)\"] = index g.leave() &#125; &#125; g.notify(queue: .main, execute: &#123; print(self.atomicDict) &#125;) &#125;&#125;let obj = MyTest()obj.test()//结果：[\"key8\": 8, \"key0\": 0, \"key2\": 2, \"key9\": 9, \"key6\": 6, \"key3\": 3, \"key7\": 7, \"key5\": 5, \"key1\": 1, \"key4\": 4]","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"给数组元素去重","slug":"hash","date":"2021-07-08T07:30:10.000Z","updated":"2021-07-08T07:06:29.076Z","comments":true,"path":"2021/07/08/hash/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/08/hash/","excerpt":"","text":"一个数组，要对元素进行去重操作有两种方式，要么重写equals方法做比较，要么利用Hash值做比较。假设对象为点Point1234struct Point &#123; let x: Int let y: Int&#125; 让对象实现equals方法12345extension Point: Equatable &#123; static func == (lhs: Point, rhs: Point) -&gt; Bool &#123; return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y &#125;&#125; 接着，我们对Array做扩展，新增去重方法并返回新数组：1234567891011extension Array where Element: Equatable &#123; func uniqueElements() -&gt; [Element] &#123; var out = [Element]() for element in self &#123; if !out.contains(element) &#123; out.append(element) &#125; &#125; return out &#125;&#125; 用Hash值方式比较对象把元素对象放至Set无序集合中，由于Set根据Hash值来存储，可存储唯一Hash值对象保证不重复。准备一个空数组接收。1extension Point: Hashable &#123;&#125;123456789101112131415extension Array where Element: Hashable &#123; func uniqueElements() -&gt; [Element] &#123; var seen = Set&lt;Element&gt;() var out = [Element]() for element in self &#123; if !seen.contains(element) &#123; out.append(element) seen.insert(element) &#125; &#125; return out &#125;&#125;将代码用compactMap改进一下：遍历每一个元素并返回不为nil的元素。我们根据元素是否存在Set集合中为条件，当存在集合中时返回nil。12345678910111213extension Array where Element: Hashable &#123; func uniqueElements() -&gt; [Element] &#123; var seen = Set&lt;Element&gt;() return self.compactMap &#123; element in guard !seen.contains(element) else &#123; return nil &#125; seen.insert(element) return element &#125; &#125;&#125;当我们不考虑原元素对象顺序的情况下，可以快速对元素去重123456extension Array where Element: Hashable &#123; func unsortedUniqueElements() -&gt; [Element] &#123; let set = Set(self) return Array(set) &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"何时使用weak self 防止内存泄露","slug":"weak","date":"2021-07-08T03:50:10.000Z","updated":"2021-07-08T04:28:57.745Z","comments":true,"path":"2021/07/08/weak/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/08/weak/","excerpt":"我们都想写得一手好代码。这包含防止内存泄露，当在写闭包时业务如果需要用到self，我们会使用[weak self] 修饰。但为什么需要弱捕获呢？是否任何情况下在闭包里都要用weak? 接下来我们将用捕获列表来回答这几个问题。我们将讲解到不同的捕获，以及什么时候用合适的捕获去处理问题。 什么是捕获列表我们先看以下代码片段，调用闭包后显示的结果:12345678var name = \"qiu\"var appendToName = &#123; (string: String) -&gt; String in return name.appending(string)&#125;let one = appendToName(\"gaoying\") //qiugaoyingname = \"liu\"let two = appendToName(\"gaoying\") //liugaoying闭包可对同一作用域范围内的属性做引用，也就是闭包内持有的属性在同一上下文作用域内变更受影响。我们再观察以下代码： 12345678var name = \"qiu\"var appendToName = &#123; [name] (string: String) -&gt; String in return name.appending(string)&#125;let one = appendToName(\"gaoying\") //qiugaoyingname = \"liu\"let two = appendToName(\"gaoying\") //qiugaoying 这时输出的结果都为qiugaoying。[name] 将属性name放在闭包的捕获列表，明确地告诉闭包强持有闭包首次调用时的name值。如果要在闭包捕获列表内捕获多个值，则用逗号隔开，如[property, anotherProperty] in 方式。","text":"我们都想写得一手好代码。这包含防止内存泄露，当在写闭包时业务如果需要用到self，我们会使用[weak self] 修饰。但为什么需要弱捕获呢？是否任何情况下在闭包里都要用weak? 接下来我们将用捕获列表来回答这几个问题。我们将讲解到不同的捕获，以及什么时候用合适的捕获去处理问题。 什么是捕获列表我们先看以下代码片段，调用闭包后显示的结果:12345678var name = \"qiu\"var appendToName = &#123; (string: String) -&gt; String in return name.appending(string)&#125;let one = appendToName(\"gaoying\") //qiugaoyingname = \"liu\"let two = appendToName(\"gaoying\") //liugaoying闭包可对同一作用域范围内的属性做引用，也就是闭包内持有的属性在同一上下文作用域内变更受影响。我们再观察以下代码： 12345678var name = \"qiu\"var appendToName = &#123; [name] (string: String) -&gt; String in return name.appending(string)&#125;let one = appendToName(\"gaoying\") //qiugaoyingname = \"liu\"let two = appendToName(\"gaoying\") //qiugaoying 这时输出的结果都为qiugaoying。[name] 将属性name放在闭包的捕获列表，明确地告诉闭包强持有闭包首次调用时的name值。如果要在闭包捕获列表内捕获多个值，则用逗号隔开，如[property, anotherProperty] in 方式。 关于内存泄露12345678910class MyClass &#123;&#125;var instance: MyClass? = MyClass()var aClosure = &#123; [instance] in print(instance)&#125;aClosure() // MyClassinstance = nilaClosure() // MyClass 如上代码片段，当instance = nil之后，闭包再次调用，此时instance仍然在闭包内被强捕获。即虽然instance置为nil，但闭包里强捕获的属性没有被释放。此刻instance捕获的是引用类型，那么闭包强指针引用该对象。我们知道在内存管理时候，引用类型对象只要引用计数大于1，那么再内存中是不会被回收的，此刻，即造成了内存泄露。 如果强捕获的属性是值类型(结构体或者枚举)，那么强捕获的时候将发生copy。 通常情况下，我们是不希望这种情况发生的。举一个场景：当我们在ViewController执行网络请求的时候，在请求结果回来之前，我们dismissed了控制器，如果网络请求回调的必要内强捕获了控制器，那么内存中是仍然存在该ViewController。当来回切换的时候，是不是造成了很多内存泄露呢？那么我们怎么去解决这个问题呢？把强捕获改成弱捕获就行了，使用weak关键字。123456789101112class MyClass &#123;&#125;var instance: MyClass? = MyClass()var aClosure = &#123; [weak instance] in print(instance) guard strongSelf = instance else &#123; return &#125; //do something&#125;aClosure() // MyClassinstance = nilaClosure() // nil在闭包调用之前，如果对象销毁了继续调用闭包可能会出一些潜在的业务bug。如果你想立即抛出异常或直接让程序crash掉，这样有助于及早地发现问题。你也可以用关键字unowned关键字进行捕获。123456789101112class MyClass &#123;&#125;var instance: MyClass? = MyClass()var aClosure = &#123; [unowned instance] in print(instance) guard strongSelf = instance else &#123; return &#125; //do something&#125;aClosure() // MyClassinstance = nilaClosure() // Crash 闭包内何时直接用 self 当self 指的是值类型(结构体、枚举)时候，可以直接用self. 因为结构体没有指针引用他们，在闭包内也不会出现内存泄露一说。 当闭包和self对象无直接持有关系时候，比如DispatchQueue.123456class MyClass &#123; func dispatchSomething() &#123; DispatchQueue.global().async &#123; &#125; &#125;&#125; 在调用dispatchSomething方法后，异步闭包体会立即执行，在闭包体可以放心的使用self。如果闭包是对象的某一事件回调你需要留意self是否弱引用避免引起循环引用。有个最简单的方法判断调用的函数闭包是否被持有：判断是否有关键字@escaping。 闭包里何时用强捕获变量强捕获用的场景比较少。以下有一个例子，如在网络请求后，通过本地存储CoreData或者Sqlite把数据持久化。1234567891011struct SomeDataSource &#123; var storage: MyDataStore //class let networking: NetworkingLayer // more properties func refreshData() &#123; networking.refresh &#123; [storage] data in storage.persist(data) &#125; &#125;&#125;这个时候，无论页面销毁SomeDataSource，只要网络请求结果回来，都能够保证数据被持久化以便下次使用。而且storage只捕获首次调用refreshData时候的storage变量。（假设）后期无论对storage更改，storage仍然是之前旧的对象。 何时使用Weak 或者 unowned 关键字弱捕获是我们比较常用且最好默认的一种捕获选择。当你不想让一个已释放对象还在闭包内执行时候，或者当你调用的函数闭包被应用时，这个时候需考虑用弱捕获。弱捕获的属性记得给可选值，因为可能是nil。这样给nil发送消息的时候就不至于崩溃。使用weak或者unowned能100%确保引用类型在销毁后也能从内存中回收，不会出现内存泄露的情况。如果你实在不知道用哪种捕获方式的时候，那就用它吧😝。\b","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"使用Result（Swift5）","slug":"result","date":"2021-07-07T08:30:10.000Z","updated":"2021-07-07T08:23:21.671Z","comments":true,"path":"2021/07/07/result/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/07/result/","excerpt":"在我们设计网络层响应结果的时候，Result是大家用的比较多的。和Optional有点类似，它是用来表述返回类型是成功或者失败。在Swift5.0中，Swift团队已经把Result加入到了标准库。这篇文章将讲解到何时去使用Result,以及怎样使用Result。上篇文章，我们讲到Swift异常处理，在处理时候用do{}catch{}捕捉异常,以及在方法名后通过throws关键字将异常往上层抛。和抛错误不同的是，在代码中用Result作为返回类型可以达到我们需要的效果。更大的不同是，Result可以用于在异步处理时候，如鱼得水般地优雅处理成功与失败的回调返回。在讲解之前，我们先看一下以下片段1代码：12345678910func loadData(from url: URL, completion:@escaping (Data?) -&gt; Void) throws &#123; URLSession.shared.dataTask(with: url) &#123; data, response, error in if let error = error &#123; throw error &#125; if let data = data &#123; completion(data) &#125; &#125;.resume()&#125;按照以往的方式，当error有异常时候，我们进行抛出异常，然后方法上也加上throws。假设以上代码编译通过，那么在调用的时候代码片段如下：123456789do &#123; try loadData(from: aURL) &#123; data in print(\"fetched data\") &#125; print(\"This will be executed before any data is fetched from the network.\") //这行代码会被先执行。由于loadData方法是异步处理请求数据，就算发生错误，error抛出存在一定的执行时长。这就违背了异常捕捉而中止的性质了，也谈不上异常捕捉。&#125; catch &#123; print(error)&#125;","text":"在我们设计网络层响应结果的时候，Result是大家用的比较多的。和Optional有点类似，它是用来表述返回类型是成功或者失败。在Swift5.0中，Swift团队已经把Result加入到了标准库。这篇文章将讲解到何时去使用Result,以及怎样使用Result。上篇文章，我们讲到Swift异常处理，在处理时候用do{}catch{}捕捉异常,以及在方法名后通过throws关键字将异常往上层抛。和抛错误不同的是，在代码中用Result作为返回类型可以达到我们需要的效果。更大的不同是，Result可以用于在异步处理时候，如鱼得水般地优雅处理成功与失败的回调返回。在讲解之前，我们先看一下以下片段1代码：12345678910func loadData(from url: URL, completion:@escaping (Data?) -&gt; Void) throws &#123; URLSession.shared.dataTask(with: url) &#123; data, response, error in if let error = error &#123; throw error &#125; if let data = data &#123; completion(data) &#125; &#125;.resume()&#125;按照以往的方式，当error有异常时候，我们进行抛出异常，然后方法上也加上throws。假设以上代码编译通过，那么在调用的时候代码片段如下：123456789do &#123; try loadData(from: aURL) &#123; data in print(\"fetched data\") &#125; print(\"This will be executed before any data is fetched from the network.\") //这行代码会被先执行。由于loadData方法是异步处理请求数据，就算发生错误，error抛出存在一定的执行时长。这就违背了异常捕捉而中止的性质了，也谈不上异常捕捉。&#125; catch &#123; print(error)&#125;以上片段1代码编译显然报错，很不幸，dataTask处理方法API并没有throws关键字。那要怎么处理异常呢？这个时候Result派上用场了。在讲解Result之前，我们首先来看一下Result的核心源码。12345678910/// A value that represents either a success or a failure, including an/// associated value in each case.@frozen public enum Result&lt;Success, Failure&gt; where Failure : Error &#123; /// A success, storing a `Success` value. case success(Success) /// A failure, storing a `Failure` value. case failure(Failure)&#125; 然后用Result进行改造,这样就很友好地处理了成功和异常的结果。123456789101112131415161718func loadData(from url: URL, completion:@escaping (Result&lt;Data, URLError&gt;) -&gt; Void) &#123; URLSession.shared.dataTask(with: url) &#123; data, response, error in if let urlError = error as? URLError &#123; completion(.failure(urlError)) &#125; if let data = data &#123; completion(.success(data)) &#125; &#125;.resume()&#125;loadData(from: URL(string: \"http://api.littleWhale/myAvatar\")!) &#123; result in guard let data = try? result.get() else &#123; return &#125; print(data)&#125;继续再看一例子：拿到data,需要将它转成图片。12345678910111213enum ConversionFailure: Error &#123; case invalidData&#125;func convertToImage(_ data: Data, completionHandler: @escaping (Result&lt;UIImage, ConversionFailure&gt;) -&gt; Void) &#123; DispatchQueue.global(qos: .userInitiated).async &#123; if let image = UIImage(data: data) &#123; completionHandler(.success(image)) &#125; else &#123; completionHandler(.failure(ConversionFailure.invalidData)) &#125; &#125;&#125;这里，我们自定义了一个错误类型。然后通过GCD异步方式将data转化成image。这里我们使用了Result 作为返回类型。当流转成了图片则返回图片，否则返回ConversionFailure错误。然后我们再看调用:12345678convertToImage(data) &#123; result in switch result &#123; case .success(let image): print(\"we get an image!\") case .failure(let error): print(\"invalid data error! \\(error)\") &#125;&#125;这里我们用switch语句对result枚举类型判断.success 和 .failure两种类型。你也可以用result.get()方法获得返回的结果要么是成功，要么是失败。失败error可以被do{}catch{}捕捉到：12345678convertToImage(data) &#123; result in do &#123; let image = try result.get() print(\"we get an image!\") &#125; catch &#123; print(\"invalid data error! \\(error)\") &#125;&#125; 或者用try? 可能返回nil，当返回nil值时即发生了错误123456convertToImage(data) &#123; result in guard let image = try? result.get() else &#123; return &#125; print(\"we get an image!\")&#125; Result也提供了一些库方法，如map，mapError等，我们可以根据需要对result结果进行处理包装。123456789101112131415convertToImage(data) &#123; result in let newResult = result.map &#123; uiImage in return uiImage.cgImage &#125;&#125;struct WrappedError: Error &#123; let cause: Error&#125;convertToImage(data) &#123; result in let newResult = result.mapError &#123; conversionFailure in return WrappedError(cause: conversionFailure) &#125;&#125;最后，我们可以对网络处理层用Result进行包装：1234567891011121314151617181920212223242526272829303132333435363738394041protocol GYRemoteFetch &#123; associatedtype ResultModel:Codable func loadData(from url: URL, completion:@escaping (Result&lt;ResultModel, Error&gt;) -&gt; Void)&#125;extension GYRemoteFetch &#123; func loadData(from url: URL, completion:@escaping (Result&lt;ResultModel, Error&gt;) -&gt; Void) &#123; URLSession.shared.dataTask(with: url) &#123; data, response, error in guard let data = data else &#123; if let error = error &#123; completion(.failure(error)) return &#125; fatalError(\"data can't be nil\") &#125; let decoder = JSONDecoder() let result = Result(catching: &#123; try decoder.decode(ResultModel.self, from: data) &#125;) completion(result) &#125;.resume() &#125;&#125;struct User:Codable&#123;&#125;//UserViewModel请求网络用户信息举例：struct UserViewModel:GYRemoteFetch &#123; typealias ResultModel = User func fetchUser()&#123; loadData(from: URL(string: \"http://api.littleWhale/user\")!) &#123; result in guard let user = try? result.get() else &#123; return &#125; print(user) &#125; &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"在Swift中有效地抛异常","slug":"error","date":"2021-07-07T03:50:10.000Z","updated":"2021-07-07T03:57:09.596Z","comments":true,"path":"2021/07/07/error/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/07/error/","excerpt":"在swift2.0, 苹果在swift中就介绍了throws 关键字。这方便开发者在写代码时候保证清晰的思路以及在执行时可能出现的错误做异常处理。可做异常捕捉或者忽略异常。这篇文章将详细讲解 throws 关键字，以及在代码中如何去处理异常。 处理异常如果你在Swift中使用过JSONDecoder，就知道在编写代码时候可抛出异常。让我们来看以下代码片段：123456789var greeting = \"Hello, playground\"do &#123; let data = greeting.data(using: .utf8)! let decoder = JSONDecoder() let string = try decoder.decode(String.self, from: data)&#125; catch &#123; error print(error)&#125;在Playground 执行代码片段，发现控制台输出Swift.DecodingError异常错误，异常被catch捕捉到了。代码中，我们用do {} catch {} 方式把可能发生的代码一次用try 方式写在do{}里面。当捕捉到一次立马进入catch{error }段。catch将捕捉到Error, 在catch时候，我们也可以捕捉精确的异常进行处理。","text":"在swift2.0, 苹果在swift中就介绍了throws 关键字。这方便开发者在写代码时候保证清晰的思路以及在执行时可能出现的错误做异常处理。可做异常捕捉或者忽略异常。这篇文章将详细讲解 throws 关键字，以及在代码中如何去处理异常。 处理异常如果你在Swift中使用过JSONDecoder，就知道在编写代码时候可抛出异常。让我们来看以下代码片段：123456789var greeting = \"Hello, playground\"do &#123; let data = greeting.data(using: .utf8)! let decoder = JSONDecoder() let string = try decoder.decode(String.self, from: data)&#125; catch &#123; error print(error)&#125;在Playground 执行代码片段，发现控制台输出Swift.DecodingError异常错误，异常被catch捕捉到了。代码中，我们用do {} catch {} 方式把可能发生的代码一次用try 方式写在do{}里面。当捕捉到一次立马进入catch{error }段。catch将捕捉到Error, 在catch时候，我们也可以捕捉精确的异常进行处理。 1234567891011var greeting = \"Hello, playground\"do &#123; let data = greeting.data(using: .utf8)! let decoder = JSONDecoder() let string = try decoder.decode(String.self, from: data)&#125; catch is DecodingError &#123; print(\"something went wrong while decoding!\")&#125; catch &#123; error print(error)&#125; Error在Swift中是一个协议，我们也可以定义自己错误类型，在一些业务错误中也可以使用到。1234567enum MyError: Error &#123; case myErrorCase&#125;func doSomething() throws &#123; throw MyError.myErrorCase&#125;当执行doSomething方法时候，程序会中端。try doSomething 你如果要捕捉则用do{} catch{}方式。如果你要忽略此异常，可以使用try? doSomething()，这个时候返回nil。如果你对返回值为nil不care的话，可以这么用。比如上面提到的json解析：12345var greeting = \"Hello, playground\"let data = greeting.data(using: .utf8)!let decoder = JSONDecoder()let string = try? decoder.decode(String.self, from: data)print(string) //输出nil，当string变量被其他业务继续使用的时候，还是要做好nil值判断。当你真的不在乎捕捉异常，或者不管错误是不是发生时候，你可以使用try?。 还有一种方式处理错误，你可以用try! 。但这种方式只适用于你非常肯定且有把握你的代码条件正确比如上述greeting变量一定要是复合json格式的字符串解析才能成功，否则非常危险，程序直接crash掉。 函数可以抛出异常方法必须含有throws关键字，如果有返回类型，则throw放在返回类型之前。123456func doSomething() throws &#123; throw MyError.myErrorCase&#125;func doSomething2() throws -&gt; String? &#123; throw MyError.myErrorCase&#125;当你不想在某方法里处理异常时候，你需要在使用的方法名后用throws将异常抛出到上层函数做处理。123456789101112131415func decodeJSON(_ data: Data) throws -&gt; String &#123; let decoder = JSONDecoder() let decodedString = try decoder.decode(String.self, from: data) return decodedString&#125;var greeting = \"Hello, playground\"let data = greeting.data(using: .utf8)!do &#123; let string = try decodeJSON(data) print(string)&#125; catch &#123; print(\"decode error\")&#125; 在block中抛异常123func executeGYBlock(_ closure: (() throws -&gt; Void)) throws &#123; try closure()&#125; 这里出现了两个throws, executeGYBlock里的closure闭包可能有异常需要throws抛出，executeGYBlock 函数本身throws是在执行executeGYBlock函数时把内部block块可能出现的移除需要再次向上层调用者进行抛出异常。调用时如下代码示例：将block块内处理的错误进行抛出。12345678do &#123; try executeGYBlock &#123; let string = try decodeJSON(data) print(string) &#125;&#125;catch&#123; print(error)&#125;当有多个异常时候：catch首先捕捉到第一个try 的异常错误然后就中止。1234567891011do &#123; try executeGYBlock &#123; try doSomething() &#125; try executeGYBlock &#123; let string = try decodeJSON(data) print(string) &#125;&#125;catch&#123; print(error)&#125;因为异常一旦catch后，程序里的代码片段将不再继续往下执行其他代码。用下面的代码表示12345func doSomething() throws &#123; print(&quot;doSomethingBefore...&quot;) throw MyError.myErrorCase print(&quot;doSomethingAfter...&quot;) &#x2F;&#x2F;Code after &#39;throw&#39; will never be executed&#125; 总结 异常错误，我们可以用do{ try something} catch{}进行捕捉处理。 Error是协议，我们可以自定义我们自己的异常类型。 异常可用try? 进行忽略，注意返回值nil的判断处理。 当你非常肯定不会有异常时候又不想写do catch 的时候，可以用try!。 但这种方式非常危险，万一有异常就直接crash。 当你方法里不想处理异常时候，在方法名处继续用throws 将异常抛出至上层。 当block块需要throws时，闭包函数需再次throws。最终把异常抛给调用处理。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"用泛型和协议构建可伸缩性组件","slug":"generics","date":"2021-07-06T10:01:10.000Z","updated":"2021-07-06T10:18:50.818Z","comments":true,"path":"2021/07/06/generics/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/06/generics/","excerpt":"在App开发中，数据层往往会做本地缓存，以便在网络不好的情况下能够先显示本地缓存数据。接下来将讲解到如何设计本地数据源中间件来实现业务数据的读取。在讲解之前我们会先了解一下简单泛型在Swift中的应用，结合associated types, 你也可以在协议中使用泛型。 在介绍之前，我刚提到我想要对泛型数据存储在本地，然后还需要一个远程数据接口API提供数据以便在本地数据没有的情况下调用。假设我需要用户信息数据：1234567let localDataStore = UserDataStore()let remoteDataStore = UserApi()let dataStore = CacheBackedDataStore(localDataStore, remoteDataStore)dataStore.fetch(userID) &#123; result in // handle result&#125;","text":"在App开发中，数据层往往会做本地缓存，以便在网络不好的情况下能够先显示本地缓存数据。接下来将讲解到如何设计本地数据源中间件来实现业务数据的读取。在讲解之前我们会先了解一下简单泛型在Swift中的应用，结合associated types, 你也可以在协议中使用泛型。 在介绍之前，我刚提到我想要对泛型数据存储在本地，然后还需要一个远程数据接口API提供数据以便在本地数据没有的情况下调用。假设我需要用户信息数据：1234567let localDataStore = UserDataStore()let remoteDataStore = UserApi()let dataStore = CacheBackedDataStore(localDataStore, remoteDataStore)dataStore.fetch(userID) &#123; result in // handle result&#125;以上为大致逻辑简写，继续拆解CacheBackedDataStore:1234567891011121314151617181920class CacheBackedDataStore &#123; let localStore: LocalStore let remoteStore: RemoteStore func fetch(_ identifier: IdentifierType, completion: @escaping Result&lt;T, Error&gt;) &#123; localStore.fetchObject(identifier) &#123; result in if let result = try? result.get() &#123; completion(.success(result)) &#125; else &#123; remoteStore.fetchObject(identifier) &#123; result in if let result = try? result.get() &#123; completion(.success(result)) &#125; else &#123; // extract error and forward to the completion handler &#125; &#125; &#125; &#125; &#125;&#125;注意到Result， T 为泛型的一个占位符。可代表任何对象。讲解泛型之前，回顾一下在Swift中，我们定义一个字符串数组。一般有两种方式:12let words1 &#x3D; [String]()let words2 &#x3D; Array&lt;String&gt;()第二种方式，我们留意到方式注明是字符串类型。我们查看Array的代码可以看到。123struct Array&lt;T&gt; &#123; &#x2F;&#x2F; implementation code&#125;T即代表我们将要注入的类型。我们再来看一串代码：12345struct SpecializedPrinter&lt;T&gt; &#123; func print(_ object: T) &#123; print(object) &#125;&#125;我们定义了一个SpecializedPrinter泛型结构体，print方法使用了泛型参数。在使用的时候，如果我们传入了字符串类型，那么输出打印的就是字符串。123let printer = SpecializedPrinter&lt;String&gt;()printer.print(\"Hello!\") // this is fineprinter.print(10) // this is not okay since T for this printer is String, not Int现在你已经了解了泛型，我们接下来对CacheBackedDataStore进行改进：12345678struct CacheBackedDataSource&lt;T&gt; &#123; let localStore: LocalStore let remoteStore: RemoteStore func find(_ objectID: String, completion: @escaping (Result&lt;T?, Error&gt;) -&gt; Void) &#123; &#125;&#125;之前的代码，我们localStore,和remoteStore不能够写死，需要制定一套标准。即localStore可以做什么，remoteStore可以做什么。进而继续改进：12345678protocol LocalStore &#123; func find(_ objectID: String, completion: @escaping (Result&lt;T, Error&gt;) -&gt; Void) func persist(_ object: T)&#125;protocol RemoteStore &#123; func find(_ objectID: String, completion: @escaping (Result&lt;T, Error&gt;) -&gt; Void)&#125;当改成上述代码的时候，这个时候编译器会报错，在协议中，泛型参数T没有声明！接下来我们需要在协议中使用泛型机制。这个时候就用到AssociateType进行类型关联。123456789101112protocol LocalStore &#123; associatedtype StoredObject func find(_ objectID: String, completion: @escaping (Result&lt;StoredObject, Error&gt;) -&gt; Void) func persist(_ object: StoredObject)&#125;protocol RemoteStore &#123; associatedtype TargetObject:Decodable //为了约束TargetObject要符合Decodable协议规则 func find(_ objectID: String, completion: @escaping (Result&lt;TargetObject, Error&gt;) -&gt; Void)&#125;接下来我们定义ArrayBackedUserStore的业务类实现LocalStore协议,RemoteUserStore业务类实现 RemoteStore 协议：1234567891011121314151617struct ArrayBackedUserStore: LocalStore &#123; func find(_ objectID: String, completion: @escaping (Result&lt;User, Error&gt;) -&gt; Void) &#123; //本地数据读取 &#125; func persist(_ object: User) &#123; //本地持久化操作 &#125;&#125;struct RemoteUserStore: RemoteStore &#123; typealias TargetObject = User //如果所使用的对象User不是Decodable协议，则会报错 func find(_ objectID: String, completion: @escaping (Result&lt;TargetObject, Error&gt;) -&gt; Void) &#123; &#125;&#125;回到上述CacheBackedDataSource泛型结构体，其中两个变量localStore和remoteStore将会编译出错，提示“Protocol ‘LocalStore’ can only be used as a generic constraint because it has Self or associated type requirements” 意思是LocalStore协议里有associatedtype关联类型，只能够通过泛型约束来使用。继续改进代码：12345678struct CacheBackedDataSource&lt;Local:LocalStore,Remote:RemoteStore&gt; &#123; let localStore: Local let remoteStore: Remote func find(_ objectID: String, completion: @escaping (Result&lt;Local.StoredObject, Error&gt;) -&gt; Void) &#123; &#125;&#125;这样就编译正常了。此时CacheBackedDataSource含有两个泛型参数，而Result 改成了Result。其实用Result也是可以，为了保证local和remote关联的类型为同一对象类型，我们继续对CacheBackedDataSource增加约束：1234567891011121314151617181920212223struct CacheBackedDataSource&lt;Local:LocalStore,Remote:RemoteStore&gt; where Local.StoredObject == Remote.TargetObject &#123; let localStore: Local let remoteStore: Remote func find(_ objectID: String, completion: @escaping (Result&lt;Local.StoredObject, Error&gt;) -&gt; Void) &#123; localStore.find(objectID) &#123; result in do &#123; let object = try result.get() completion(.success(object)) &#125; catch &#123; self.remoteStore.find(objectID) &#123; result in do &#123; let object = try result.get() self.localStore.persist(object) completion(.success(object)) &#125; catch &#123; completion(.failure(error)) &#125; &#125; &#125; &#125; &#125;&#125;最后调用的时候：123456let localUserStore = ArrayBackedUserStore()let remoteUserStore = RemoteUserStore()let cache = CacheBackedDataSource(localStore: localUserStore, remoteStore: remoteUserStore)cache.find(\"someObjectId\") &#123; (result: Result&lt;User, Error&gt;) in&#125;通过这篇文章，你已经知道使用给对象定义泛型，使用泛型参数，以及在在协议中使用关联类型来约束参数类型。以及在对象中包含定义了关联的协议变量，需使用泛型参数来对协议变量进行约束。泛型的功能强大，可使组件抽象，复用。可帮助我们构建弹性组件。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"SwiftUI 属性包裹器","slug":"@State","date":"2021-07-05T09:01:10.000Z","updated":"2021-07-06T06:32:33.941Z","comments":true,"path":"2021/07/05/@State/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/05/@State/","excerpt":"简介文章将简要讲述何时使用@State, @Binding, @StateObject, @ObservedObject, @EnvironmentObject。 @State@State属性包裹器可用于当你的视图对象响应任何状态改变时候。换句话说，视图初始化@State修饰的属性变量。该属性变量的变更只发生在内部View，而不被外界所改变。12345678910111213struct StateExample: View &#123; @State private var intValue &#x3D; 0 var body: some View &#123; VStack &#123; Text(&quot;intValue equals \\(intValue)&quot;) Button(&quot;Increment&quot;) &#123; intValue +&#x3D; 1 &#125; &#125; &#125;&#125;在内部，SwiftUI将会存储 @State修饰的属性值，然后贯穿整个渲染或重复渲染的生命周期中将持久化存储这个值，当在视图刷新或者重新创建的时候，该属性值可以很好地被视图自身管理。当然，你也可以用private修饰词修饰@State属性，保证只在内部修改@State属性。@State使用场景： 在被修饰的属性需要响应你视图变化的状态时候 你修饰的是一个值类型（结构体、枚举）","text":"简介文章将简要讲述何时使用@State, @Binding, @StateObject, @ObservedObject, @EnvironmentObject。 @State@State属性包裹器可用于当你的视图对象响应任何状态改变时候。换句话说，视图初始化@State修饰的属性变量。该属性变量的变更只发生在内部View，而不被外界所改变。12345678910111213struct StateExample: View &#123; @State private var intValue &#x3D; 0 var body: some View &#123; VStack &#123; Text(&quot;intValue equals \\(intValue)&quot;) Button(&quot;Increment&quot;) &#123; intValue +&#x3D; 1 &#125; &#125; &#125;&#125;在内部，SwiftUI将会存储 @State修饰的属性值，然后贯穿整个渲染或重复渲染的生命周期中将持久化存储这个值，当在视图刷新或者重新创建的时候，该属性值可以很好地被视图自身管理。当然，你也可以用private修饰词修饰@State属性，保证只在内部修改@State属性。@State使用场景： 在被修饰的属性需要响应你视图变化的状态时候 你修饰的是一个值类型（结构体、枚举） @Binding@Binding属性包裹器修饰的属性值被其他View所传递。视图内定义的@Binding修饰的属性值可接受外部传入的值，也包含写的权限，即可对Binding修饰的属性做更改，可将值响应回到父容器。（一般在子view Binding修饰属性接收父容器初始值，然后子view做更改，父视图可实时响应其结果。）123456789101112131415161718192021struct StateView: View &#123; @State private var intValue &#x3D; 0 var body: some View &#123; VStack &#123; Text(&quot;intValue equals \\(intValue)&quot;) BindingView(intValue: $intValue) &#125; &#125;&#125;struct BindingView: View &#123; @Binding var intValue: Int var body: some View &#123; Button(&quot;Increment&quot;) &#123; intValue +&#x3D; 1 &#125; &#125;&#125;说明：以上代码StateView中把 @State包裹修饰的intValue通过$符号传递到BindingView中。子View通过Binding形式间接修改了@State包裹的intValue。由于@Binding包裹修饰时，值总是从外部传递进来。所以当试图被丢弃时，SwiftUI不管理Binding。 @Bindingg可以比作是绑定传递、响应父视图，而@State是需要持久化状态变更。 @Binding使用场景： 你需要对父视图的属性进行读或写权限时候 被包裹的属性是值类型的时候(结构体或枚举) @StateObject@StateObject修饰属性有点类似@State的用法，但可用来引用类型比如class. 一般用于修饰ObservableObject对象。以及订阅ObservableObject里@Published修饰的属性。1234567891011class DataProvider: ObservableObject &#123; @Published var currentValue &#x3D; &quot;a value&quot;&#125;struct DataOwnerView: View &#123; @StateObject private var provider &#x3D; DataProvider() var body: some View &#123; Text(&quot;provider value: \\(provider.currentValue)&quot;) &#125;&#125;说明：DataOwnerView持有DataProvider的实例。当DataProvider里的currentValue发生改变的时候，值将在DataOwnerView里实时显示。内部，当DataOwnerView发生刷新需要重新创建的时候，SwiftUI将会管理持有@StateObject包裹的变量。意味着视图中@StateObject修饰的变量只创建1次。SwiftUI将实例和@StateObject关联，当视图再次初始化时将会再次重用@StateObject修饰的对象。换句话说，@StateObject 标记的属性，SwiftUI维护管理着该实例，供视图需要时使用（甚至SwiftUI重新创建渲染视图）。和@State不同的是，@StateObject可用来接收ObservableObject的对象而不是接收一个值类型。 @StateObject使用场景： 你想在ObservableObject里响应或者更新视图。 在视图中，创建了ObservableObject实例，需要用@StateObject修饰。 @ObservedObject@ObservedObject是用来包裹ObservableObject实例，和@StateObject相似，除了视图不创建拥有@ObservedObject 实例。12345678910111213141516171819struct DataOwnerView: View &#123; @StateObject private var provider &#x3D; DataProvider() var body: some View &#123; VStack &#123; Text(&quot;provider value: \\(provider.currentValue)&quot;) DataUserView(provider: provider) &#125; &#125;&#125;struct DataUserView: View &#123; @ObservedObject var provider: DataProvider var body: some View &#123; &#x2F;&#x2F; create body and use &#x2F; modify &#96;provider&#96; &#125;&#125; DataOwnerView往DataUserView传递了一个@StateObject，而DataProvider实例在DatauserView中被使用。在DatauserView中，当该视图需要刷新渲染的时候，SwiftUI内部不维护不管理 @ObservedObject。SwiftUI知道父视图将会传递ObservedObject过来,用于DatauserView中作为一个属性值来使用即可。 @ObservedObject使用场景： 你需要在ObservedObject响应变更或者更新 在视图中不需创建ObservedObject的实例（如果需要，则用@StateObject） @EnvironmentObject有时候你需要在你的App各种各样的地方使用同一个对象，而你又不想一层层传递。你可能想做一个全局依赖可用于让视图的所有节点或者你的App都共享使用到该对象。那么你可以使用@EnvironmentObject。1234567struct EnvironmentUsingView: View &#123; @EnvironmentObject var dependency: DataProvider var body: some View &#123; Text(dependency.currentValue) &#125;&#125;@EnvironmentObject 修饰的对象必须遵循ObservableObject协议，一般可配置在父节点。例如，我们可以在App入口注入一个全局的环境变量，这样我们整个App都可以使用。12345678910struct MyApp: App &#123; @StateObject var dataProvider &#x3D; DataProvider() var body: some Scene &#123; WindowGroup &#123; EnvironmentUsingView() .environmentObject(dataProvider) &#125; &#125;&#125;当@EnvironmentObject 修饰的属性发生改变时候，你的视图将会重新渲染。@EnvironmentObject使用场景： 正常情况下，你会使用@ObservedObject，但你可能需要把ObservableObject对象传递到多个视图中初始化之前，因为视图渲染的时候可能用到它，那么此刻就用@EnvironmentObject。 总结通过以上讲解，我们可以把渲染的类型分为值类型和对象。值类型： 数据怎样使用？常规属性？只读？读或写？ 谁持有该数据？来自外界？（@Binding） 还是自身View的状态（@State）?对象类型： View怎样接收该对象？ 作为参数？（@ObservedObject） 自身创建该对象实例？（@StateObject） 通过环境变量？（@EnvironmentObject）","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"Sqlite 并行模式的试验探究","slug":"sqlite","date":"2021-07-05T09:01:10.000Z","updated":"2021-07-05T09:53:36.819Z","comments":true,"path":"2021/07/05/sqlite/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/05/sqlite/","excerpt":"大多数产品在本地Sqlite存储的时候，基本都是用了串行模式。即整个应用全局只有一个sql操作句柄，用单例管理着这个SqlHandler。另外还有一个模式叫线程模式。这种模式下很容易出现Sqlite_Busy错误。 当有写操作时，其他读操作会被驳回。 当有写操作时，其他写操作会被驳回。 当开启事务时，在事务提交之前，其他写操作会被驳回。 当开启事务时，在事务提交之前，其他事务请求会被驳回。 当有读操作时，其他写操作会被驳回。 读操作之间能够并发执行。 第三方库WCDB支持多线程度于读与读，读与写并发执行，写与写串行执行。WCDB 在多线程方面明显优于 FMDB 和 ModelSqliteKit，通过 WCDB 的改造，使得SQLite的性能发挥到极致。","text":"大多数产品在本地Sqlite存储的时候，基本都是用了串行模式。即整个应用全局只有一个sql操作句柄，用单例管理着这个SqlHandler。另外还有一个模式叫线程模式。这种模式下很容易出现Sqlite_Busy错误。 当有写操作时，其他读操作会被驳回。 当有写操作时，其他写操作会被驳回。 当开启事务时，在事务提交之前，其他写操作会被驳回。 当开启事务时，在事务提交之前，其他事务请求会被驳回。 当有读操作时，其他写操作会被驳回。 读操作之间能够并发执行。 第三方库WCDB支持多线程度于读与读，读与写并发执行，写与写串行执行。WCDB 在多线程方面明显优于 FMDB 和 ModelSqliteKit，通过 WCDB 的改造，使得SQLite的性能发挥到极致。 我们可以设计所有写的任务都放在一个队列中。1_gyWriteQueue &#x3D; dispatch_queue_create([[NSString stringWithFormat:@&quot;gy_write_queue.%@&quot;, self]当所有关于新增，删除，修改等sql 业务时候统一用_gyWriteQueue。123dispatch_sync(_gyWriteQueue,^&#123; &#x2F;&#x2F;进行写操作);我们可以根据队列的名字，确定是属于写队列，还是读队列。12const char * queueLabel &#x3D; dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL); &#x2F;&#x2F;获取当前队列的名字。NSString *queueName &#x3D; [NSString stringWithUTF8String:queueLabel];如果是读队列，则从读的队列池中取中取出与之对应的队列，拿出队列中所持有的handle句柄。这样就能保证每个队列中唯一正在执行的子线程使用该handle句柄。首先准备队列池，队列最大并发数1，并且持有一个handle. 读取操作时候，从队列池取当前操作数最小的队列进行添加任务。 以下是创建读队列的队列池:12345678910111213- (void)createSqlHandleToPool:(NSString *)queueName&#123; GYSqlHandle *handleModel &#x3D; [[GYSqlHandle alloc] init]; &#x2F;&#x2F;初始化即创建了一个sql句柄 if(handleModel.sqlHandle)&#123; GYSqlOperationQueue *sqlQueue &#x3D; [[GYSqlOperationQueue alloc] init]; sqlQueue.name &#x3D; queueName; sqlQueue.sqlQueueName &#x3D; queueName; sqlQueue.maxConcurrentOperationCount &#x3D; 1; sqlQueue.handle &#x3D; handleModel; [self.dbQueueList addObject:sqlQueue]; &#125;&#125;由于sqlite的句柄返回的是结构体指针，所以用GYSqlHandle对象进行包裹一下方便处理。 GYSqlOperationQueue代码如下：1234567891011121314151617181920212223242526272829303132@interface GYSqlOperationQueue: NSOperationQueue@property(nonatomic,strong) GYSqlHandle *handle; &#x2F;&#x2F;每一个queue持有一个handle模型@property(nonatomic,strong) NSString *sqlQueueName; &#x2F;&#x2F;记录队列名- (NSComparisonResult)compareByOperationsCount:(GYSqlOperationQueue *) another;-(void)addSqlOperationWithBlock:(void (^)(void))block;@end@implementation GYSqlOperationQueue- (NSComparisonResult)compareByOperationsCount:(GYSqlOperationQueue *) another&#123; if (self.operations.count &gt; another.operations.count) &#123; return NSOrderedAscending; &#125; else if(self.operations.count &lt; another.operations.count) &#123; return NSOrderedDescending; &#125; return NSOrderedSame;&#125;-(void)addSqlOperationWithBlock:(void (^)(void))block &#123; if(self)&#123; NSOperation *operation &#x3D; [NSBlockOperation blockOperationWithBlock:block]; id lastOperation &#x3D; self.operations.lastObject; if(lastOperation)&#123; [operation addDependency:lastOperation]; &#125; [self addOperation:operation]; &#125;&#125;@end这里仅为个人的一些试验性的探索，因为全局业务代码无法固定使用某统一队列，线程之间可能出现嵌套等，无法保证一个Handle同一时间只有一个线程在使用。这也是我的疑惑点，希望大家多多交流。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"图片编辑总结","slug":"pictureEdit","date":"2021-07-04T09:15:10.000Z","updated":"2021-07-04T09:16:15.070Z","comments":true,"path":"2021/07/04/pictureEdit/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/04/pictureEdit/","excerpt":"简介图片编辑是基于 CLImageEditor 第三方进行改装得到仿微信的图片编辑交互。原CLImageEditor库是一个日本人写的图片编辑，支持涂鸦，裁剪，旋转，文字帖功能。但有几项我们进行改进。 所有的这些图片操作我们汇总到一起进行编辑，最终保存的时候才处理所有操作汇总成一张处理图片。 涂鸦撤销功能实现真正的上一步撤销，而不是仅仅透明色进行橡皮擦擦除。 新增马赛克操作功能。 把图片裁剪和旋转进行结合到一个页面操作，另外新增裁剪、旋转之后的图片恢复。 改变颜色选择，文字编辑的交互，新增图片裁剪区域的边角重点标注。12345678910111213CLImageEditorViewController：usedToolDic：使用过的工具【toolName:CLImageToolBase】-(CLImageToolBase *)currentEditTool; 当前正在使用的工具。-(UIImage *)getMergeDrawImageForCropTool; 最后合成的图片。用于业务转发、保存、回调给用户。&#x2F;&#x2F;图片编辑器所支持的工具类都继承于CLImageToolBase, 通过CLClassList辅助类runtime方式自动将相关工具类注入到菜单项中。+ (NSArray*)subtools&#123; return [CLImageToolInfo toolsWithToolClass:[CLImageToolBase class]];&#125; CLImageToolBase 工具基类：持有editor编辑器方便拿到图片，同时具有setup, cleanUp 这几个“生命周期”方法，做相关工具的视图创建与清除。","text":"简介图片编辑是基于 CLImageEditor 第三方进行改装得到仿微信的图片编辑交互。原CLImageEditor库是一个日本人写的图片编辑，支持涂鸦，裁剪，旋转，文字帖功能。但有几项我们进行改进。 所有的这些图片操作我们汇总到一起进行编辑，最终保存的时候才处理所有操作汇总成一张处理图片。 涂鸦撤销功能实现真正的上一步撤销，而不是仅仅透明色进行橡皮擦擦除。 新增马赛克操作功能。 把图片裁剪和旋转进行结合到一个页面操作，另外新增裁剪、旋转之后的图片恢复。 改变颜色选择，文字编辑的交互，新增图片裁剪区域的边角重点标注。12345678910111213CLImageEditorViewController：usedToolDic：使用过的工具【toolName:CLImageToolBase】-(CLImageToolBase *)currentEditTool; 当前正在使用的工具。-(UIImage *)getMergeDrawImageForCropTool; 最后合成的图片。用于业务转发、保存、回调给用户。&#x2F;&#x2F;图片编辑器所支持的工具类都继承于CLImageToolBase, 通过CLClassList辅助类runtime方式自动将相关工具类注入到菜单项中。+ (NSArray*)subtools&#123; return [CLImageToolInfo toolsWithToolClass:[CLImageToolBase class]];&#125; CLImageToolBase 工具基类：持有editor编辑器方便拿到图片，同时具有setup, cleanUp 这几个“生命周期”方法，做相关工具的视图创建与清除。 画笔涂鸦 画笔手势：通过 UIPanGestureRecongnizer 手势实现在 imageview 的表层新 ImageView,通过画布生成 image 给 ImageView 赋值。 画笔撤销旧撤销：CLImageEditor 开源库涂鸦撤销原本是一个橡皮檫功能，通过设置BlendMode为透明色来实现擦除画笔线条。假“撤销”。 CGContextSetBlendMode(context, kCGBlendModeClear);撤销-方案演变： 新方案1: 为了可以真正的实现撤销，我们把 Pan 手势由开始到触摸结束表示为一条线，然后用一个数据源存储好这些线条。当撤销的时候，实际为移除最后一个线条即可。表层即一个drawImageView,所有画笔涂鸦合成图片最终只赋值给drawImageView显示。在CLDrawTool 类上新增三个属性：用来记录画布图层上划线的操作。由于每条线可切换颜色进行涂鸦，所以每条线都对应lineColorsArray 颜色数组来记录。一条线即为nowPointArray数组。记录一条线上的所有点。而linePointArray用来记录所有线。 1234@property(nonatomic,strong) NSMutableArray *nowPointArray; &#x2F;&#x2F;当前线的所有点@property(nonatomic,strong) NSMutableArray *lineColorsArray;&#x2F;&#x2F;每条线对应的颜色@property(nonatomic,strong) NSMutableArray *linePointArray;&#x2F;&#x2F;所有线【nowPointArray】 撤销的时候：移除最后一条线以及颜色。重新绘制到当前的画布上，然后生成image赋值给表层的drawImageView. 缺点1：每次撤销移除最后一条线，都需要重绘所有线。以及每次新涂鸦时候，都需要重新实时绘制所有线来达到实时显示的效果。性能消耗太大，不利于用于快速绘制。 缺点2：当图片旋转后，无法对所有线上的点做相应的旋转和放大。旋转图片后，线条错位。 缺陷：这种“正常”撤销无法满足当图片旋转后，所有线条的位置变化，即 我们应该根据角度去旋转所有点的旋转后的点坐标 新方案2、为了解决图片旋转后的的坐标点改变和计算问题，我们换了一种思路：即一次 Pan 手势生成一张图层，旋转时旋转所有画笔图层进行旋转。 每次画完一条线，即在表层生成一张新的drawImageView. 当画多条线的时候，实则【drawImageView】集合。 1234if(sender.state &#x3D;&#x3D; UIGestureRecognizerStateEnded)&#123; &#x2F;&#x2F;结束的时候，再创建一张图drawImageView。 [self generateDrawImageView];&#125; 将线条属性移至DrawPageData模型中。 12345@interface DrawPageData : NSObject@property(nonatomic,strong) NSMutableArray *nowPointArray; &#x2F;&#x2F;当前点@property(nonatomic,strong) NSMutableArray *lineColorsArray;&#x2F;&#x2F;每条线对应的颜色@property(nonatomic,strong) NSMutableArray *linePointArray; &#x2F;&#x2F;所有线@end CLDrawTool 中 新增两属性用来记录所有图层以及图层所对应的划线数据模型。 12@property(nonatomic,strong) NSMutableArray *drawImageViews; &#x2F;&#x2F;[imageView]@property(nonatomic,strong) NSMutableArray *drawPages; &#x2F;&#x2F;[DrawPageData] 撤销： 123_lastDrawPage.linePointArray removeLastObject 移除最后一条线;_lastDrawPage.lineColorsArray removeLastObject 移除颜色;clearTopDrawImageView 移除最顶层的画笔图片层。 优点：此方案既保证了绘制时不再走重绘，每条线都在单独的图层上。同时在图片发生旋转时，旋转每一条线锁在的图片drawImageView,保证了每一条线显示都正确。 123456789101112131415161718192021222324252627282930313233343536@property(nonatomic,strong) DrawPageData _lastDrawPage; &#x2F;&#x2F;定义一个当前页记录模型&#x2F;&#x2F;画笔撤销功能-(void)eraserButtonDidTap:(UIButton *)btn&#123;if (_lastDrawPage.linePointArray &amp;&amp; _lastDrawPage.linePointArray.count &gt;&#x3D; 1) &#123; [_lastDrawPage.linePointArray removeLastObject]; [_lastDrawPage.lineColorsArray removeLastObject]; [self drawAllPanLine:_drawingView byDrawPage:_lastDrawPage]; &#x2F;&#x2F;当前画笔层所有线都移除了的情况下，自动移除当前画笔层 if(_lastDrawPage.linePointArray.count &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;当只有一页的情况下不做处理。 if(self.drawImageViews.count &gt; 1)&#123; [self clearTopDrawImageView]; &#125; &#125; &#125;else&#123; &#x2F;&#x2F;当只有一页的情况下不做处理。 if(self.drawPages.count &gt; 1)&#123; [self clearTopDrawImageView]; [self eraserButtonDidTap:nil]; &#x2F;&#x2F;递归移除空的drawImageView &#125; &#125;&#125;&#x2F;&#x2F;清除顶层的画笔 imageview-(void)clearTopDrawImageView&#123; [self.drawPages removeLastObject]; [((UIImageView *)self.drawImageViews.lastObject) removeFromSuperview]; [self.drawImageViews removeLastObject]; &#x2F;&#x2F;重置当前的层级page _lastDrawPage &#x3D; self.drawPages.lastObject; _drawingView &#x3D; self.drawImageViews.lastObject;&#125; 渲染画笔图层 现在的渲染逻辑是每个 DrawPage 里面的 linePointArray 只会有一条线，外层 for 循环其实可以省略。 123456789101112131415161718192021222324252627282930313233343536373839&#x2F;&#x2F;传入drawImageView 和 drawPageData 进行划线-(void)drawAllPanLine:(UIImageView *)drawImageView byDrawPage:(DrawPageData *)lastDrawPage&#123; CGSize size &#x3D; drawImageView.frame.size; UIGraphicsBeginImageContextWithOptions(size, NO, 0.0); &#x2F;&#x2F;遍历每一条线 for (int i &#x3D; 0 ; i &lt; lastDrawPage.linePointArray.count ; i ++ ) &#123; NSMutableArray *pointArray &#x3D; [lastDrawPage.linePointArray objectAtIndex:i]; CGContextRef context &#x3D; UIGraphicsGetCurrentContext(); CGFloat strokeWidth &#x3D; 6.5; CGContextSetLineWidth(context, strokeWidth); CGContextSetLineJoin(context, kCGLineJoinRound); CGContextSetLineCap(context, kCGLineCapRound); UIColor *strokeColor &#x3D; lastDrawPage.lineColorsArray[i]; &#x2F;&#x2F;得出每条线的颜色 CGContextSetStrokeColorWithColor(context, strokeColor.CGColor); &#x2F;&#x2F;一条线的每个点 for (int j &#x3D; 0 ; j &lt; pointArray.count ; j ++ ) &#123; NSValue *value &#x3D; [pointArray objectAtIndex:j]; CGPoint p &#x3D; [value CGPointValue]; if (j &#x3D;&#x3D; 0) &#123; CGContextMoveToPoint(context, p.x, p.y); CGContextAddLineToPoint(context, p.x, p.y); &#125;else&#123; CGContextAddLineToPoint(context, p.x, p.y); &#125; &#125; CGContextStrokePath(context); &#125; drawImageView.image &#x3D; UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext();&#125; Pan 手势的事件处理 1234567891011121314151617181920212223242526272829303132- (void)drawingViewDidPan:(UIPanGestureRecognizer*)sender&#123; if([[self.editor currentEditTool] isKindOfClass:[CLMosaicTool class]])&#123; &#x2F;&#x2F;手势功能传递，所有tool图层都叠在一起。因马赛克图层在最底层，涂鸦在马赛克上层，文字层在最顶层。 CLMosaicTool *mosaicTool &#x3D; [self.editor.usedToolDic objectForKey:@&quot;CLMosaicTool&quot;]; [mosaicTool drawingViewDidPan:sender]; return; &#125; CGPoint currentDraggingPosition &#x3D; [sender locationInView:_drawingView]; if(sender.state &#x3D;&#x3D; UIGestureRecognizerStateBegan)&#123; _lastDrawPage.nowPointArray &#x3D; [[NSMutableArray alloc] init]; UIColor *currentLineStrokeColor &#x3D; _strokePreview.backgroundColor; &#x2F;&#x2F;记录当前画线颜色，因为用户可能切换颜色。 [_lastDrawPage.lineColorsArray addObject:currentLineStrokeColor]; [_lastDrawPage.linePointArray addObject:_lastDrawPage.nowPointArray]; _prevDraggingPosition &#x3D; currentDraggingPosition; &#125; &#x2F;&#x2F;记录当前的点 NSValue *point &#x3D; [NSValue valueWithCGPoint:currentDraggingPosition]; [_lastDrawPage.nowPointArray addObject:point]; [self drawAllPanLine:_drawingView byDrawPage:_lastDrawPage]; _prevDraggingPosition &#x3D; currentDraggingPosition; if(sender.state &#x3D;&#x3D; UIGestureRecognizerStateEnded)&#123; &#x2F;&#x2F;结束的时候，再创建一张图drawImageView。 [self generateDrawImageView]; &#x2F;&#x2F;如果要在一张图上画多条线，则屏蔽掉此局。 &#125;&#125; 画完一条线生成一张图层 123456789101112131415161718192021-(void)generateDrawImageView&#123; DrawPageData *pageData &#x3D; [[DrawPageData alloc] init]; [self.drawPages addObject:pageData]; _lastDrawPage &#x3D; pageData; UIImageView *lastDrawImageView &#x3D; [[UIImageView alloc] initWithFrame:self.editor.imageView.bounds]; UIPanGestureRecognizer *panGesture &#x3D; [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(drawingViewDidPan:)]; panGesture.maximumNumberOfTouches &#x3D; 1; lastDrawImageView.userInteractionEnabled &#x3D; YES; lastDrawImageView.tag &#x3D; 100 + self.drawImageViews.count; [lastDrawImageView addGestureRecognizer:panGesture]; if(self.drawImageViews.count)&#123; [self.editor.imageView insertSubview:lastDrawImageView aboveSubview:_drawingView]; &#125;else&#123; [self.editor.imageView addSubview:lastDrawImageView]; &#125; [self.drawImageViews addObject:lastDrawImageView]; _drawingView &#x3D; lastDrawImageView;&#125; 图片旋转 当图片发生旋转或者裁剪操作时候，需要从 usedToolDic 中拿出CLDrawTool 和 CLMosialTool ，取出其中的【drawImageView】集合，对其中的每一张图层进行旋转和裁剪，再赋回给对应的每一项图层drawImageView. 再调整每一项drawImageView的frame. 调用此方法。 //重置画笔层&amp;马赛克层的frame。1- (void)resetDrawImageViewFrame:(UIImage *)image withDrawImageView:(UIImageView *)drawingView //以下代码在CLClipping旋转或裁剪操作完成时候的回调需要对涂鸦图层做的image和frame处理。1234567891011121314151617CLDrawTool *_drawTool &#x3D; [self.editor.usedToolDic objectForKey:@&quot;CLDrawTool&quot;];if(_drawTool)&#123; &#x2F;&#x2F;将多张画笔图进行图片源旋转。 for(UIImageView *drawingView in _drawTool.drawImageViews)&#123; UIImage *roateDrawImage &#x3D; [self buildRoteImage:drawingView.image]; &#x2F;&#x2F;需要对imageviews进行旋转 CGFloat roateZoomScale &#x3D; _rotateImageView.width &#x2F; roateDrawImage.size.width; CGRect roateRct &#x3D; _gridView.clippingRect; roateRct.size.width &#x2F;&#x3D; roateZoomScale; roateRct.size.height &#x2F;&#x3D; roateZoomScale; roateRct.origin.x &#x2F;&#x3D; roateZoomScale; roateRct.origin.y &#x2F;&#x3D; roateZoomScale; UIImage *roateCropDrawImage &#x3D; [roateDrawImage crop:roateRct]; drawingView.image &#x3D; roateCropDrawImage; &#x2F;&#x2F;设置裁剪后的图片。 [self.editor resetDrawImageViewFrame:roateCropDrawImage withDrawImageView:drawingView]; &#125;&#125; 马赛克马赛克的思路和画笔差不多，也是根据用户 pan 手势进行触摸，所画的颜色为原图经 RGB 模糊换算得到的马赛克图片，算法使用 XRGBTool 第三方的一个类。 马赛克初始方案原先的方案是创建一个 imageLayer，然后添加到 imageView 的 layer: [self.editor.imageView.layer insertSublayer:_imageLayer atIndex:0]; //确定马赛克在最底部. 123456789101112CALayer *imageLayer &#x3D; [CALayer layer];imageLayer.frame &#x3D; drawingView.bounds;imageLayer.contents &#x3D; (id)_mohuImage.CGImage;CAShapeLayer *shapeLayer &#x3D; [CAShapeLayer layer];shapeLayer.frame &#x3D; drawingView.bounds; &#x2F;&#x2F;self.editor.imageView.bounds;shapeLayer.lineCap &#x3D; kCALineCapRound;shapeLayer.lineJoin &#x3D; kCALineJoinRound;shapeLayer.lineWidth &#x3D; 15;shapeLayer.strokeColor &#x3D; [UIColor blueColor].CGColor;shapeLayer.fillColor &#x3D; nil;&#x2F;&#x2F;此处必须设为nil，否则后边添加addLine的时候会自动填充imageLayer.mask &#x3D; shapeLayer; 1234在pan手势时候，通过改变shareLayer.pathCGPoint currentDraggingPosition &#x3D; [sender locationInView:_drawingView];CGPathAddLineToPoint(_path, nil, currentDraggingPosition.x, currentDraggingPosition.y);_shapeLayer.path &#x3D; _path; 最后合成图片的时候，通过 imageview.layer 渲染在上下文中： [self.editor.imageView.layer renderInContext:context]; 存在的问题(一)：path 路径不可撤回 马赛克撤回创建一个可变的 path 路径 CGMutablePathRef _path = CGPathCreateMutable(); 并将每条线进行叠加，CGPathAddPath(_path, nil, _onePath);最后将总的_path 赋给_shapeLayer.path。 12345678910111213141516171819202122232425- (void)drawingViewDidPan:(UIPanGestureRecognizer*)sender&#123; CGPoint currentDraggingPosition &#x3D; [sender locationInView:_drawingView]; if(sender.state &#x3D;&#x3D; UIGestureRecognizerStateBegan)&#123; _prevDraggingPosition &#x3D; currentDraggingPosition; _nowPointArray &#x3D; [[NSMutableArray alloc] init]; [_linePointArray addObject:_nowPointArray]; &#x2F;&#x2F;无撤销时候的单次马赛克涂抹&#x2F;&#x2F; CGPathMoveToPoint(_path, nil, _prevDraggingPosition.x, _prevDraggingPosition.y);&#x2F;&#x2F; _shapeLayer.path &#x3D; _path; &#125;&#x2F;&#x2F; if(sender.state !&#x3D; UIGestureRecognizerStateEnded)&#123;&#x2F;&#x2F;&#x2F;&#x2F; CGPathAddLineToPoint(_path, nil, currentDraggingPosition.x, currentDraggingPosition.y);&#x2F;&#x2F; _shapeLayer.path &#x3D; _path;&#x2F;&#x2F; &#125; NSValue *point &#x3D; [NSValue valueWithCGPoint:currentDraggingPosition]; [_nowPointArray addObject:point]; [self drawAllPanLine]; _prevDraggingPosition &#x3D; currentDraggingPosition;&#125; 撤销的操作(旧)流程：当撤销时，仅移除数组记录的最后一条线。然后要重新调用一遍渲染。把每条线的所有点进行连接 CGPathAddPath，赋值给总的可变_path，最后把_path 给_shapeLayer.path 1234567&#x2F;&#x2F;撤回上一步-(void)eraserButtonDidTap:(UIButton *)btn&#123; if (_linePointArray &amp;&amp; _linePointArray.count &gt;&#x3D; 1) &#123; [_linePointArray removeLastObject]; [self drawAllPanLine]; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637-(void)drawAllPanLine&#123; CGPathRelease(_path); _path &#x3D; CGPathCreateMutable(); &#x2F;&#x2F;遍历每一条线 for (int i &#x3D; 0 ; i &lt; _linePointArray.count ; i ++ ) &#123; NSMutableArray *pointArray &#x3D; [_linePointArray objectAtIndex:i]; &#x2F;&#x2F;一条线的每个点 CGMutablePathRef _onePath &#x3D; CGPathCreateMutable(); for (int j &#x3D; 0 ; j &lt; pointArray.count ; j ++ ) &#123; NSValue *value &#x3D; [pointArray objectAtIndex:j]; CGPoint p &#x3D; [value CGPointValue]; if (j &#x3D;&#x3D; 0) &#123; CGPathMoveToPoint(_onePath, nil, p.x, p.y); &#125;else&#123; CGPathAddLineToPoint(_onePath, nil, p.x, p.y); &#125; &#125; CGPathAddPath(_path, nil, _onePath); &#125; _shapeLayer.path &#x3D; _path;&#125;- (UIImage*)buildImage&#123; __weak typeof(self) weakSelf &#x3D; self; UIGraphicsBeginImageContextWithOptions(self.editor.imageView.frame.size, NO, 0); CGContextRef context &#x3D; UIGraphicsGetCurrentContext(); [weakSelf.editor.imageView.layer renderInContext:context]; UIImage *tmp &#x3D; UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return tmp;&#125; 撤销的操作(新)新方案的撤销是和画笔流程解决方案一致，都是每完成一次触摸涂抹马赛克，则在表面覆盖一张图片. 在MosaicPageData 数据源基础上新增两个layer属性。 CAShapeLayer shapeLayer; CALayer imageLayer; 操作原理：通过设置当前PageData的 shapeLayer.path 来实现路径涂抹。然后将imageLayer渲染到画布上[lastMosaicPage.imageLayer renderInContext:context];得到image赋值给当前上层的drawImageView. buildImage:图片合成。 先将原图绘制，然后将每一张马赛克图层的image进行绘制。最后得到合成的马赛克图片。具体参照CLMosialTool buildImage方法。 //准备好原图的马赛克虚化图片。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140 _mohuImage &#x3D; [XRGBTool getMosaicImageWith:image level:0];_shapeLayer &#x3D; [CAShapeLayer layer];_shapeLayer.frame &#x3D; _drawingView.bounds;_shapeLayer.lineCap &#x3D; kCALineCapRound;_shapeLayer.lineJoin &#x3D; kCALineJoinRound;_shapeLayer.lineWidth &#x3D; 15;_shapeLayer.strokeColor &#x3D; [UIColor blueColor].CGColor;_shapeLayer.fillColor &#x3D; nil;&#x2F;&#x2F;此处必须设为nil，否则后边添加addLine的时候会自动填充_imageLayer &#x3D; [CALayer layer];_imageLayer.frame &#x3D; _drawingView.bounds;_imageLayer.contents &#x3D; (id)_mohuImage.CGImage;_imageLayer.mask &#x3D; _shapeLayer;- (void)drawingViewDidPan:(UIPanGestureRecognizer*)sender&#123; CGPoint currentDraggingPosition &#x3D; [sender locationInView:_drawingView]; if(sender.state &#x3D;&#x3D; UIGestureRecognizerStateBegan)&#123; _prevDraggingPosition &#x3D; currentDraggingPosition; _lastMosaicPage.nowPointArray &#x3D; [[NSMutableArray alloc] init]; [_lastMosaicPage.linePointArray addObject:_lastMosaicPage.nowPointArray]; &#x2F;&#x2F;无撤销时候的单次马赛克涂抹&#x2F;&#x2F; CGPathMoveToPoint(_path, nil, _prevDraggingPosition.x, _prevDraggingPosition.y);&#x2F;&#x2F; _shapeLayer.path &#x3D; _path; &#125;&#x2F;&#x2F; if(sender.state !&#x3D; UIGestureRecognizerStateEnded)&#123;&#x2F;&#x2F;&#x2F;&#x2F; CGPathAddLineToPoint(_path, nil, currentDraggingPosition.x, currentDraggingPosition.y);&#x2F;&#x2F; _shapeLayer.path &#x3D; _path;&#x2F;&#x2F; &#125; NSValue *point &#x3D; [NSValue valueWithCGPoint:currentDraggingPosition]; [_lastMosaicPage.nowPointArray addObject:point]; [self drawAllPanLine:_drawingView byDrawPage:_lastMosaicPage]; _prevDraggingPosition &#x3D; currentDraggingPosition; if(sender.state &#x3D;&#x3D; UIGestureRecognizerStateEnded)&#123; &#x2F;&#x2F;结束的时候，再创建一张图drawImageView。 [self generateDrawImageView]; &#x2F;&#x2F;如果要在一张图上画多条线，则屏蔽掉此局。 &#125;&#125;-(void)drawAllPanLine:(UIImageView *)drawImageView byDrawPage:(MosaicPageData *)lastMosaicPage&#123; CGMutablePathRef _path &#x3D; CGPathCreateMutable(); &#x2F;&#x2F;遍历每一条线 for (int i &#x3D; 0 ; i &lt; lastMosaicPage.linePointArray.count ; i ++ ) &#123; NSMutableArray *pointArray &#x3D; [lastMosaicPage.linePointArray objectAtIndex:i]; &#x2F;&#x2F;一条线的每个点 CGMutablePathRef _onePath &#x3D; CGPathCreateMutable(); for (int j &#x3D; 0 ; j &lt; pointArray.count ; j ++ ) &#123; NSValue *value &#x3D; [pointArray objectAtIndex:j]; CGPoint p &#x3D; [value CGPointValue]; if (j &#x3D;&#x3D; 0) &#123; CGPathMoveToPoint(_onePath, nil, p.x, p.y); &#125;else&#123; CGPathAddLineToPoint(_onePath, nil, p.x, p.y); &#125; &#125; CGPathAddPath(_path, nil, _onePath); &#125; lastMosaicPage.shapeLayer.path &#x3D; _path; &#x2F;* 手指的涂抹路径 *&#x2F; &#x2F;&#x2F;画图 CGFloat scale &#x3D; self.editor.imageView.image.size.width &#x2F; self.editor.imageView.width; UIGraphicsBeginImageContextWithOptions(self.editor.imageView.image.size, NO, self.editor.imageView.image.scale); CGContextRef context &#x3D; UIGraphicsGetCurrentContext(); CGContextScaleCTM(UIGraphicsGetCurrentContext(), scale, scale); [lastMosaicPage.imageLayer renderInContext:context]; UIImage *tmp &#x3D; UIGraphicsGetImageFromCurrentImageContext(); drawImageView.image &#x3D; tmp; UIGraphicsEndImageContext();&#125;-(void)generateDrawImageView&#123; MosaicPageData *pageData &#x3D; [[MosaicPageData alloc] init]; [self.mosaicPages addObject:pageData]; _lastMosaicPage &#x3D; pageData; UIImage *_mohuImage &#x3D; [XRGBTool getMosaicImageWith:self.editor.imageView.image level:0]; UIImageView *drawingView &#x3D; [[UIImageView alloc] initWithFrame:self.editor.imageView.bounds]; UIPanGestureRecognizer *panGesture &#x3D; [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(drawingViewDidPan:)]; panGesture.maximumNumberOfTouches &#x3D; 1; drawingView.userInteractionEnabled &#x3D; YES; drawingView.tag &#x3D; 1000 + self.drawImageViews.count; [drawingView addGestureRecognizer:panGesture]; if(self.drawImageViews.count)&#123;&#x2F;&#x2F; for(NSInteger tagIndex &#x3D; 0; tagIndex &lt; self.drawImageViews.count ; tagIndex++)&#123;&#x2F;&#x2F; UIImageView *imageView &#x3D; self.drawImageViews[tagIndex];&#x2F;&#x2F; [imageView removeFromSuperview];&#x2F;&#x2F; &#125; [self.editor.imageView.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSLog(@&quot;子imageview的层次tag:%d&quot;,obj.tag); &#125;];&#x2F;&#x2F; for(NSInteger tagIndex &#x3D; 0; tagIndex &lt; self.drawImageViews.count ; tagIndex++)&#123;&#x2F;&#x2F; UIImageView *imageView &#x3D; self.drawImageViews[tagIndex];&#x2F;&#x2F; if(tagIndex &#x3D;&#x3D; 0)&#123;&#x2F;&#x2F; [self.editor.imageView insertSubview:imageView atIndex:0]; &#x2F;&#x2F;底层第一张&#x2F;&#x2F; &#125;else&#123;&#x2F;&#x2F; [self.editor.imageView insertSubview:imageView aboveSubview:_drawingView];&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125; [self.editor.imageView insertSubview:drawingView aboveSubview:_drawingView]; &#125;else&#123; [self.editor.imageView insertSubview:drawingView atIndex:0]; &#x2F;&#x2F;底层第一张 &#125;&#x2F;&#x2F; [self.editor.imageView addSubview:drawingView]; [self.drawImageViews addObject:drawingView]; _drawingView &#x3D; drawingView; &#x2F;&#x2F;重新创建？手势停止时候，创建不断往imageview.layer创建 。最终的结果是熏染imageLayer集合渲染在图片上。 CALayer *imageLayer &#x3D; [CALayer layer]; imageLayer.frame &#x3D; drawingView.bounds; &#x2F;&#x2F;self.editor.imageView.bounds;&#x2F;&#x2F; [self.editor.imageView.layer insertSublayer:_imageLayer atIndex:0]; &#x2F;&#x2F;确定马赛克在最底部&#x2F;&#x2F; [_drawingView.layer addSublayer:_imageLayer]; imageLayer.contents &#x3D; (id)_mohuImage.CGImage; CAShapeLayer *shapeLayer &#x3D; [CAShapeLayer layer]; shapeLayer.frame &#x3D; drawingView.bounds; &#x2F;&#x2F;self.editor.imageView.bounds; shapeLayer.lineCap &#x3D; kCALineCapRound; shapeLayer.lineJoin &#x3D; kCALineJoinRound; shapeLayer.lineWidth &#x3D; 15; shapeLayer.strokeColor &#x3D; [UIColor blueColor].CGColor; shapeLayer.fillColor &#x3D; nil;&#x2F;&#x2F;此处必须设为nil，否则后边添加addLine的时候会自动填充 imageLayer.mask &#x3D; shapeLayer; _lastMosaicPage.shapeLayer &#x3D; shapeLayer; _lastMosaicPage.imageLayer &#x3D; imageLayer;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#x2F;&#x2F;清除顶层的画笔imageview-(void)clearTopDrawImageView&#123; [self.mosaicPages removeLastObject]; [((UIImageView *)self.drawImageViews.lastObject) removeFromSuperview]; [self.drawImageViews removeLastObject]; &#x2F;&#x2F;重置当前的层级page _lastMosaicPage &#x3D; self.mosaicPages.lastObject; _drawingView &#x3D; self.drawImageViews.lastObject;&#x2F;&#x2F; [self.editor.imageView bringSubviewToFront:_drawingView]; &#x2F;&#x2F;将下一层放到最顶层, 移除此句。会遮挡画笔层。&#125;&#x2F;&#x2F;撤回上一步-(void)eraserButtonDidTap:(UIButton *)btn&#123; if (_lastMosaicPage.linePointArray &amp;&amp; _lastMosaicPage.linePointArray.count &gt;&#x3D; 1) &#123; [_lastMosaicPage.linePointArray removeLastObject]; [self drawAllPanLine:_drawingView byDrawPage:_lastMosaicPage]; &#x2F;&#x2F;当前画笔层所有线都移除了的情况下，自动移除当前画笔层 if(_lastMosaicPage.linePointArray.count &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;当只有一页的情况下不做处理。 if(self.drawImageViews.count &gt; 1)&#123; [self clearTopDrawImageView]; &#125; &#125; &#125;else&#123; &#x2F;&#x2F;当只有一页的情况下不做处理。 if(self.mosaicPages.count &gt; 1)&#123; [self clearTopDrawImageView]; [self eraserButtonDidTap:nil]; &#x2F;&#x2F;递归移除空的drawImageView &#125; &#125; &#x2F;&#x2F;单层撤销&#x2F;&#x2F; if (_lastDrawPage.linePointArray &amp;&amp; _lastDrawPage.linePointArray.count &gt;&#x3D; 1) &#123;&#x2F;&#x2F; [_lastDrawPage.linePointArray removeLastObject];&#x2F;&#x2F; [self drawAllPanLine];&#x2F;&#x2F; &#125;&#125;- (UIImage*)buildImage&#123; CGSize originalImageSize &#x3D; self.editor.imageView.image.size; UIGraphicsBeginImageContextWithOptions(originalImageSize, NO, self.editor.imageView.image.scale); [self.editor.imageView.image drawAtPoint:CGPointZero]; &#x2F;&#x2F;循环_drawingView数组。 for(UIImageView *eachDrawImageView in self.drawImageViews)&#123; if(eachDrawImageView.image)&#123; [eachDrawImageView.image drawInRect:CGRectMake(0, 0, originalImageSize.width, originalImageSize.height)]; &#125; &#125; UIImage *tmp &#x3D; UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return tmp;&#125; 文字帖富文本框doneAppendNewText 点击完成的时候，调用此方法。 [_CLTextView setActiveTextView:nil]; 使当前label 失去焦点。 键盘显示时候，调整textview的高度。12345678- (void)keyBoardWillShow:(NSNotification *)notificatioin&#123; NSDictionary * info &#x3D; [notificatioin userInfo]; CGSize kbSize &#x3D; [[info objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue].size; [_textView mas_updateConstraints:^(MASConstraintMaker *make) &#123; make.bottom.mas_equalTo(-kbSize.height); &#125;];&#125; drawingViewDidPan事件穿透12345678910111213141516- (void)drawingViewDidPan:(UIPanGestureRecognizer*)sender&#123; if([[self.editor currentEditTool] isKindOfClass:[CLMosaicTool class]])&#123; &#x2F;&#x2F;此代码为当顶层为文字层时候， 打开马赛克，pan手势的传递。 CLMosaicTool *mosaicTool &#x3D; [self.editor.usedToolDic objectForKey:@&quot;CLMosaicTool&quot;]; [mosaicTool drawingViewDidPan:sender]; return; &#125;else if([[self.editor currentEditTool] isKindOfClass:[CLDrawTool class]])&#123; &#x2F;&#x2F;此代码为当顶层为文字层时候， 打开涂鸦，pan手势的传递。 CLDrawTool *drawTool &#x3D; [self.editor.usedToolDic objectForKey:@&quot;CLDrawTool&quot;]; [drawTool drawingViewDidPan:sender]; return; &#125;&#125; View容器layer渲染到画布123456789101112131415161718192021222324252627-(UIImage *)mergeDrawImage:(UIImage *)mergeImage&#123; __block CALayer *layer &#x3D; nil; __block CGFloat scale &#x3D; 1; safe_dispatch_sync_main(^&#123; scale &#x3D; mergeImage.size.width &#x2F; self-&gt;_workingView.width; layer &#x3D; self-&gt;_workingView.layer; &#125;); UIGraphicsBeginImageContextWithOptions(mergeImage.size, NO, mergeImage.scale); [mergeImage drawAtPoint:CGPointZero]; CGContextRef context &#x3D; UIGraphicsGetCurrentContext(); CGContextSaveGState(context); CGContextScaleCTM(context, scale, scale); CGContextTranslateCTM(context, _workingView.center.x, _workingView.center.y); CGContextConcatCTM(context, _workingView.transform); CGContextTranslateCTM(context, -_workingView.bounds.size.width * [layer anchorPoint].x, -_workingView.bounds.size.height*[layer anchorPoint].y); [layer renderInContext:context]; CGContextRestoreGState(context); UIImage *tmp &#x3D; UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return tmp;&#125; 旋转在CLClippingTool 旋转完成时候executeWithCompletionBlock:(void (^)(UIImage , NSError , NSDictionary *))completionBlock 对文字帖进行处理,根据旋转裁剪后得到的图片大小决定workingView的容器frame大小。123456CLTextTool *_textTool &#x3D; [self.editor.usedToolDic objectForKey:@&quot;CLTextTool&quot;]; if(_textTool)&#123; &#x2F;&#x2F;将workingView 进行transform旋转 CGAffineTransform transform &#x3D; CATransform3DGetAffineTransform([self rotateTransform:CATransform3DIdentity clockwise:NO]); [self.editor resetTextWorkingViewFrame:_textTool.workingView byResultImage:result transform:transform]; 对workingView 容器进行旋转，设置其transform.1234567891011121314151617181920212223242526272829303132- (void)resetTextWorkingViewFrame:(UIView *)workingView byResultImage:(UIImage *)image transform:(CGAffineTransform )transform&#123; CGRect originFrame &#x3D; workingView.frame; CLTextTool *textTool &#x3D; [self.usedToolDic objectForKey:@&quot;CLTextTool&quot;]; CGFloat offsetBottom &#x3D; textTool.workingViewBottomOffset; originFrame.size.height +&#x3D; offsetBottom; workingView.frame &#x3D; originFrame; &#x2F;&#x2F;加上底部的菜单偏离差 _textToolNeedAddBottomFlag &#x3D; NO; if(offsetBottom &#x3D;&#x3D; 0)&#123; _textToolNeedAddBottomFlag &#x3D; YES; &#125; CGSize size &#x3D; image ? image.size : workingView.frame.size; CGAffineTransform resultTransform &#x3D; transform; if(!CGAffineTransformIsIdentity(workingView.transform))&#123; &#x2F;&#x2F;判断是否进行旋转过,然后进行叠加 resultTransform &#x3D; CGAffineTransformConcat(workingView.transform,transform); &#125; workingView.transform &#x3D; resultTransform; &#x2F;&#x2F;692, 409,旋转了两次，这个不对。 CGRect workingViewWillFrame &#x3D; workingView.frame; &#x2F;&#x2F;409 , 692 if(size.width&gt;0 &amp;&amp; size.height&gt;0)&#123; CGFloat ratio &#x3D; MIN(_scrollView.frame.size.width &#x2F; size.width, _scrollView.frame.size.height &#x2F; size.height); CGFloat W &#x3D; ratio * size.width * _scrollView.zoomScale; CGFloat H &#x3D; ratio * size.height * _scrollView.zoomScale; CGFloat scaleX &#x3D; W&#x2F;workingViewWillFrame.size.width; CGFloat scaleY &#x3D; H&#x2F;(workingViewWillFrame.size.height); CGFloat willScale &#x3D; MIN(scaleX, scaleY); &#x2F;&#x2F;拿到旋转后的缩放比 workingView.transform &#x3D;CGAffineTransformIdentity; &#x2F;&#x2F;旋转，加缩放系数。 workingView.transform &#x3D; CGAffineTransformScale(resultTransform, willScale, willScale); &#125; 裁剪旋转旋转用户通过点击旋转按钮- (void)tappedRoteMenu:(UITapGestureRecognizer*)sender 旋转通过_rotateImageView 来展示旋转的动画和实时效果， rotateStateDidChange方法实现旋转动画1234- (void)rotateStateDidChange&#123; CATransform3D transform &#x3D; [self rotateTransform:CATransform3DIdentity clockwise:NO]; _rotateImageView.layer.transform 设置。 旋转动画结束后：重新设置一下裁剪格子。123456 _rotateView.hidden &#x3D; YES; _gridView &#x3D; [[CLClippingPanel alloc] initWithSuperview:self.editor.imageView.superview frame:_rotateImageView.frame];_gridView.backgroundColor &#x3D; [UIColor clearColor];_gridView.bgColor &#x3D; [self.editor.view.backgroundColor colorWithAlphaComponent:0.8];_gridView.gridColor &#x3D; [[UIColor whiteColor] colorWithAlphaComponent:0.8];_gridView.clipsToBounds &#x3D; NO; 图片旋转：将原图的CIImage注入到CIFilter中，设置CIFilter的旋转系数，CIFilter导出旋转后的CIImage, 通过CIContext 将导出的新图片CIImage转换成CGImage,最后拿到UIImage。 参考以下代码：12345678910111213141516171819- (UIImage*)buildRoteImage:(UIImage*)image&#123; CIImage *ciImage &#x3D; [[CIImage alloc] initWithImage:image]; CIFilter *filter &#x3D; [CIFilter filterWithName:@&quot;CIAffineTransform&quot; keysAndValues:kCIInputImageKey, ciImage, nil]; [filter setDefaults]; CGAffineTransform transform &#x3D; CATransform3DGetAffineTransform([self rotateTransform:CATransform3DIdentity clockwise:YES]); [filter setValue:[NSValue valueWithBytes:&amp;transform objCType:@encode(CGAffineTransform)] forKey:@&quot;inputTransform&quot;]; CIContext *context &#x3D; [CIContext contextWithOptions:@&#123;kCIContextUseSoftwareRenderer : @(NO)&#125;]; CIImage *outputImage &#x3D; [filter outputImage]; CGImageRef cgImage &#x3D; [context createCGImage:outputImage fromRect:[outputImage extent]]; UIImage *result &#x3D; [UIImage imageWithCGImage:cgImage]; CGImageRelease(cgImage); return result;&#125; 裁剪裁剪方法crop:12345678910111213- (UIImage*)crop:(CGRect)rect&#123; CGPoint origin &#x3D; CGPointMake(-rect.origin.x, -rect.origin.y); UIImage *img &#x3D; nil; UIGraphicsBeginImageContextWithOptions(rect.size, NO, self.scale); [self drawAtPoint:origin]; img &#x3D; UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return img;&#125;裁剪视图: CLClippingPanel： subLayer: CLGridLayar -&gt; drawInContext。横竖各画四条线。 CLClippingCircle-&gt;drawRect: 四个边角框视图进行边角划线操作。 四个边角视图添加panCircleView手势，实现clippingRect裁剪区域的变更。 CLClippingPanl 自身事件panGridView，拖动格子进行上下左右移动改变clippingRect区域。 原图恢复resetOriginImage 方法。原图恢复只恢复原图的frame，原图的方向。 已画涂鸦和马赛克操作不进行恢复。 先将_originalImage 赋值给_imageView,重新计算最新originFrame. 并且将马赛克和涂鸦工具对象的[drawImageView]集合遍历每一层的drawImageView设置为_imageView最新frame,并再次渲染每张图的一条线的涂鸦图片赋值给drawImageView,并更改drawImageView最新的frame. 最后走一遍重新关和开，展示恢复后的裁剪格和图片。这样就完成了原图恢复这样一个功能。 1234567891011121314151617181920212223242526272829303132- (void)resetOriginImage&#123; _imageView.image &#x3D; _originalImage; &#x2F;&#x2F;设置当前imageview最新frame [self resetImageViewFrame]; &#x2F;&#x2F;对马赛克层进行frame重新设置。 CLMosaicTool *_mosaicTool &#x3D; [self.usedToolDic objectForKey:@&quot;CLMosaicTool&quot;]; if(_mosaicTool)&#123; for(NSInteger i&#x3D;0; i &lt; _mosaicTool.drawImageViews.count; i++)&#123; UIImageView *drawingView &#x3D; _mosaicTool.drawImageViews[i]; drawingView.frame &#x3D; self.imageView.bounds; [_mosaicTool drawAllPanLine:drawingView byDrawPage:_mosaicTool.mosaicPages[i]]; [self resetDrawImageViewFrame:drawingView.image withDrawImageView:drawingView]; &#125; &#125; &#x2F;&#x2F;对画笔层进行frame重新设置。 CLDrawTool *_drawTool &#x3D; [self.usedToolDic objectForKey:@&quot;CLDrawTool&quot;]; if(_drawTool)&#123; for(NSInteger i&#x3D;0; i &lt; _drawTool.drawImageViews.count; i++)&#123; UIImageView *drawingView &#x3D; _drawTool.drawImageViews[i]; drawingView.frame &#x3D; self.imageView.bounds; [_drawTool drawAllPanLine:drawingView byDrawPage:_drawTool.drawPages[i]]; [self resetDrawImageViewFrame:drawingView.image withDrawImageView:drawingView]; &#125; &#125; &#x2F;&#x2F;重新开启裁剪页面功能 [_currentTool cleanup]; [_currentTool setup];&#125; 确定走pushDone方法，调用自身的executeWithCompletionBlock方法，检查UseToolDic是否含有涂鸦，马赛克、文字帖等，进行相关视图的旋转裁剪设置frame等操作。 [self.currentTool executeWithCompletionBlock: 取消重置currentTool 为nil , 走cleanUp方法，移除相关视图。此篇文章仅为个人总结，仅为图片编辑中所遇难点提供几点思路。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"群通知里的人员名字点击剖析","slug":"nameClick","date":"2021-07-02T09:01:10.000Z","updated":"2021-07-02T09:05:59.601Z","comments":true,"path":"2021/07/02/nameClick/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/02/nameClick/","excerpt":"我们每个人的手机都安装有微信App,肯定大家都使用过以下场景在聊天群中，当有新的成员进入的时候，可以看到 某某邀请了某某1进入群聊，或者当你是群主的时候，某管理人员邀请了几个人进入时候看到 某某管理员邀请了张三、李四，王五，张三（同名）进入了群聊。对于邀请人员或者被邀请人员，我们发现人员的名称是可以点击的，即使同名的人，点击其名字也可以跳转到各自的主页详情中。 如何存储人员的id？一条群成员变更通知就是一串文本，我们点击的时候肯定要存储好他的人员id,然后点击的时候就能拿到对应人员的id。从最简单的存储方案来看，这条内容可以写成以下格式： 管理员刘某某邀请了张三、李四、王五、张三进入了群聊。换成代码的格式即为：“管理员\\”刘某某::1000\\”邀请了\\”张三::1001、李四::1002、王五::1003、张三::1004\\”进入了群聊”。其中的代码格式为userName::userId这样一种形式进行拼接，中间的符号可以采用其他特殊符号代替。这里为了区别用户特殊性输入用了双冒号。多个成员之间用顿号隔开，人员与普通内容之间用符号双引号\\”进行分割（斜杆为转义符）。 我们需要对这一串文字表达式进行解析进行UI显示，把人员名字后的拼接符号用户id进行过滤掉,组合成不带用户id的易懂文字内容给到用户。","text":"我们每个人的手机都安装有微信App,肯定大家都使用过以下场景在聊天群中，当有新的成员进入的时候，可以看到 某某邀请了某某1进入群聊，或者当你是群主的时候，某管理人员邀请了几个人进入时候看到 某某管理员邀请了张三、李四，王五，张三（同名）进入了群聊。对于邀请人员或者被邀请人员，我们发现人员的名称是可以点击的，即使同名的人，点击其名字也可以跳转到各自的主页详情中。 如何存储人员的id？一条群成员变更通知就是一串文本，我们点击的时候肯定要存储好他的人员id,然后点击的时候就能拿到对应人员的id。从最简单的存储方案来看，这条内容可以写成以下格式： 管理员刘某某邀请了张三、李四、王五、张三进入了群聊。换成代码的格式即为：“管理员\\”刘某某::1000\\”邀请了\\”张三::1001、李四::1002、王五::1003、张三::1004\\”进入了群聊”。其中的代码格式为userName::userId这样一种形式进行拼接，中间的符号可以采用其他特殊符号代替。这里为了区别用户特殊性输入用了双冒号。多个成员之间用顿号隔开，人员与普通内容之间用符号双引号\\”进行分割（斜杆为转义符）。 我们需要对这一串文字表达式进行解析进行UI显示，把人员名字后的拼接符号用户id进行过滤掉,组合成不带用户id的易懂文字内容给到用户。 解析带用户id的字符串规则，拼装成正常文本判断待解析的目标内容是否包含我们定义的特殊连接符号与双引号，符合条件的情况下第一步以双引号将文本进行分割。分为以下步骤。 双引号将文本进行分割成不同段的数组。 遍历数组，判断不同段中是否还有顿号，如果有则需要再根据顿号进行分割成最小粒化段（userName::userId），否则直接判断是否最小粒化段（判断是否包含特殊符::）,如果包含，则以特舒符再将文本分割、否则直接添加到可变字符串中进行拼接。这样我们就能够拿到userName 以及 userId. 另外准备一个数组，存储每一个被分割的最小粒化段 {userName::userId}。 记得把人员之间的顿号，以及普通文本与人员之间的双引号加回去。最终的到了正常显示的文本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960if([msgBody containsString:@&quot;\\&quot;&quot;] &amp;&amp; [msgBody containsString:@&quot;::&quot;])&#123; NSArray *descArr &#x3D; [msgBody componentsSeparatedByString:@&quot;\\&quot;&quot;]; NSMutableString *afterFilterIdStr &#x3D; [[NSMutableString alloc] init]; &#x2F;&#x2F;过滤出Id后要显示在界面的str NSMutableArray *filterEmpDicArr &#x3D; [[NSMutableArray alloc] init]; &#x2F;&#x2F;过滤出成员 NSInteger findIndex &#x3D; 0; for (NSString *eachStr in descArr) &#123; findIndex ++; &#x2F;&#x2F;加入双引号 if(eachStr.length &gt; 0)&#123; if([eachStr containsString:@&quot;、&quot;])&#123; NSArray *namesArr &#x3D; [eachStr componentsSeparatedByString:@&quot;、&quot;]; NSInteger otherFindIndex &#x3D; 0; for(NSString *otherName in namesArr)&#123; otherFindIndex ++; if([otherName containsString:@&quot;::&quot;])&#123; &#x2F;&#x2F;需分割取得名字 NSArray *itemStrArr &#x3D; [otherName componentsSeparatedByString:@&quot;::&quot;]; if(itemStrArr.count)&#123; NSString *empName &#x3D; itemStrArr.firstObject; NSString *empId &#x3D; itemStrArr.lastObject; [afterFilterIdStr appendString:empName]; [filterEmpDicArr addObject:@&#123;@&quot;name&quot;:empName,@&quot;id&quot;:empId&#125;]; &#125; &#125; if(otherFindIndex &lt; namesArr.count)&#123; [afterFilterIdStr appendString:@&quot;、&quot;]; &#125; &#125; &#125;else&#123; if([eachStr containsString:@&quot;::&quot;])&#123; &#x2F;&#x2F;需分割取得名字 NSArray *itemStrArr &#x3D; [eachStr componentsSeparatedByString:@&quot;::&quot;]; if(itemStrArr.count)&#123; NSString *empName &#x3D; itemStrArr.firstObject; NSString *empId &#x3D; itemStrArr.lastObject; [afterFilterIdStr appendString:empName]; NSString * oldContainsStr &#x3D; @&quot;将&quot;; &#x2F;&#x2F;兼容移除群聊的显示结果 if([empId containsString:oldContainsStr])&#123; [afterFilterIdStr appendString:oldContainsStr]; NSArray *oldArr &#x3D; [empId componentsSeparatedByString:oldContainsStr]; empId &#x3D; oldArr.firstObject; &#125; [filterEmpDicArr addObject:@&#123;@&quot;name&quot;:empName,@&quot;id&quot;:empId&#125;]; &#125; &#125;else&#123; &#x2F;&#x2F;普通字符串 [afterFilterIdStr appendString:eachStr]; &#125; &#125; &#125; if(findIndex &lt; descArr.count)&#123; [afterFilterIdStr appendString:@&quot;\\&quot;&quot;]; &#125; &#125; NSString *realMsgBody &#x3D; [afterFilterIdStr copy];&#125; 通过以上代码，我们得到realMsgBody就是需要在文本上直接显示的内容，另外我们还得到了filterEmpDicArr包含了成员id的一个map。 渲染人员名字、增加样式蓝色，表示可以点击由上一步，我们得到可正常显示在UI上的文字，另外还得到一个人名id的字典数组。渲染显示我们采用YYLabel设置Attribute的方式。先设置全内容属性mAttributedString。然后循环遍历filterEmpDicArr,根据人名创建名字高亮的lightAttribute。根据人名得到nameRange, 最后再采用替换方式将对应range进行替换掉属性。代码：1[mAttributedString replaceCharactersInRange:nameRange withAttributedString:lightNameAttributeStr];这里有一个问题，当匹配到第四个人时候，取到的nameRange是第一个人张三，结果并不对。来看看我们取nameRange的方式：1NSRange range &#x3D; [realMsgBody rangeOfString:empName]; &#x2F;&#x2F;可能存在多个 这个时候就需要判断名字是否在文本中多次出现。当同名时候，我们需要把匹配到该人名的range全部找出来，而不是一个range。 当遍历当前的name时候，检查该人名出现的次数，出现第几次则这个当前遍历的人名的range则是对应第几个range. 这个逻辑才是正确的！这个时候，我们可以把当前遍历的userId对应的正确的range记录下来存到一个map中。最后当用户点击蓝色某名字时候label点击处所对应的range会返回，这个时候我们就可以根据range来命中userId了。当点击同名的时候不知道点击的是谁的问题就可以迎刃而解！此处应该有点赞，哈。过奖了，只是一个技巧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657NSString *realMsgBody &#x3D; [afterFilterIdStr copy];NSMutableAttributedString *mAttributedString &#x3D; [[NSMutableAttributedString alloc] initWithString:realMsgBody];mAttributedString.yy_font &#x3D; labelFont;mAttributedString.yy_color &#x3D; message_centerTextColor;mAttributedString.yy_alignment &#x3D; NSTextAlignmentCenter;NSMutableDictionary *recordNameCountDic &#x3D; [[NSMutableDictionary alloc] init]; &#x2F;&#x2F;缓存每个名字记录的次数NSMutableDictionary *recordRangeEmpIdDic &#x3D; [[NSMutableDictionary alloc] init]; &#x2F;&#x2F;记录每个名字的range对应的id&#x2F;&#x2F;循环找出名字，并且替换attribute;for (NSDictionary *empDic in filterEmpDicArr) &#123; NSString *empName &#x3D; empDic[@&quot;name&quot;]; NSString *empId &#x3D; empDic[@&quot;id&quot;]; NSMutableAttributedString *lightNameAttributeStr &#x3D; [[NSMutableAttributedString alloc] initWithString:empName]; lightNameAttributeStr.yy_font &#x3D; labelFont; lightNameAttributeStr.yy_underlineStyle &#x3D; NSUnderlineStyleNone; &#x2F;&#x2F;NSUnderlineStyleSingle; lightNameAttributeStr.yy_color &#x3D; message_centerTextColor; lightNameAttributeStr.yy_lineSpacing &#x3D; 2; __weak typeof(self) weakSelf &#x3D; self; [lightNameAttributeStr yy_setTextHighlightRange:lightNameAttributeStr.yy_rangeOfAll color:[UIColor colorWithRed:110&#x2F;255.0f green:121&#x2F;255.0f blue:151&#x2F;255.0f alpha:1] backgroundColor:[UIColor colorWithWhite:0.000 alpha:0.0] tapAction:^(UIView *containerView, NSAttributedString *text, NSRange range, CGRect rect)&#123; &#x2F;&#x2F;点击名字跳转 &#x2F;&#x2F; NSString *empName &#x3D; [text.string substringWithRange:range]; NSString *empId &#x3D; [recordRangeEmpIdDic objectForKey:[NSValue valueWithRange:range]]; if(empId &amp;&amp; weakSelf.tappedNameBlock)&#123; weakSelf.tappedNameBlock(empId); &#125; &#125;]; NSRange range &#x3D; [realMsgBody rangeOfString:empName]; &#x2F;&#x2F;可能存在多个 &#x2F;&#x2F;同名可匹配出多个range NSArray *rangeArr &#x3D; [self rangeOfSubString:empName inString:realMsgBody]; if(rangeArr.count &amp;&amp; rangeArr.count &gt; 1)&#123; &#x2F;&#x2F;有多个重名，拿字典记录的值&#123;name:count&#125; 名字次数. count有存切大于1时，本次的range为 rangeArr【count】 if([recordNameCountDic objectForKey:empName])&#123; NSInteger nameCount &#x3D; [[recordNameCountDic objectForKey:empName] integerValue]; nameCount++; &#x2F;&#x2F;rangeArr[name]记录的count累加 [recordNameCountDic setObject:@(nameCount) forKey:empName]; NSValue * value &#x3D; rangeArr[nameCount-1]; range &#x3D; [value rangeValue]; &#125;else&#123; [recordNameCountDic setObject:@1 forKey:empName]; NSValue * value &#x3D; rangeArr.firstObject; range &#x3D; [value rangeValue]; &#125; &#125; &#x2F;&#x2F;根据range来记录id NSValue *rangeKey &#x3D; [NSValue valueWithRange:range]; [recordRangeEmpIdDic setObject:empId forKey:rangeKey]; [mAttributedString replaceCharactersInRange:range withAttributedString:lightNameAttributeStr];&#125;mAttributedString.yy_lineSpacing &#x3D; 2;self.groupInfolabel.attributedText &#x3D; mAttributedString; 以下是匹配一个字符串里包含字段某字符串的所有range12345678910111213- (NSArray*)rangeOfSubString:(NSString*)subStr inString:(NSString*)string &#123; NSMutableArray *rangeArray &#x3D; [NSMutableArray array]; NSString*string1 &#x3D; [string stringByAppendingString:subStr]; NSString *temp; for(int i &#x3D;0; i &lt; string.length; i ++) &#123; temp &#x3D; [string1 substringWithRange:NSMakeRange(i, subStr.length)]; if ([temp isEqualToString:subStr]) &#123; NSRange range &#x3D; &#123;i,subStr.length&#125;; [rangeArray addObject: [NSValue valueWithRange:range]]; &#125; &#125; return rangeArray;&#125; 正则过滤处理将符合改正则表达式的字符串找出来，NSRegularExpression可以拿到NSTextCheckingResult,然后result可以拿到range.把对应的字符串截取出来。最后再循环遍替换成空字符串。1234567891011121314151617181920 if([msgBody containsString:@&quot;::&quot;])&#123; &#x2F;&#x2F;匹配替换掉::工号显示。 NSMutableArray *replaceFormatStrArr &#x3D; [[NSMutableArray alloc] init]; NSError *error &#x3D; nil; NSRegularExpression *regexp &#x3D; [NSRegularExpression regularExpressionWithPattern:@&quot;::\\\\d&#123;1,&#125;&quot; options:NSRegularExpressionCaseInsensitive error:&amp;error]; [regexp enumerateMatchesInString:msgBody options:0 range:NSMakeRange(0, msgBody.length) usingBlock:^(NSTextCheckingResult *result, __unused NSMatchingFlags flags, __unused BOOL *stop) &#123; if (flags !&#x3D; NSMatchingInternalError) &#123; NSRange firstHalfRange &#x3D; [result rangeAtIndex:0]; if (firstHalfRange.length &gt; 0) &#123; NSString *resultString1 &#x3D; [msgBody substringWithRange:result.range]; [replaceFormatStrArr addObject:resultString1]; NSLog(@&quot;result1 &#x3D; %@&quot;,resultString1); &#125; &#125; &#125;]; for(NSString *formatStr in replaceFormatStrArr)&#123; msgBody &#x3D; [msgBody stringByReplacingOccurrencesOfString:formatStr withString:@&quot;&quot;]; &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"群插件如何开发？","slug":"groupPlugin","date":"2021-07-01T09:52:11.000Z","updated":"2021-07-01T10:02:44.468Z","comments":true,"path":"2021/07/01/groupPlugin/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/01/groupPlugin/","excerpt":"群插件的基础属性群插件一般是用H5配置的网页小插件，然后和群构造一个入口。本地通过sqlite维护一个插件表，以及群插件关系表。插件信息升级一下可分为平台系统必须插件以及业务自定义插件。具体可由业务决定。插件有其基本属性：名称，插件id，类型，默认排序值，跳转内容(本地模块名/h5链接地址)，跳转类型：h5/本地模块 等等。插件关系表： 群id，插件id，角标数量，排序值，是否显示，等等。","text":"群插件的基础属性群插件一般是用H5配置的网页小插件，然后和群构造一个入口。本地通过sqlite维护一个插件表，以及群插件关系表。插件信息升级一下可分为平台系统必须插件以及业务自定义插件。具体可由业务决定。插件有其基本属性：名称，插件id，类型，默认排序值，跳转内容(本地模块名/h5链接地址)，跳转类型：h5/本地模块 等等。插件关系表： 群id，插件id，角标数量，排序值，是否显示，等等。 群插件的本地存储以及业务逻辑由于每个IM用户本地都有一个相关的userId唯一数据库，插件基础信息存储在一张表，信息更新频率较低。插件关系一张表，和群id关联性较高，即一个群可以有多个插件。当用户登录后，在适当的时机请求Java接口进行同步插件信息。（客户端可以根据时间戳定义一个时间段，这样就不用每次登录同步插件信息了）由业务决定多久时间段同步最新的插件信息到本地。如果后端后台配置了最新插件，客户单需要及时显示的话就需要服务端进行实时下发IM通知，表示有插件更新或新增。群插件当且仅当和群挂钩时候才会实时下发。当客户端收到群插件变更指令的时候，首先判断群插件变更类型如果是插件信息变更，则根据id请求最新的某插件信息 replace into（更新或新增） 插件信息的记录。如果是其他变更类型： 首先检查插件表是否有该插件记录，如果有，则存储到插件关系表，完成后则通知界面去读取群最新的插件信息。如果没有，则先请求网络插件信息，再replace into 到插件表。然后再处理插件关系表，最后通知到界面刷新。 群插件的变更类型一般可分为以下几种：绑定，解绑，角标数量，群插件排序，显示/隐藏等等。具体根据业务情况，这里只是简单列举。 界面刷新当IM收到群插件自定义通知时，进行条件处理对应的业务。当完成群插件关系表的变更时，发送通知到控制器，控制器收到通知后，判断仅当当前会id与要接收通知的群id相等的时候，才进行调用dao查询群插件列表方法返回相关的插件关系集合。插件关系Model包含插件信息Model，然后界面就能完整显示了。 同步时机？ 当用户登录后，首次点开某群时候，会自动调用同步群信息基础接口，里面包含插件集合。集合里分别为已关联的某插件id在当前群的最终状态。根据existGroupFlag为true表示与该群关联着，如果为false 则需要调用解绑删除群插件关系。 当用户首次安装或卸载重装时候，进入消息首页会进行多群同步，在群信息同步时返回的基础信息也会包含此群插件集合基信息。 代码建议插件Dao提供查询，修改，删除等基本方法。插件Manager专门处理业务，调用Dao相关方法结合完成业务需求。避免block回调地狱,防止多层嵌套。内存排序和sql排序相结合，结构体和对象Model相映射，解包时候留意结构体字段类型，解码时候对应相关网络字节序，留意新增与replace into 的区别，界面刷新严格条件过滤防止造成不必要的刷新。插件基本信息同步频率看业务，关系绑定要实时，测试要充分留意卸载重装后的插件信息同步问题。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"聊天输入框@某人","slug":"input@","date":"2021-07-01T08:42:10.000Z","updated":"2021-07-01T08:42:41.992Z","comments":true,"path":"2021/07/01/input@/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/01/input@/","excerpt":"聊天输入框@某人逻辑分类点说明IM 应用软件无论是App端或者是PC端都有@某人这样一个功能点，由于用户输入框输入条件的复杂随机性种类多，@的针对不同情况进行拼接或者新增样式显示蓝色字体表示该人名可链接。由输入框开始，用户输入@的方式进行分类： 首字母为空，用户直接输入@，然后跳转到成员页面进行选择相关人员，选完即带回人名 结果为：“@某人” input输入框输入了文字的基础上: 在最前面下班为0的第1个位置进行插入@ 结果为：“@某人原input输入框的文字” input输入框输入了文字的基础上，在最后面下班为length-1的第后一个位置进行插入@ 结果为：“原input输入框的文字@某人” input输入框输入了文字的基础上，在文字内容中输入@。即条件 0 &lt; index &lt; length-1 结果为：“原input输入@某人框的文字” 在以上四种输入情况中，3，4 输入拼接@某人的时候，需要判断前一个字是否为@, 如果是,则后面拼接的时候直接+某人即可。另外当在第4种情况文字中间输入的时候，中英文下输入可能遇到文本框的值为 “ @@文字”，按照之前的逻辑当光标输入在第2个@后时，然后键盘输入@跳转页面选择成员，最后的结果应该是“ @@某人文字”这个组合，为了更友好地显示，还需检查当前两个也是@的时候，即出现1个@. 即结果为“ @某人文字” 以便更友好地显示。 核心逻辑：根据文本框原输入文字是否有内容，无内容时候直接拼接。有内容时候分两种情况，即光标的输入位置情况：当location等于0的时候，即在首位置输入@某人拼接原文本内容。当location大于0的时候，即光标可能出现在内容文字之间，也可能是在最后面。也是分两种情况：根据location+1判断是否小于原文本框文字长度length.如果小于，则表示在内容之间插入。否则,在内容最后尾部插入。无论是之间还是尾部做插入，都需检查前一个字符是否为@,如果是，则在做拼接人名时候就无需再追加@。当在之间做插入的时候，为了友好显示，可适当判断前两个字符为@@时候进行替换为一个@。","text":"聊天输入框@某人逻辑分类点说明IM 应用软件无论是App端或者是PC端都有@某人这样一个功能点，由于用户输入框输入条件的复杂随机性种类多，@的针对不同情况进行拼接或者新增样式显示蓝色字体表示该人名可链接。由输入框开始，用户输入@的方式进行分类： 首字母为空，用户直接输入@，然后跳转到成员页面进行选择相关人员，选完即带回人名 结果为：“@某人” input输入框输入了文字的基础上: 在最前面下班为0的第1个位置进行插入@ 结果为：“@某人原input输入框的文字” input输入框输入了文字的基础上，在最后面下班为length-1的第后一个位置进行插入@ 结果为：“原input输入框的文字@某人” input输入框输入了文字的基础上，在文字内容中输入@。即条件 0 &lt; index &lt; length-1 结果为：“原input输入@某人框的文字” 在以上四种输入情况中，3，4 输入拼接@某人的时候，需要判断前一个字是否为@, 如果是,则后面拼接的时候直接+某人即可。另外当在第4种情况文字中间输入的时候，中英文下输入可能遇到文本框的值为 “ @@文字”，按照之前的逻辑当光标输入在第2个@后时，然后键盘输入@跳转页面选择成员，最后的结果应该是“ @@某人文字”这个组合，为了更友好地显示，还需检查当前两个也是@的时候，即出现1个@. 即结果为“ @某人文字” 以便更友好地显示。 核心逻辑：根据文本框原输入文字是否有内容，无内容时候直接拼接。有内容时候分两种情况，即光标的输入位置情况：当location等于0的时候，即在首位置输入@某人拼接原文本内容。当location大于0的时候，即光标可能出现在内容文字之间，也可能是在最后面。也是分两种情况：根据location+1判断是否小于原文本框文字长度length.如果小于，则表示在内容之间插入。否则,在内容最后尾部插入。无论是之间还是尾部做插入，都需检查前一个字符是否为@,如果是，则在做拼接人名时候就无需再追加@。当在之间做插入的时候，为了友好显示，可适当判断前两个字符为@@时候进行替换为一个@。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152NSString *newNameStr &#x3D; nil; if(originStr.length &gt; 1)&#123; NSMutableString *mStr &#x3D; [[NSMutableString alloc] init]; if(_range.location &gt; 0)&#123; &#x2F;&#x2F;在中间或者在末尾插入@,取出之前的，再取出之后的。 NSString *beforeStr &#x3D; [originStr substringWithRange:NSMakeRange(0, _range.location)]; [mStr appendString:beforeStr]; BOOL bCenterInsertFlag &#x3D; NO; BOOL bNeedInsertAtFlag &#x3D; YES; if(_range.location + 1 &lt; originStr.length)&#123; bCenterInsertFlag &#x3D; YES; &#x2F;&#x2F;中间插入.判断前一个是否@ NSString *lastChar &#x3D; [beforeStr substringFromIndex:beforeStr.length-1]; if([lastChar isEqualToString:@&quot;@&quot;])&#123; bNeedInsertAtFlag &#x3D; NO; &#125; if(beforeStr.length &gt; 2 &amp;&amp; beforeStr.length-2 &gt; 0)&#123; NSString *lastTwoChar &#x3D; [beforeStr substringFromIndex:beforeStr.length-2]; if([lastTwoChar isEqualToString:@&quot;@@&quot;])&#123; [mStr replaceOccurrencesOfString:@&quot;@@&quot; withString:@&quot;@&quot; options:nil range:NSMakeRange(0, mStr.length)]; &#125; &#125; &#125;else&#123; &#x2F;&#x2F;末尾插入.判断前一个是否@ NSString *lastChar &#x3D; [beforeStr substringFromIndex:beforeStr.length-1]; if([lastChar isEqualToString:@&quot;@&quot;])&#123; bNeedInsertAtFlag &#x3D; NO; &#125; &#125; if(bNeedInsertAtFlag)&#123; [mStr appendString:@&quot;@&quot;]; &#125; [mStr appendString:nameStr]; if(bCenterInsertFlag)&#123; &#x2F;&#x2F;如果在文字中间插入,拿到@之后的字符串 NSString *afterStr &#x3D; [originStr substringFromIndex:_range.location+1]; [mStr appendString:afterStr]; &#125; &#125;else&#123; &#x2F;&#x2F;首字母为@符号，截取之后的. [mStr appendString:@&quot;@&quot;]; [mStr appendString:nameStr]; NSString *afterStr &#x3D; [originStr substringFromIndex:1]; [mStr appendString:afterStr]; &#125; newNameStr &#x3D; mStr; &#125;else&#123; newNameStr &#x3D; [NSString stringWithFormat:@&quot;%@%@&quot;,mutableStr,nameStr]; &#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"奇怪的侧边栏问题","slug":"LeftSlide","date":"2021-07-01T03:37:12.000Z","updated":"2021-07-01T03:42:09.324Z","comments":true,"path":"2021/07/01/LeftSlide/","link":"","permalink":"https://www.littlewhale.xyz/2021/07/01/LeftSlide/","excerpt":"开发中由于系统版本以及sdk，第三方库等原因，都会影响成出现一些奇怪的问题。当时是引用YYTextview控件解决消息cell长文本的光标选择范围内容复制的小功能。由于YYTextview光标弹出层自定义在另外一个新的Windown上，然后左侧侧滑出的view是新增在另一个新的Windown中。当侧边栏dismiss的时候，可能由于windown层级的影响，当在聊天输入框再次输入文字长按时候，系统出现的UIMenu层的Button不见了。当时想从根本问题去排查为啥系统的UIMenu当长按的时候操作功能的button为啥不见去解决，花费了将近2个多小时通过Xcode调试查看层级，阅读YYTextview的光标自定义层的实现以及添加到windown的层级，查看左侧侧边栏添加动画实现方式等都未解决。然后想到如果不通过新创建window来添加view 实现动画，而是通过present一个控制器实现侧边栏动画。最终问题得到了解决。 旧Slide侧滑方案旧有的侧滑方案是创建一个新window,然后设置其windowLevel 为正常的+1，这样就在最顶层了，然后设置其rootViewController为侧滑的控制器。很有可能是新创建的window与YYtextView的光标选择层创建的window有冲突，然后造成UIMenu按钮消失了。 改进方案，Present一个控制器 SlideVC实则我们可以通过拿到最顶层控制器topVC，用导航控制器把SlideVC包裹好，设置它的 modalPresentationStyle 模式为UIModalPresentationOverCurrentContext，然后present出来 .这里要注意的是，系统的present方法是否有被runtime method swizled进行方法替换来公共统一处理modelPresentStyle问题，因为有些App交互不想使用系统的抽屉式present效果, 如果有需要做相关的过滤业务控制器逻辑判断。 侧边动画的实现：在SlideVC中定义一个半透明层背景bgView，添加tap手势，点击即关闭。往bgView添加一个左侧内容视图leftView 75%宽,右侧rightView。self.view添加一个Pan手势，用来计算leftView拖拽时候X的值位移变化。将内容控制器交由SlideVC管理：","text":"开发中由于系统版本以及sdk，第三方库等原因，都会影响成出现一些奇怪的问题。当时是引用YYTextview控件解决消息cell长文本的光标选择范围内容复制的小功能。由于YYTextview光标弹出层自定义在另外一个新的Windown上，然后左侧侧滑出的view是新增在另一个新的Windown中。当侧边栏dismiss的时候，可能由于windown层级的影响，当在聊天输入框再次输入文字长按时候，系统出现的UIMenu层的Button不见了。当时想从根本问题去排查为啥系统的UIMenu当长按的时候操作功能的button为啥不见去解决，花费了将近2个多小时通过Xcode调试查看层级，阅读YYTextview的光标自定义层的实现以及添加到windown的层级，查看左侧侧边栏添加动画实现方式等都未解决。然后想到如果不通过新创建window来添加view 实现动画，而是通过present一个控制器实现侧边栏动画。最终问题得到了解决。 旧Slide侧滑方案旧有的侧滑方案是创建一个新window,然后设置其windowLevel 为正常的+1，这样就在最顶层了，然后设置其rootViewController为侧滑的控制器。很有可能是新创建的window与YYtextView的光标选择层创建的window有冲突，然后造成UIMenu按钮消失了。 改进方案，Present一个控制器 SlideVC实则我们可以通过拿到最顶层控制器topVC，用导航控制器把SlideVC包裹好，设置它的 modalPresentationStyle 模式为UIModalPresentationOverCurrentContext，然后present出来 .这里要注意的是，系统的present方法是否有被runtime method swizled进行方法替换来公共统一处理modelPresentStyle问题，因为有些App交互不想使用系统的抽屉式present效果, 如果有需要做相关的过滤业务控制器逻辑判断。 侧边动画的实现：在SlideVC中定义一个半透明层背景bgView，添加tap手势，点击即关闭。往bgView添加一个左侧内容视图leftView 75%宽,右侧rightView。self.view添加一个Pan手势，用来计算leftView拖拽时候X的值位移变化。将内容控制器交由SlideVC管理：12[self addChildViewController:self.leftVC];[self.leftVC didMoveToParentViewController:self];当slideVC控制器ViewDidApper显示的时候，我们即做动画（可以加一个开关状态判断其是否打开）。根据侧滑手指移动距离是否使内容View到屏幕的一半，否则复位。然后可以适当做一点弹性动画。通过UIview的animateWithDuration: usingSpringWithDamping:方法进行设置。123456789101112131415161718192021- (void)showAnimation &#123; self.view.userInteractionEnabled &#x3D; NO; self.menuOpenFlag &#x3D; YES; if(!self.hasMoreThenHalf)&#123; CGAffineTransform translate &#x3D; CGAffineTransformMakeTranslation(-300, 0); CGAffineTransform scale &#x3D; CGAffineTransformMakeScale(3.0, 1.0); self.modalView.transform &#x3D; CGAffineTransformConcat(translate, scale); &#125; CGFloat time &#x3D; fabs(self.modalView.frame.origin.x &#x2F; self.modalView.frame.size.width) * animationTime; [UIView animateWithDuration:time delay:0.0 usingSpringWithDamping:0.85 initialSpringVelocity:0.7 options:UIViewAnimationOptionCurveLinear animations:^&#123; if(self.hasMoreThenHalf)&#123; self.modalView.frame &#x3D; CGRectMake(0, 0, MenuWidth, [UIScreen mainScreen].bounds.size.height); &#125;else&#123; self.modalView.transform &#x3D; CGAffineTransformIdentity; &#125; &#125; completion:^(BOOL finished) &#123; self.view.userInteractionEnabled &#x3D; YES; self.menuOpenFlag &#x3D; YES; &#125;];&#125;当关闭的时候：进行视图的复位动画，然后dismiss控制器。这个是主动关闭。另外需要预留好被动其他业务情况下需要关闭侧边栏的情况，注册好相关的通知，当收到通知时，就自动关闭了侧边栏。1234567891011121314- (void)closeAnimation &#123; self.view.userInteractionEnabled &#x3D; NO; self.hasMoreThenHalf &#x3D; NO; &#x2F;&#x2F; 根据当前x，计算隐藏时间 CGFloat time &#x3D; (1 - fabs(self.modalView.frame.origin.x &#x2F; self.modalView.frame.size.width)) * animationTime; [UIView animateWithDuration:time animations:^&#123; self.modalView.frame &#x3D; CGRectMake(-self.modalView.frame.size.width, 0, self.modalView.frame.size.width, [UIScreen mainScreen].bounds.size.height); self.bgView.alpha &#x3D; 0.0; &#125; completion:^(BOOL finished) &#123; self.menuOpenFlag &#x3D; NO; [self dismissViewControllerAnimated:false completion:nil]; &#125;];&#125; Pan手势的事件控制LeftView X坐标位移12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)moveViewWithGesture:(UIPanGestureRecognizer *)panGes &#123; &#x2F;&#x2F; 开始位置 static CGFloat startX; &#x2F;&#x2F; 结束位置 static CGFloat lastX; &#x2F;&#x2F; 改变多少 static CGFloat durationX; CGPoint touchPoint &#x3D; [panGes locationInView:self.view]; &#x2F;&#x2F; 手势开始 if (panGes.state &#x3D;&#x3D; UIGestureRecognizerStateBegan) &#123; startX &#x3D; touchPoint.x; lastX &#x3D; touchPoint.x; &#125; if (panGes.state &#x3D;&#x3D; UIGestureRecognizerStateChanged) &#123; CGFloat currentX &#x3D; touchPoint.x; durationX &#x3D; currentX - lastX; lastX &#x3D; currentX; self.hasMoreThenHalf &#x3D; NO; CGFloat leftVC_X &#x3D; durationX + self.modalView.x; if (leftVC_X &lt;&#x3D; -self.modalView.width) &#123; leftVC_X &#x3D; - self.modalView.width; &#125; &#x2F;&#x2F;如果是向右滑动 if (leftVC_X &gt; 0) &#123; leftVC_X &#x3D; 0; &#125; self.bgView.alpha &#x3D; (1 + leftVC_X &#x2F; self.modalView.frame.size.width) * 0.5; [self.modalView setFrame:CGRectMake(leftVC_X, 0, _modalView.frame.size.width, _modalView.frame.size.height)]; &#125; if (panGes.state &#x3D;&#x3D; UIGestureRecognizerStateEnded) &#123; &#x2F;&#x2F; 超过一半屏幕 if (_modalView.x &gt; - _modalView.frame.size.width + [UIScreen mainScreen].bounds.size.width &#x2F; 2) &#123; self.hasMoreThenHalf &#x3D; YES; [self showAnimation]; &#125;else&#123; [self closeAnimation]; &#125; &#125;&#125; H5页面奇怪的UIDocumentMenuViewController在边栏控制器点击菜单进入进入意见反馈模块，通过input标签打开原生图片选择器出现闪退。此时系统的present会经过两层。第一层是UIDocumentMenuViewController,第二层才到系统选择相册那个控制器。所以我们可以在我们的导航控制器中重写dismiss方法，根据presentedViewController是否为UIDocumentMenuViewController做一个标记documentFlag, 需要手动控制当第二次系统调用dismiss时候就无需回调父类的dismiss方法。123456789101112-(void) dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion&#123; if(self.presentedViewController !&#x3D; nil &amp;&amp; [self.presentedViewController isKindOfClass:[NSClassFromString(@&quot;UIDocumentMenuViewController&quot;) class]])&#123; self.documentFlag &#x3D; YES; [super dismissViewControllerAnimated:flag completion:completion]; &#125;else&#123; &#x2F;&#x2F;第二次dismiss阻止掉。 if(!self.documentFlag)&#123; [super dismissViewControllerAnimated:flag completion:completion]; &#125; self.documentFlag &#x3D; NO; &#125;&#125; 总结：问题本身不可怕，可怕的是不愿意尝试从影响该问题点去绕开该点所导致的问题。这本身也是一种解决问题的捷径方案。当产生新的问题点时候，我们只需耐心调试，步步细心，发现造成问题点的直接原因。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"2020年下半年iOS工作技术点","slug":"2020iOS","date":"2021-06-29T09:52:11.000Z","updated":"2021-06-29T09:57:07.000Z","comments":true,"path":"2021/06/29/2020iOS/","link":"","permalink":"https://www.littlewhale.xyz/2021/06/29/2020iOS/","excerpt":"2020 年下半年iOS工作技术点 tips背景：疫情原因导致之前云喵工作不能够继续，2020年6月还是面试找了一份相对稳定的工作，去了南航的一家外包供应商。 E App 是一个企业内部OA即时通讯App. 驻场南航后主要是针对此项目进行功能迭代敏捷开发。主要说一下几个技术任务点： 首要任务就是将旧有MRC内存运行环境改成ARC运行环境。 任务到不是复杂，主要修改点是多，体力劳动。将ARC相关的修饰关键词，控制器的dealloc 方法以及设置的代理delegate, 配置文件-fno-objc 相关配置干掉。遇到的问题？ 期间由于之前是MRC手动内存回收机制，由于开发人员代码某些变量没有回收或者泄露贮存在内存中，当改成ARC之后会自动释放导致再次使用该变量的时候出现nil值崩溃或者业务的中断开！C++代码块Client类某方法的变量被释放造成崩溃？ 当时问题点抛向如何停止某线程的解决方案上去了，而不是终止某条件然后让线程自然停止。当程序进入后台applicationWillTerminate的时候，手动退出IM.然后进入销毁连接阶段。为了使alive_thread , recv_thread 两线程退出,在CLIENT_Disconnect 销毁阶段，通过改变alivethread的条件让while条件中止，线程必然退出。 h5网页打卡有时候定位不到或者崩溃。因App程序使用了百度地图sdk,所以直接升级百度地图sdk即可。sdk编译分xcode11.3 或 xcode 12 。具体看E项目如果采取xcode11.3 编译打包上线，那么需要找到适应的.a包或者framework 进行编译。 将ASI网络文件下载改成AFNetwroking网络文件下载，将长进度条改成扇形进度条。ASI那套网络请求比较老旧，当时还是用NSURLConnnection来进行网络请求，而且需要单独维护一个网络线程长期贮存到内存中。AFN 采取NSURLSession来进行网络请求，线程即用即回收。AFN请求时设置支持SSL安全策略。 12345AFSecurityPolicy *securityPolicy &#x3D; [[AFSecurityPolicy alloc] init];securityPolicy &#x3D; [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];securityPolicy.allowInvalidCertificates &#x3D; YES;securityPolicy.validatesDomainName &#x3D; NO;[_manager setSecurityPolicy:securityPolicy]; 然后通过NSURLSessionDownloadTask 进行下载request,返回对应的进度，通过KVO进行进度条的UI显示,也可通过Block传递到控制器进行显示。","text":"2020 年下半年iOS工作技术点 tips背景：疫情原因导致之前云喵工作不能够继续，2020年6月还是面试找了一份相对稳定的工作，去了南航的一家外包供应商。 E App 是一个企业内部OA即时通讯App. 驻场南航后主要是针对此项目进行功能迭代敏捷开发。主要说一下几个技术任务点： 首要任务就是将旧有MRC内存运行环境改成ARC运行环境。 任务到不是复杂，主要修改点是多，体力劳动。将ARC相关的修饰关键词，控制器的dealloc 方法以及设置的代理delegate, 配置文件-fno-objc 相关配置干掉。遇到的问题？ 期间由于之前是MRC手动内存回收机制，由于开发人员代码某些变量没有回收或者泄露贮存在内存中，当改成ARC之后会自动释放导致再次使用该变量的时候出现nil值崩溃或者业务的中断开！C++代码块Client类某方法的变量被释放造成崩溃？ 当时问题点抛向如何停止某线程的解决方案上去了，而不是终止某条件然后让线程自然停止。当程序进入后台applicationWillTerminate的时候，手动退出IM.然后进入销毁连接阶段。为了使alive_thread , recv_thread 两线程退出,在CLIENT_Disconnect 销毁阶段，通过改变alivethread的条件让while条件中止，线程必然退出。 h5网页打卡有时候定位不到或者崩溃。因App程序使用了百度地图sdk,所以直接升级百度地图sdk即可。sdk编译分xcode11.3 或 xcode 12 。具体看E项目如果采取xcode11.3 编译打包上线，那么需要找到适应的.a包或者framework 进行编译。 将ASI网络文件下载改成AFNetwroking网络文件下载，将长进度条改成扇形进度条。ASI那套网络请求比较老旧，当时还是用NSURLConnnection来进行网络请求，而且需要单独维护一个网络线程长期贮存到内存中。AFN 采取NSURLSession来进行网络请求，线程即用即回收。AFN请求时设置支持SSL安全策略。 12345AFSecurityPolicy *securityPolicy &#x3D; [[AFSecurityPolicy alloc] init];securityPolicy &#x3D; [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];securityPolicy.allowInvalidCertificates &#x3D; YES;securityPolicy.validatesDomainName &#x3D; NO;[_manager setSecurityPolicy:securityPolicy]; 然后通过NSURLSessionDownloadTask 进行下载request,返回对应的进度，通过KVO进行进度条的UI显示,也可通过Block传递到控制器进行显示。 123456789101112131415161718192021222324 NSURLSessionDownloadTask *downloadTask &#x3D; [_manager downloadTaskWithRequest:request progress:^(NSProgress * _Nonnull downloadProgress) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if(progressBlock)&#123; progressBlock(downloadProgress); &#125; downloadModel.progress &#x3D; downloadProgress.fractionCompleted; &#125;);&#125; destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123; return [NSURL fileURLWithPath:downloadModel.pathName]; &#x2F;&#x2F;这里直接返回需要存储的本地沙盒路径&#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) &#123; if (error) &#123; if (failedBlock) &#123; downloadModel.progress &#x3D; 1; failedBlock(error); &#125; &#125;else&#123; if(successBlock)&#123; NSHTTPURLResponse * successRes &#x3D; (NSHTTPURLResponse *)response; successBlock(successRes,downloadModel); &#125; &#125;&#125;];[downloadTask resume];downloadModel.task &#x3D; downloadTask; 扇形视图的定义编写参考TZImagePicker图片选择器开源UI框架中的TZProgressView，后期的聊天图片预览也很大参考了TZ的图片、gif，视频混合预览控件。后期还会讲到基于TZImagePicker的图片入口进行图片编辑等功能扩展。回到扇形进度视图，我们定义了一个PieProgressView， 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#define Hollow_Circle_Radius 0 &#x2F;&#x2F;中间空心圆半径，默认为0实心#define KOffsetRadius 10 &#x2F;&#x2F;偏移距离#define KMargin 0 &#x2F;&#x2F;边缘间距@interface PieProgressView ()&#123; CGFloat _radius; CGPoint _center;&#125;@property (nonatomic, strong) CAShapeLayer *pieLayer;@end@implementation PieProgressView- (instancetype)initWithFrame:(CGRect)frame&#123; self &#x3D; [super initWithFrame:frame]; if (self) &#123; self.backgroundColor &#x3D; UIColor.clearColor; &#x2F;&#x2F;线的半径为扇形半径的一半，线宽是扇形半径-&gt;半径+线宽的一半&#x3D;真实半径，这样就能画出圆形了 _radius &#x3D; (frame.size.width - KMargin*2)&#x2F;4.f; _center &#x3D; CGPointMake(_radius*2 + KMargin, _radius*2 + KMargin); _pieLayer &#x3D; [CAShapeLayer layer]; _pieLayer.strokeStart &#x3D; 0; _pieLayer.lineWidth &#x3D; _radius*2 - Hollow_Circle_Radius; _pieLayer.strokeColor &#x3D; [[UIColor colorWithWhite:0 alpha:0.5] CGColor]; _pieLayer.fillColor &#x3D; [UIColor clearColor].CGColor; _pieLayer.strokeEnd &#x3D; 0.98; &#125; return self;&#125;#pragma mark -- Publish Methods- (void)drawRect:(CGRect)rect &#123; _radius &#x3D; (rect.size.width - KMargin*2)&#x2F;4.f; _center &#x3D; CGPointMake(_radius*2 + KMargin, _radius*2 + KMargin); _pieLayer.frame &#x3D; self.bounds; UIBezierPath *piePath &#x3D; [UIBezierPath bezierPathWithArcCenter:_center radius:_radius + Hollow_Circle_Radius startAngle:M_PI_2*3 endAngle:-M_PI_2 clockwise:false]; _pieLayer.strokeEnd &#x3D; 1.0-_progress; _pieLayer.path &#x3D; piePath.CGPath; [_pieLayer removeFromSuperlayer]; [self.layer addSublayer:_pieLayer];&#125;- (void)setProgress:(float)progress &#123; _progress &#x3D; progress; [self setNeedsDisplay];&#125;@end 设置视图进度属性的时候，通过调用setNeedsDisplay告诉系统需要进行视图渲染，系统调用drawRect方法,往self.layer添加一个pieLayer, pieLayer的path通过贝塞尔曲线进行设置，piePath相当于从画了一个圆弧度，通过strokeEnd控制结束点，需要和closewise配合控制逆时针。pieLayer需要每次移除再往里添加。在控制器列表cellFor的时候, 设置progress的起初值为0.0001很小，几乎接近0，这样在点击的时候如果去下载，则灰色透明蒙版值达到0.999接近1.0 ，给人很逼真的感觉。 12345678910111213if(_convRecord.msg_type &#x3D;&#x3D; type_file)&#123; PieProgressView *pieProgressView &#x3D; (PieProgressView *) [cell.contentView viewWithTag:pic_progress_circle_tag]; pieProgressView.superview.hidden &#x3D; NO; if(pieProgressView) &#123; if(_convRecord.download_flag &#x3D;&#x3D; state_download_success) &#123; pieProgressView.hidden &#x3D; YES; &#125;else &#123; pieProgressView.hidden &#x3D; YES; pieProgressView.alpha &#x3D; 1.0; pieProgressView.progress &#x3D; 0.0001; &#x2F;&#x2F;初始化配置进度。 &#125; &#125;&#125; 由于ui需求需显示圆扇形进度，需要将pieProgressView添加到一个背景view中，再设置其circleBackView的背景颜色为透明，layer的masksToBounds为YES,这样就可以显示我们需要的圆扇形了。 Xcode12 Runtime的方法调用。由于主工程是多个project工程相互依赖串行而成的工程，底工程需要依赖主工程类时候，可通过runtime obj_msgSend消息发送方式进行调用。 123id cls &#x3D; ((id (*) (id, SEL)) objc_msgSend)(objc_getClass(&quot;HttpTool&quot;),sel_registerName(&quot;tool&quot;));SEL sel &#x3D; sel_registerName(&quot;POST:paramDic:Success:Failure:&quot;);((void (*)(id,SEL,NSString *,NSDictionary *, id, id))objc_msgSend)(cls, sel, urlStr, dic, finishSuccessBlock,FailureBlock); 崩溃问题： 数组越界。尤其在使用tableview的beginUpdate 的时候，局部刷新操作的数据源和读取的数据源个数不一致导致。还有一种情况是在子线程中操作了该数据，导致刷新的时候和该数据源不一致导致崩溃。或者是数据源遭到污染，变相被改变。 字符串截取崩溃。 在使用字符串的方法截取range 的时候没有判断长度越界情况。 在集合copy的时候，要注意是否变化为不可变集合，否则调用类似addObject等方法时候容易崩溃。 对象释放。在使用SDWebImage下载图片的时候，如果用一个临时的imageView去下载一个图片，而这个imageView又没有被界面引用就出现对象被释放了。从而导致imageView sd_download的时候complateBlock一直没有回调。 对象关键字的使用。比如block没有使用copy, delegate没有使用weak等。 在子线程中发送了通知，然后在主线程更改了UI导致崩溃。 业务异常： 切换登录用户，导致发送消息失败或者丢失。原因：切换用户时，数据库开关不正确导致sql事务没有提交。 解决方案：首先sqllite模式为串行模式，全局App只有一个共享的句柄handle。我们把这个变量定义在LCLSqlite中设置为只读。 建立一个单例dbManager类,只负责创建数据库和关闭数据库以及数据库版本的管理。 定义BaseSqlite类.提供公共的操纵数据库sql的读写方法，子类业务DAO都继承于BaseSqlite类，子类Dao可以使用handle(只读),但不可更改handle. 在数据库sqlite关闭的时候，为防止遗留与语句池statement还在使用, 需循环拿出未处理的语句池进行关闭。这样再打开数据库就能成功。 正在某会话聊天的时候，输入文字发送后。突然杀掉进程，再次打开会话发现消息消失。解决方案：App线程干掉会走applicationWillTerminate方法，在此需要将数据库关闭。 用户登录后收到很多离线消息，如果处理消息入库的线程池开辟数量大于2，则会出现多个业务先后顺序的问题（问题场景：消息在会话页面撤销了，但未在消息列表页面撤销掉）。必须控制线程数为1，保证Operation任务依赖有序插入，如果要处理入库的效率。可将消息数据记录进行批量事务入库。 线程问题： 消息数据记录入库后，都会写一段代码来发送通知到控制器进行页面的刷新操作。当大量消息入库后发送通知时候，会造成主界面代码块如果开辟了GCD线程，会造成大量浪费和内存开辟的浪费。需要严格控制好线程的数量，可通过线程池等方面去控制。 不要一味地想当然用异步去处理耗时长的任务然后直接下一步业务操作。比如发送一段语音，需要存储到沙盒，需要上传，需要把数据记录存到数据库。存到数据库时候，我们需要存储后端服务器返回给我们的fileToken，线程的执行有先后，文件的fileToken取到的是否正确的？值得考量。或者采取Block方式当真正拿到fileToken时候才进行下一步的业务操作。 如何保证在多线程情况下的数据源安全？原子性？加同步锁？信号量？栅栏函数？ 值得你去探索? 归根结底是引用类型造成的问题，Swift Struct 值类型值得你拥有。 业务懒加载： 场景1：某消息类型为群待办或者群公告。他们重用的消息Cell可能一直，只是局部UI的不同。 cell的显示需要实时显示正确的消息类型对应的UI,这个时候可能通过查数据库拿到值后再更新UI. 但在计算cell高度的时候，无论是群待办还是群公告，它们的高度是固定的。所以无需多余的查询，只需load数据源的时候提前一次查询即可。 当涉及到对象的copy的时候，尤其是当对象里某属性重写了get又去查询数据库的时候，性能损耗较大，在copyWithZone的方法里赋值的时候可根据情况将self.propA 改成_propA 这样就不会触发耗时的查询。 在消息首页不断地查询计算总得未读数的时候，我们可以控制当消息数99+的时候，终止没必要的查询机制。当在收到通知需要查询未读数业务时候可控制专门的线程去查询该未读数。 为了减少通知之后的刷新率，我们可以在消息入库之后发出通知之前，用一个中转器相当于一个定时时间内去检查有记录则即通知刷新一次（带参将消息数据发出去）。 性能问题： 大部分性能损耗其实还是发生在主线程进行IO读取上，应该尽量去控制IO的读取频次，以及根据业务情况按实际需要它放在子线程中处理，再通过Block形式去返回。而block形式会给编写的代码造成block嵌套，尤其是层次多的时候，给阅读上造成一定的干扰。所以应该控制嵌套层次数，两者结合。业界也有coobjc协程解决方案。或者参考PromiseKit 类似前端web的promise方案。 Sqlite串行模式下数据库读写在大量离线消息收到时候比较容易出现卡顿的问题，因为所触发的读和写都是穿插排队。并不能很好地实现读写并发。在此基础上，我们应该控制大量数据写的时候尽量剥离出冗合的业务，将数据批量事务入库，这样在性能上也不至于那么卡。当然此方案也需要后台配合，看后台服务器是一条条下发给客户端还是批量多条下发给客户端。 当在群会话发送一条消息的时候，本地有一张数据已读回执表记录着消息id, 用户id,阅读状态，创建时间，阅读时间等。首先需要将群里所有人批量入库初始为未阅读状态。当有收到回执消息时，即更新对应的阅读状态。这样给此表造成数据量的庞大和臃肿。解决方案：可根据时间戳删除一个月之前的废记录。在创建表的时候，可根据一个群一个回执记录表。这样有利于消息的多表连接与快速查询。 当有大量数据在内存中排序的时候，如果能从数据库中排序尽量通过sql排序，效率远远大于内存排序。 如果服务器是一条条离线消息下发，可根据消息的类型属于聊天消息专门通过一个队列来维护，后台线程getMessage循环去取的时候，一次就可以拿多个进行批量入库。 关于IM App 消息存储问题：目前是所有消息都存储在本地客户端。虽然节省了服务器资源，如果不批量下发，客户端性能上处理可能有点问题。可能会有轻微卡顿，如果量大，那就很明显了。虽然进入会话都是从本地拉数据，查询数据也都是本地进行搜索，比较全。但是如果后期要做多端数据同步[漫游]。那其实服务器还是要存储一定时间段的用户聊天消息的。网上查了很多资料，还有一种做法是这样：用户每次登录后，IM服务端会下发每个会话的近50条消息，10个会话也才500条，其实数据量很小了。当用户点击某会话时候，先显示最近的消息，当往上翻页的时候，本地数据库如果有则本地加载出来，如果没有则请求网络进行拉数据。这样推拉结合能减轻客户端很多问题。客户端根据需要进行消息存储。 接下来将会写一些功能点上的技术心得：[图片编辑：涂鸦，裁剪，文字帖，马赛克][聊天图片浏览：图片，gif，视频][消息收藏][YYTextView富文本部分文字光标选择][正则匹配解决群内邀请新成员点击问题][奇怪的侧边栏问题][@某人在文字前中后的处理规则][群插件如何开发？][数据源的线程安全][图片的转发]","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"Office English Tips","slug":"OfficeEnglishTips","date":"2021-06-25T09:01:10.000Z","updated":"2021-07-20T03:39:45.975Z","comments":true,"path":"2021/06/25/OfficeEnglishTips/","link":"","permalink":"https://www.littlewhale.xyz/2021/06/25/OfficeEnglishTips/","excerpt":"","text":"Talk over someone by accident(当不小心打断别人时)：Sorry I interrupted, you were saying … ?Sorry go ahead/ go on. useful expressions for video conference（视频会议一些非常有用的表达）：Identify yourself （表明身份）Gaoying speaking, can we have a break? Did not hear clearly （听不太清晰时）Can you speak up a little bit?Can you say it again ?Sorry I did’t get that? what did you say? How to interrupt （如何打断插话）Would you mind if I jump in here please ?Can I stop you for just one second please? Leave for a moment （临时离开）I will be back later.I am gonna step away for a few minutes. Deal with technical issues （网络不畅通）My internet is a bit slow.Can you move closer to the router?Sorry I am late, I had hard time in connecting.I am having problems with my connection. Try to adjust your output settings (调整外接设备)It sounds like you have echoes.Gaoying, are you still with us?Sorry my mic was off. / you are muted. Is your microphone on mute?Gaoying is cutting off. Office Tipstalk to you later.Sure, OK, Yes, No problem. Exactly, Absolutely, Of course, Correct.No, Not yet. Not now. I don’t think So. I Have different opinion; I might disagree with you. Leave ApplicationDear Manager, I would like to apply for a three-day leave, starting from the 13th and finishing on 15th, in orderto return home to fix something.I should be very much obliged if you will grant me the leave.Gaoying. Job ReportDear XX:I am writing to report my work progress of this week. The details of XXX project are as follows：1…2…I may need your help for below 2 aspects:1….Above all are all my work items during this week, if you have time ,I would like to have a private talk with you for more detials。If any queries, please contact me. thank you. Email Ask QuestionI wanted to follow up on or meeting last week and confirm our plans for this month.I would like to ask about the budget and whether this will affect our department.Do you know when the database issues will be fixed ?Let’s confirm our plans for this month.How will the new budget affect our department?I’m concerned about the number of sick days staff have been talking recently.I suggest that you contact all clients who may have been affected by the data breach.Can I ask you to design a poster to inform staff about the new policies?","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"这两个月学的前端知识","slug":"webSummary","date":"2020-04-25T02:25:11.000Z","updated":"2021-06-29T09:59:17.000Z","comments":true,"path":"2020/04/25/webSummary/","link":"","permalink":"https://www.littlewhale.xyz/2020/04/25/webSummary/","excerpt":"","text":"框架方面目前主要掌握 Vue 。可独立开发 H5 项目，PC Web 后台系统, 小程序开发。 UI 框架：用过 element-UI, iView, WeUI, WeUIJs. MiniUI 第三方插件：使用过 Moment 日期处理,Echart 图表统计, VueDraggable 拖动。 网络请求：Axios 图片上传: Weui-Uploader, Blob 或 base64 上传. IM: 使用过网易云信。 移动 App: 用 Swift 开发过 iOS 项目,Sass 应用。(云喵) 熟悉 Webpack, Sass, NodeJs, vue-Cli, Router, VueX. 个人 Github Page 演示","categories":[{"name":"Web","slug":"Web","permalink":"https://www.littlewhale.xyz/categories/Web/"}],"tags":[]},{"title":"快速搭建前端网络请求","slug":"webBegain","date":"2020-02-06T06:05:04.000Z","updated":"2020-05-27T00:53:54.000Z","comments":true,"path":"2020/02/06/webBegain/","link":"","permalink":"https://www.littlewhale.xyz/2020/02/06/webBegain/","excerpt":"HTTP超文本传输协议。TCP 三次握手。 1、客户端 发syn询问 给 服务器 2、服务器 回应询问syn,并发送一个指令ack 客户端 3、客户端 回 ack 服务器。 正式连接成功。 开始客户端请求Http报文 ，服务器响应报文。","text":"HTTP超文本传输协议。TCP 三次握手。 1、客户端 发syn询问 给 服务器 2、服务器 回应询问syn,并发送一个指令ack 客户端 3、客户端 回 ack 服务器。 正式连接成功。 开始客户端请求Http报文 ，服务器响应报文。 四次挥手过程 发送一个请求查询用户日志记录请求123456789101112131415:method: POST:scheme: https:authority: vendor-api-prod.gaoying.com:path: &#x2F;customer&#x2F;logs&#x2F;Accept: application&#x2F;json, text&#x2F;plain, *&#x2F;*Content-Type: application&#x2F;x-www-form-urlencoded &#x2F;&#x2F;表单提交方式Origin: http:&#x2F;&#x2F;h5-vendor-dev.gaoying.comContent-Length: 236Accept-Language: zh-cnHost: vendor-api-dev.gaoying.comUser-Agent: Mozilla&#x2F;5.0 (iPhone; CPU iPhone OS 13_3 like Mac OS X) AppleWebKit&#x2F;605.1.15 (KHTML, like Gecko) Mobile&#x2F;15E148Referer: http:&#x2F;&#x2F;h5-vendor-dev.gaoying.com&#x2F;page&#x2F;customerMain.html?customerId&#x3D;172821&amp;userId&#x3D;15243265&amp;token&#x3D;41cadcb70eed35378a92379871a51181Accept-Encoding: gzip, deflate, brConnection: keep-alive 响应12345status: 200Access-Control-Allow-Origin: *Content-Type: application&#x2F;json;charset&#x3D;UTF-8 &#x2F;&#x2F;json响应格式Date: Fri, 27 Dec 2019 05:58:18 GMTServer: Tengine 请求方式有哪些？1234567891011121314METHODS: [ 'ACL', 'BIND', 'CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LINK', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCALENDAR', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REBIND', 'REPORT', 'SEARCH', 'SOURCE', 'SUBSCRIBE', 'TRACE', 'UNBIND', 'UNLINK', 'UNLOCK', 'UNSUBSCRIBE' ] 响应码有哪些？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465STATUS_CODES: &#123; '100': 'Continue', '101': 'Switching Protocols', '102': 'Processing', '103': 'Early Hints', '200': 'OK', '201': 'Created', '202': 'Accepted', '203': 'Non-Authoritative Information', '204': 'No Content', '205': 'Reset Content', '206': 'Partial Content', '207': 'Multi-Status', '208': 'Already Reported', '226': 'IM Used', '300': 'Multiple Choices', '301': 'Moved Permanently', '302': 'Found', '303': 'See Other', '304': 'Not Modified', '305': 'Use Proxy', '307': 'Temporary Redirect', '308': 'Permanent Redirect', '400': 'Bad Request', '401': 'Unauthorized', '402': 'Payment Required', '403': 'Forbidden', '404': 'Not Found', '405': 'Method Not Allowed', '406': 'Not Acceptable', '407': 'Proxy Authentication Required', '408': 'Request Timeout', '409': 'Conflict', '410': 'Gone', '411': 'Length Required', '412': 'Precondition Failed', '413': 'Payload Too Large', '414': 'URI Too Long', '415': 'Unsupported Media Type', '416': 'Range Not Satisfiable', '417': 'Expectation Failed', '418': \"I'm a Teapot\", '421': 'Misdirected Request', '422': 'Unprocessable Entity', '423': 'Locked', '424': 'Failed Dependency', '425': 'Unordered Collection', '426': 'Upgrade Required', '428': 'Precondition Required', '429': 'Too Many Requests', '431': 'Request Header Fields Too Large', '451': 'Unavailable For Legal Reasons', '500': 'Internal Server Error', '501': 'Not Implemented', '502': 'Bad Gateway', '503': 'Service Unavailable', '504': 'Gateway Timeout', '505': 'HTTP Version Not Supported', '506': 'Variant Also Negotiates', '507': 'Insufficient Storage', '508': 'Loop Detected', '509': 'Bandwidth Limit Exceeded', '510': 'Not Extended', '511': 'Network Authentication Required'&#125; 客户端请求后，服务器响应携带的https证书HTTPS:在HTTP与TCP之间 加入SSL层，一个加密/身份验证层，用于安全的HTTP数据传输。 它是一个URI scheme（抽象标识符体系）。SSL : 安全套接层 ， 在网络传输层基础上对网络连接进行数据加密； 具有校验机制，配备身份证书。客户端利用公钥对数据加密，服务端收到加密数据后 对数据进行解密； Https 服务器端口是443, Https 公共密钥采用 RSA算法加密， 证书信息将在请求响应之前回复给客户端。客户端根据证书信息 本地做一个安全校验，通过后再允许服务端响应返回数据，否则取消本次请求响应。签名算法：SHA-256 ECDSA 常用加密算法对称加密 单向散列函数MD5 是一种 不可逆的信息摘要算法，严格来说不是加密。单向散列函数是一种不可逆的信息摘要算法，无法通过密文还原成明文（注意：是算法上不能实现），对于简单的 MD5 加密（这里的简单是指：明文长度短，且字符单一，并且进行 HASH 操作的时候没有进行加盐处理），是可以通过一些在线工具网站解密出来，实则是利用了彩虹表的技术。 AES 加密 加密原理： 字节代换，行位移，列混合：（矩阵相乘：状态矩阵 和 固定矩阵相乘） ，轮钥加密：轮钥加密是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作 DES 加密 非对称加密 RSA 加密 快速搭建Vue 普通h5项目页面的网络请求在学习请求之前，需要掌握好Javascript语言。最基础的知识首先要了解和掌握变量修饰符，Function 和 Object对象。 js 变量修饰符let 是局部变量，非常适合循环的时候；const 是只读变量， 初始化的时候就要赋值；只能赋值一次；var 是全局变量，全局都可以用。 函数 Function 从上图我们看到有个名为open的函数，包含参数，调用者，长度，名字，以及 Proto 对象。该对象里面有 apply ,bind, call 函数。还有一个contructor构造器。 Function属性： length,name,prototype Function方法: Function.prototype.apply(), //调用一个函数并将其设置为提供的值。 可以将参数作为Array对象传递 Function.prototype.bind(), //创建一个新函数，该新函数在调用时将其设置为提供的值，并在调用新函数时在提供的任何参数之前添加给定的参数序列。 Function.prototype.call(), //调用一个函数并将其设置为提供的值。 可以按原样传递参数。 Function.prototype.toString() //返回表示函数源代码的字符串。 //题外话，apply 和 bind 增强代码的扩展性，类似iOS 的category;①动态改变this的指向，也就是this从callObject动态切换为thisArg。②callObject.method.apply(thisArg,thisArray)，可以将thisArray转化为arguments，传入到callObject.method内部。我们通过以下代码来测试bind 的用法： 12345678910111213//程序员的黄金年龄 18 ~ 35var checkProgramerAgeRange = function (value) &#123; if (typeof value !== 'number') return false; else return value &gt;= this.minimum &amp;&amp; value &lt;= this.maximum;&#125;let programmerRange = &#123; minimum: 18, maximum: 35 &#125;;// 把函数内部的this修改为range对象，let boundCheckProgramerAgeRange = checkProgramerAgeRange.bind(programmerRange);console.log(boundCheckProgramerAgeRange(12)); Object 对象Object 继承Function, 扩展了自己的许多方法。 Object 的属性构造器 Object.prototype Object.assign() 将所有可枚举的自身属性的值从一个或多个源对象复制到目标对象。 Object.create() 用指定的原型对象和属性创建一个新对象。 Object.defineProperty() 定义一个property给指定对象 Object.defineProperties() 定义一个属性 给指定对象 Object.entries() 返回一个装有map的数组。 Object.getOwnPropertyNames() 得到这个对象自己的属性名 Object.getPrototypeOf() 得到指定类型的属性 Object.is() 比较对象 Object.keys() 字符窜属性 Object.values() 12345678910111213141516171819202122232425262728293031let stuObj = &#123;room:\"english\"&#125;;Object.defineProperties(stuObj,&#123; stuName:&#123; value:\"qiugaoying\", writable:true /* configurable, enumerable, value, writable, get, set */ &#125;, age: &#123; value:18, writable:true &#125;&#125;)//可直接覆盖某对象的属性；Object.defineProperty(stuObj,\"stuName\",&#123; value:\"gaogao\", writable: true&#125;)stuObj.age = 20;console.log(stuObj.stuName); //gaogaoconsole.log(stuObj.age); //20console.log(Object.keys(stuObj)); //room 取得公共属性console.log(Object.values(stuObj)); //room 取得公共属性值console.log(Object.getOwnPropertyNames(stuObj)); //room,age,stuName 取得对象所有属性console.log(Object.getOwnPropertyDescriptors(stuObj)); //获取属性描述器console.log(stuObj[\"stuName\"]); //gaogao 对象的定义传统方式定义一个对象12345678910function Person(name,age)&#123; this.name = name; this.age = age;&#125;//通过函数的prototype公共空间存储方法Person.prototype.introduce = function()&#123; console.log(\"hello,my name is \"+this.name);&#125;new Person().introduce(); Class方式定义一个对象1234567891011class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; introduce()&#123; console.log(\"我的名字是：\"+this.name); &#125;&#125; 类的本质是对象，对象继承Function; 所以introduce方法还是存储在prototype 公共空间中。操作类函数也可通过Person.prototype 去动态新增新的方法。另外要注意一点类的所有实列共享原型的prototype。123let student = new Person(\"qiugaoying\",18);let student2 = new Person(\"lihua\",22); console.log(student.__proto__ == student2.__proto__); //结果为true。 类的所有实列共享原型的prototype Ajax 请求通常，发起一个请求，需要传入基础参数，业务url, 业务参数，设置请求头，和响应方式。 接着对响应成功和失败的处理；前端通常的请求方式有 表单提交，Ajax异步请求，Jquery也提供了ajax封装的快捷api。另外也有较新的框架Axios。 ajax 的出现是解决局部数据刷新的问题。可通过后台异步调用接口 实现页面局部刷新。浏览器原生有个XMLHttpRequest对象。jQuery 出来之后，ajax的调用简化了好多 1234567891011121314$ajax(&#123; type: 'POST', dataType: 'json', //服务端返回的数据类型 contentType: 'application/json' ,//参数类型 url : \"http://127.0.0.1/log/list/\", headers:&#123;'Content-Type':'application/json'&#125;,//请求头, 内容编码类型 默认 \"application/x-www-form-urlencoded\" data: JSON.stringify(&#123;\"name\":\"qiugaoying\"&#125;), //传参 success: function(result,status,xhr)&#123; console.log(result); //获取结果 &#125;, error: function (xhr,status,error)&#123; console.log(error); &#125;&#125;); Axios 框架Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中. 我们来观察一下 在axios 的api 方法。 从图可以看出，有个默认属性中有个xmlHttpRequet网络适配器。 可设置基础baseURL , 以及请求头，请求超时等一些基础设置。 转换请求数据和响应数据，支持防御 XSRF。 提供了常用的get,post 等请求。自动转换 JSON 数据。还提供请求和响应的拦截器。 script标签引入axios 的js1234567891011121314&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt;//构建一个axios实列只读变量，设置基础urlconst http = axios.create(&#123; baseURL: 'https://vendor-api-prod.qiugaoying.com', timeout: 1000, transformRequest: [function(data) &#123; // Do whatever you want to transform the data let ret = '' for (let it in data) &#123; ret += encodeURIComponent(it) + '=' + encodeURIComponent(data[it]) + '&amp;' &#125; return ret &#125;]&#125;); 封装基础参数，排序 加密等对请求的基础参数做一个封装。 大部分请求都需要带上一些基础参数和userId,token 等字段。最后对所有字段key排序,最后转成Json 字符串再加密。以下为示例： 123456789101112131415161718192021222324252627282930313233343536373839const netManager = &#123; getRequestParams: function(params) &#123; let userId = localStorage.getItem(\"userId\"); let token = localStorage.getItem(\"token\"); // var userInfo = JSON.parse(userInfoStr); var obj = Object.assign(params, &#123; api_version: 1, //接口版本 platform: 2, //平台类型 terminal: 1, //终端类型 nonce: (Math.random().toFixed(8) + '').replace('0.', ''), //随机数; timestamp: new Date().getTime(), //当前时间戳 毫秒 user_id:123, //userId token: \"ec29c3af0dd998yjhgd22f9y867ws6512\", //token version_code: 100 //当前版本号 &#125;); let sign = MD5(this.strKeySort(obj)).toUpperCase(); //md5加密 obj[\"Sign\"] = sign; return obj; &#125;, //key排序 strKeySort: function(obj) &#123; const newkey = Object.keys(obj).sort(); const newArr = []; for (let i = 0; i &lt; newkey.length; i++) &#123; if (obj[newkey[i]] === 'undefined' || obj[newkey[i]] === 'null') &#123; obj[newkey[i]] = ''; &#125; newArr.push(`$&#123;newkey[i]&#125;=$&#123;obj[newkey[i]]&#125;`) &#125; const newStr = newArr.join('&amp;') + '&amp;secret_key=gaoyingAESKey'; return newStr; &#125;, //获取url 后面带的参数; getUrlKey: function (name) &#123; return decodeURIComponent((new RegExp('[?|&amp;]' + name + '=' + '([^&amp;;]+?)(&amp;|#|;|$)').exec(location.href) || [, \"\"])[1].replace(/\\+/g, '%20')) || null &#125;&#125; axios实列发起一个请求示例这里拿请求用户个人主页基础信息为样例，把下面方法放入 Vue 的 methods 中。 加载loading用到的是weiui.js.以下可以实现一个分页加载的请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var vm = new Vue(&#123; el: '#PageContainer1', data: &#123; //分页数据 pageNumber: 1, pageSize: 10, gyPageListStart: 0, hasMoreDataFlag: false, dataSource: [], &#125;, methods: &#123; execBaseCustomerRequest: function(url, listKey) &#123; var loading = null; if (this.pageNumber == 1) &#123; loading = weui.loading('加载中'); &#125; let pageVue = this; //this在不同的作用域中指向的对象不同；临时存储vue对象 if (this.pageNumber == 1) &#123; this.gyPageListStart = 0; &#125; http.post(url, netManager.getRequestParams(&#123; customer_id: this.customerId, start: this.gyPageListStart, size: 10, &#125;)).then(function(response) &#123; if (loading) &#123; loading.hide(); &#125; let dataDic = response.data; if (dataDic.status == 1) &#123; var arr = pageVue.dataSource; if (pageVue.pageNumber == 1) &#123; arr = []; &#125; var dataArr = dataDic.data[listKey]; arr = arr.concat(dataArr); pageVue.gyPageListStart = dataDic.data.start; vm.$data.hasMoreDataFlag = (dataDic.data.more == 1); vm.$data.dataSource = arr; &#125; setTimeout(function() &#123; pageVue.requestLoadingFinished = true; &#125;, 800); //重置加载完成的状态； &#125;).catch(function(error) &#123; console.log(error); &#125;); &#125; &#125;&#125;);其他： url 通常会放到一个全局文件中配置1234567const gaoyingAPI = &#123; customerList: \"/customer/list/\", customerLogs: \"/customer/logs/\", customerCoupons: \"/customer/coupons/\", customerOrders: \"/customer/orders/\", customerDetail: \"/customer/detail/\"&#125; Promise 用法简要讲解从上文中，我们看到http发送post 方法请求之后，通过promise语法 then的回调监听响应结果，通过catch方法 来捕捉异常错误处理。ES6 就支持了Promise的用法。Promise中文为承诺。有三种状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)。 即状态一旦更改就不能再次改变赋值。这也是承诺的意义。Promise实列通过.then方法或者.catch方法 返回一个新的Promise实例来实现链式调用。.then方法可以返回普通值或者一个新的promise。不设置返回值时，默认返回null。Promise有很多用法，但什么情况下需要用到Promise呢？ 在需要处理异步耗时任务的时候，可用Promise包装后进行返回。Promise用的时候会遇到很多种情况，Promise也提供了对应的解决方法。 当Promise.then方法返回一个新的Promise时候，下一级的then 将在 新的Promise then 执行 之后执行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Promise then 嵌套 方式一new Promise(resolve =&gt; &#123; console.log(\"step1:异步请求处理耗时任务\"); setTimeout(() =&gt; &#123; resolve(\"qiu\"); &#125;, 1000);&#125;).then(value =&gt; &#123; //第一个接口请求成功拿到qiu console.log(\"step1-result:\" + value); return new Promise(resolve =&gt; &#123; console.log(\"step2-1:异步请求处理耗时任务2\"); setTimeout(() =&gt; &#123; resolve(\"qiugao\"); &#125;, 1000); //触发第二个接口请求 &#125;).then(value =&gt; &#123; //第二个接口请求成功，拿到id2 做第一件事情。 console.log(\"step2-1-result-event1:\" + value); return \"qiugaoying\"; &#125;).then(value =&gt; &#123; //第二个接口请求成功，拿到id2 做第二件事情。 console.log(\"step2-1-result-event2:\" + value); return \"hello, my name is qiugaoying\"; &#125;);&#125;).then(value =&gt; &#123; //最后全部请求完成，触发汇总刷新。 console.log(\"step1-result:\" + value);&#125;);/*console输出结果:step1:异步请求处理耗时任务step1-result:qiustep2-1:异步请求处理耗时任务2step2-1-result-event1:qiugaostep2-1-result-event2:qiugaoyingstep1-result:hello, my name is qiugaoying*///Promise then 嵌套，方式二： 把then移到同一级展开。执行打印结果是一样的。new Promise(resolve =&gt; &#123; console.log(\"step1:异步请求处理耗时任务\"); setTimeout(() =&gt; &#123; resolve(\"qiu\"); &#125;, 1000);&#125;).then(value =&gt; &#123; //第一个接口请求成功拿到qiu console.log(\"step1-result:\" + value); return new Promise(resolve =&gt; &#123; console.log(\"step2-1:异步请求处理耗时任务\"); setTimeout(() =&gt; &#123; resolve(\"qiugao\"); &#125;, 1000); //触发第二个接口请求 &#125;);&#125;).then(value =&gt; &#123; //第二个接口请求成功，拿到id2 做第一件事情。 console.log(\"step2-1-result-event1:\" + value); return \"qiugaoying\";&#125;).then(value =&gt; &#123; //第二个接口请求成功，拿到id2 做第二件事情。 console.log(\"step2-1-result-event2:\" + value); return \"hello, my name is qiugaoying\";&#125;).then(value =&gt; &#123; //最后全部请求完成，触发汇总刷新。 console.log(\"step1-result:\" + value);&#125;); then 方法提供两个参数，第二个参数可选。一个是名为resolve的成功回调 和 另一个名为reject 的失败回调。通常处理一个失败回调我们会用catch方法去捕捉异常和失败。1234567891011121314151617181920212223242526272829303132333435363738394041new Promise(resolve =&gt; &#123; console.log(\"step1:异步请求处理耗时任务\"); setTimeout(() =&gt; &#123; resolve(\"qiu\"); &#125;, 1000);&#125;).then(value =&gt; &#123; //第一个接口请求成功拿到qiu console.log(\"step1-result:\" + value); return new Promise(resolve =&gt; &#123; console.log(\"step2-1:异步请求处理耗时任务\"); setTimeout(() =&gt; &#123; resolve(\"qiugao\"); &#125;, 1000); //触发第二个接口请求 &#125;);&#125;).then(value =&gt; &#123; //第二个接口请求成功，拿到id2 做第一件事情。 let hasError = true if (hasError) &#123; throw new Error(\"step2-1-result-event1-error报异常\"); //抛出异常 将不再继续执行then, 直接到catch异常；中途如果没有遇到catch 将直接到最后的catch. &#125; else &#123; console.log(\"step2-1-result-event1:\" + value); return \"qiugaoying\"; &#125;&#125;)/*.catch(err =&gt; &#123; console.log(\"中途catchError会继续往下走:\" + err); return \"qiugaoying\" //也会返回一个promise实例，并且是resolved状态，不会被最后一个catch 捕捉&#125;)*/.then(value =&gt; &#123; //第二个接口请求成功，拿到id2 做第二件事情。 console.log(\"step2-1-result-event2:\" + value); return \"hello, my name is \"+value;&#125;).then(value =&gt; &#123; //最后全部请求完成，触发汇总刷新。 console.log(\"step1-result:\" + value);&#125;).catch(error =&gt; &#123; console.log(\"end error:\" + error);&#125;); finally 方法是最终执行的方法（无参） ，无论状态是什么，成功 or 失败 都会执行收尾。 Promise 还提供all 方法(接收一个数组，里面值可以是普通函数，或者Promise对象)，可用来做一个类似批量处理之后汇总的业务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 testPromiseAll() &#123; function washFood()&#123; console.log('做饭第一步：洗菜'); let hasError = false; if(hasError)&#123; return \"发现了一只虫子！洗掉它。\"; &#125;else&#123; return '菜洗干净了。'; &#125; &#125; function cutFood() &#123; console.log('做饭第二步：切菜'); var p = new Promise(function (resolve, reject) &#123; //做一些异步操作 setTimeout(function () &#123; let cutFoodHasError = true; //控制默契切菜时 是否发生异常 if(cutFoodHasError)&#123; reject(\"呜呜~ 割到手了，流血！\") &#125;else&#123; resolve('切好了菜。'); &#125; &#125;, 1000); &#125;) /* 试试打开这里的注释 .catch(error=&gt;&#123; console.log(\"切菜异常:\"+error); //异常本身就是返回resolve状态，值是null console.log(\"用创口贴止血，继续做菜。\"); &#125;); */ return p; &#125; function cooking() &#123; console.log('做饭第三步：炒菜'); var p = new Promise(function (resolve, reject) &#123; //做一些异步操作 setTimeout(function () &#123; resolve('菜已做好!'); &#125;, 2000); &#125;); return p; &#125; //数组里，如果放Promise 一定要返回状态。 Promise.all([washFood(), cutFood(),cooking()]) .then((result) =&gt; &#123; console.log('上桌，吃饭了：'+result); console.log(result); &#125;).catch(error=&gt;&#123; console.log(\"菜没做成，出现了小事故:\"+error); &#125;) /* 结果： 1. 当cutFoodHasError = true；打印如下结果： 菜没做成，出现了小事故:呜呜~ 割到手了，流血！ 2. 当cutFoodHasError = true 且 cutFood方法里的Promise有异常捕捉时： 切菜异常:呜呜~ 割到手了，流血！ 上桌，吃饭了：菜洗干净了！,,菜已做好 3. 当cutFoodHasError = false 上桌，吃饭了：菜洗好了。切好了菜。菜已做好！ */ /* Promise.all使用总结： 数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态改变 当所有的子Promise都完成，该Promise完成，返回值是全部值得数组 有任何一个失败，该Promise失败，返回值是第一个先失败的子Promise结果 */&#125;, Promise 另外一个race 方法与all 不同的是，race 类似竞赛，参数中的Promise实例只要有一个率先改变状态就会触发结果。 123456789101112131415161718192021222324252627282930//打印结果： 兔子赢了testPromiseRace() &#123; function rabbit() &#123; console.log('兔子选手'); var p = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve('兔子赢了'); &#125;, 1000); &#125;) .catch(error=&gt;&#123; console.log(\"兔子跑步中出现异常:\"+error); &#125;); return p; &#125; function tortoise() &#123; console.log('乌龟选手'); var p = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve('乌龟赢了'); &#125;, 3000); &#125;); return p; &#125; Promise.race([rabbit(),tortoise()]) .then((result) =&gt; &#123; console.log(\"比赛结果:\"+result); &#125;)&#125; Vue Cli 脚手架项目请求模块的搭建在vue的基础上，我们可以通过vue cli来管理我们的项目。vue cli 方式的优势在于模块之间可以很好地相互引用，通过package 包来管理配置相关的框架依赖。生态非常丰富，可轻松运用vue-router 来解决路由跳转等问题。首先第一步是要创建一个 vue cli项目。 基础安装环境123npm install -g @vue&#x2F;clivue create helloworld 方式创建项目也可以 使用GUI vue ui 来通过网页 手动点击按钮操作 来创建项目 package.json 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; \"name\": \"gaoying-cli\", \"version\": \"0.1.0\", \"private\": true, \"scripts\": &#123; \"serve\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\", \"lint\": \"vue-cli-service lint\" &#125;, \"dependencies\": &#123; \"animate.css\": \"^3.7.2\", \"core-js\": \"^3.4.3\", \"vue\": \"^2.6.10\", \"vue-axios\": \"^2.1.5\", \"vue-router\": \"^3.1.3\", \"vuex\": \"^3.1.2\", \"weui.js\": \"^1.2.1\" &#125;, \"devDependencies\": &#123; \"@vue/cli-plugin-babel\": \"^4.1.0\", \"@vue/cli-plugin-router\": \"^4.1.1\", \"@vue/cli-plugin-vuex\": \"^4.1.1\", \"@vue/cli-service\": \"^4.1.0\", \"axios\": \"^0.19.0\", \"vue-template-compiler\": \"^2.6.10\", \"weui\": \"^2.1.3\" &#125;, \"eslintConfig\": &#123; \"root\": true, \"env\": &#123; \"node\": true &#125;, \"extends\": [ \"plugin:vue/essential\", \"eslint:recommended\" ], \"parserOptions\": &#123; \"parser\": \"babel-eslint\" &#125; &#125;, \"browserslist\": [ \"&gt; 1%\", \"last 2 versions\" ]&#125; 配置main.js1234567891011121314151617181920212223242526272829303132333435363738394041import Vue from 'vue'import App from './App.vue'import router from './router'import store from './store'import axios from 'axios' //请求网络import VueAxios from 'vue-axios' import weui from 'weui.js' //weuiJsimport 'weui' //weui样式import ymAPI from '@/assets/js/urlConfig.js' //Apiimport netManager from '@/assets/js/netManager.js' //请求基础参数拼接import ymNativeBridge from '@/assets/js/ymNativeBridge.js' //原生事件交互import animate from 'animate.css' const ymHttp = axios.create(&#123; baseURL: 'https://vendor-api-prod.gaoying.com', timeout: 1000, transformRequest: [function(data) &#123; // Do whatever you want to transform the data let ret = '' for (let it in data) &#123; ret += encodeURIComponent(it) + '=' + encodeURIComponent(data[it]) + '&amp;' &#125; return ret &#125;]&#125;);Vue.config.productionTip = falseVue.prototype.$weui = weuiVue.prototype.$ymAPI = ymAPIVue.prototype.$netManager = netManagerVue.prototype.$ymNativeBridge = ymNativeBridgeVue.use(VueAxios, ymHttp,animate)new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount('#app'); 请求Demo示例//和普通h5 请求网络类似，唯一不同的就是通过挂载到Vue上的axios ，可以通过this.$http 取得。this.$netManager 也类似。1234567891011121314151617181920212223242526272829303132333435363738394041424344execBaseCustomerRequest: function(url, listKey) &#123; var loading = null; if (this.pageNumber == 1) &#123; loading = this.$weui.loading('加载中'); this.gyPageListStart = 0; &#125; let pageVue = this; //this在不同的作用域中指向的对象不同；临时存储vue对象 this.$http.post(url, this.$netManager.getRequestParams(&#123; customer_id: this.customerId, start: this.gyPageListStart, size: 10, &#125;)).then(function(response) &#123; if (loading) &#123; loading.hide(); &#125; let dataDic = response.data; if (dataDic.status == 1) &#123; var arr = pageVue.dataSource; if (pageVue.pageNumber == 1) &#123; arr = []; &#125; var dataArr = dataDic.data[listKey]; arr = arr.concat(dataArr); pageVue.gyPageListStart = dataDic.data.start; pageVue.hasMoreDataFlag = (dataDic.data.more == 1); pageVue.dataSource = arr; &#125;else&#123; pageVue.$weui.topTips(dataDic.errorMsg); &#125; setTimeout(function() &#123; pageVue.requestLoadingFinished = true; &#125;, 800); //重置加载完成的状态； &#125;).catch(function(error) &#123; console.log(error); &#125;);&#125; 模块之间的引用和导出1234567891011121314151617181920212223242526import MD5 from './md5.js'export default &#123; getRequestParams: function(params) &#123; let userId = localStorage.getItem(\"userId\"); let token = localStorage.getItem(\"token\"); ...... &#125;&#125;//md5.js 文件中 var MD5 = function (string) &#123; ......&#125;module.exports = MD5//接口配置urlConfig.js 文件中const ymAPI = &#123; //客户信息 customerList: \"/customer/list/\", customerLogs: \"/customer/logs/\", customerCoupons: \"/customer/coupons/\", customerOrders: \"/customer/orders/\", customerDetail: \"/customer/detail/\"&#125;module.exports = ymAPI export 在js文件中可以有多个.12345678//testExport.jsexport const person = &#123; name: \"qiugaoying\",sex:1, job:\"software Programmer\"&#125;export const addressInfo = &#123;province:\"广东省\", city:\"guangzhou\"&#125;export const introduct = function()&#123; console.log(\"my name is qiugaoying\");&#125;export 有多个的时候 ，导入必须用花括号括起来.12import &#123;person,addressInfo&#125; from \"../../utils/testExport.js\"import * as allExp from \"../../utils/testExport.js\" //加载全部export,取个别名 总结 export default 只能导出一个对象。import 和 export 同一js文件中可以导入或导出多次。 module.exports 和 exports 都是 node 端在用，两者指向同一内存块，可以导出变量 或 函数，对象。 exports 变量是在模块的文件级作用域内可用的，且在模块执行之前赋值给 module.exports。 H5 和 App 原生交互1234567891011121314151617181920212223242526272829303132333435363738394041//原生调用appexport default &#123; callApp:function(handlerMethod, parameters) &#123; if (!window.WeixinJSBridge || !WeixinJSBridge.invoke) &#123; var handlerInterface = 'YunMiaoNative'; var dic = &#123; 'handlerInterface': handlerInterface, 'function': handlerMethod, //调用原生的指令 'parameters': parameters //传递的参数； &#125;; if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) &#123; window.webkit.messageHandlers[handlerInterface].postMessage(dic); &#125; else &#123; //安卓 app.ymAppWebClick(); //dic &#125; &#125; else &#123; //包含微信功能，比如可唤起小程序。 &#125; &#125;, //原生调用app 并传递参数给H5 callbackH5: function(handlerMethod, parameters, callbackMethod) &#123; if (!window.WeixinJSBridge || !WeixinJSBridge.invoke) &#123; var handlerInterface = 'YunMiaoH5'; var dic = &#123; 'handlerInterface': handlerInterface, 'function': handlerMethod, //调用原生的指令 'parameters': parameters, //传递的参数； 'callbackMethod': callbackMethod //回调的函数 &#125;; if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) &#123; window.webkit.messageHandlers[handlerInterface].postMessage(dic); &#125; else &#123; //安卓 app.ymAppWebClick(JSON.stringify(dic)); &#125; &#125; else &#123; //包含微信功能，比如可唤起小程序。 &#125; &#125;&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://www.littlewhale.xyz/categories/Web/"}],"tags":[]},{"title":"递归，分治，标记","slug":"algorithmExercises","date":"2020-02-02T02:11:19.000Z","updated":"2020-05-27T00:57:27.000Z","comments":true,"path":"2020/02/02/algorithmExercises/","link":"","permalink":"https://www.littlewhale.xyz/2020/02/02/algorithmExercises/","excerpt":"目录 打印图案 等腰三角形之字母扩展 空心菱形 方法一：两个等腰三角形拼接 空心菱形 方法二：对角线相等 杨辉三角 螺旋矩阵 蛇形矩阵 1 蛇形矩阵 2 趣味习题 打印某年某月日历排版 找出最长的单词 颠倒一串英文句子 颠倒一串英文句子 Java版本 生成不重复的随机数 统计班级成绩排名 Java 版本 统计班级成绩排名 C 版本 报数 123，报数 3 的童鞋退出，最后留下的是哪个同学。 Java 版本 报数 123，报数 3 的童鞋退出，最后留下的是哪个同学。 C 语言版本 模拟对象层级树结构 基础排序 插入排序 选择排序 冒泡排序 快速排序 二分法查找 Json 格式的校验","text":"目录 打印图案 等腰三角形之字母扩展 空心菱形 方法一：两个等腰三角形拼接 空心菱形 方法二：对角线相等 杨辉三角 螺旋矩阵 蛇形矩阵 1 蛇形矩阵 2 趣味习题 打印某年某月日历排版 找出最长的单词 颠倒一串英文句子 颠倒一串英文句子 Java版本 生成不重复的随机数 统计班级成绩排名 Java 版本 统计班级成绩排名 C 版本 报数 123，报数 3 的童鞋退出，最后留下的是哪个同学。 Java 版本 报数 123，报数 3 的童鞋退出，最后留下的是哪个同学。 C 语言版本 模拟对象层级树结构 基础排序 插入排序 选择排序 冒泡排序 快速排序 二分法查找 Json 格式的校验 打印图案等腰三角形之字母扩展123456789101112131415161718192021222324252627282930313233343536373839//等腰三角形之字母扩展void printThreeCornerRect1()&#123; int i,j,row; printf(\"输入行：\"); scanf(\"%d\",&amp;row); int col=2*row-1; char words[27]=\" ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; int center = col/2 + 1; printf(\"center:%d\\n\",center); for(i=1;i&lt;=row;i++)&#123; for(j=1;j&lt;=col;j++)&#123; if(j&lt;=row-i||j&gt;col-(row-i)) printf(\" \"); else&#123; if(j==center &amp;&amp; i &gt;1)&#123; printf(\"%c\",words[i+1]); &#125;else&#123; printf(\"%c\",words[i]); &#125; &#125; &#125; printf(\"\\n\"); &#125;&#125;打印结果：输入行：9 A BCB CCDCC DDDEDDD EEEEFEEEE FFFFFGFFFFF GGGGGGHGGGGGG HHHHHHHIHHHHHHH IIIIIIIIJIIIIIIII 思路分析： 根据输入行数，先输出一个矩形如下图所示。 确定每一行字母的个数为 2 n - 1。 每行显示的时候根据条件对显示字母除外的地方挖空，用 * 表示 打印字母取数组对应下标行数的字母。正中间的位置为下标加 1 输出下一个字母。123456789********A***************BCB*************CCDCC***********DDDEDDD*********EEEEFEEEE*******FFFFFGFFFFF*****GGGGGGHGGGGGG***HHHHHHHIHHHHHHH*IIIIIIIIJIIIIIIII 空心菱形 方法一: 两个等腰三角形拼接1234567891011121314151617181920212223242526272829303132333435363738394041//空心菱形void printLingxingRect()&#123; int i,j,e,f; int c; char word[10] = \"*\"; printf(\"请输代表图案:\"); scanf(\"%s\",&amp;word); printf(\"请输入行:\"); scanf(\"%d\",&amp;c); printf(\"\\n\"); for(i=1;i&lt;=c;i++) //打印上半部分 &#123; for(j=1;j&lt;=c+1-i;j++) &#123; printf(\" \"); //左边挖空 &#125; for(j=1;j&lt;=(2*i-1);j++) &#123; if(j&gt;1&amp;&amp;j&lt;(2*i-1)) printf(\" \"); //中间挖空 else printf(\"%s\", word); &#125; printf(\"\\n\"); &#125; for(e=2;e&lt;=c;e++) //打印下半部分 &#123; for(f=1;f&lt;=e;f++) &#123; printf(\" \"); &#125; for(f=1;f&lt;=2*c+1-2*e;f++) &#123; if(f&gt;1&amp;&amp;f&lt;2*c+1-2*e) printf(\" \"); else printf(\"%s\",word); &#125; printf(\"\\n\"); &#125;&#125; 效果如下：1234567891011121314151617181920请输代表图案:*请输入行:9 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 思路分析： 由一个正等腰三角形和倒等腰三角形组成。 对上半部分等腰三角形左边挖空，中间挖空。 对下半部分倒等腰三角形左边挖空，中间挖空。下图为数字 0 替代挖空位置的分析思路。1234567891011121314151617000000000*00000000*0*0000000*000*000000*00000*00000*0000000*0000*000000000*000*00000000000*00*0000000000000*0*000000000000000*00*0000000000000*000*00000000000*0000*000000000*00000*0000000*000000*00000*0000000*000*00000000*0*000000000* 空心菱形 方法二： 对角线相等12345678910111213141516171819void printLingxingRect2()&#123; int r,c,row; printf(\"请输入菱形的对角线的长度:\"); scanf(\"%d\",&amp;row); for(r=1;r&lt;=row*2-1;r++) &#123; for(c=1;c&lt;=row*2-1;c++) &#123; if((r&lt;=row &amp;&amp; (c==row+1-r)) || c==row-1+r) printf(\"*\"); else if((r&gt;=row &amp;&amp; (c==r-row+1)) || (c==row+row*2-1-r)) printf(\"*\"); else printf(\" \"); &#125; printf(\"\\n\"); &#125;&#125; 思路分析： 根据菱形的对角线相等的数据知识，首先绘制的是一个矩形图案如图所示: 数字 0 为挖空项。 第一个条件先判断上半部分左边和右边星星位置。 第二个条件判断下半部分左边和右边星星的位置。 以上半部分为列 “c == row-1+r” 和 左边 “row+1-r” 对称。 123456789101112131415161718请输入菱形的对角线的长度:900000000*000000000000000*0*0000000000000*000*00000000000*00000*000000000*0000000*0000000*000000000*00000*00000000000*000*0000000000000*0*000000000000000*0*0000000000000*000*00000000000*00000*000000000*0000000*0000000*000000000*00000*00000000000*000*0000000000000*0*000000000000000*00000000 杨辉三角1234567891011121314151617181920212223242526//杨辉三角void yanghui_Corner()&#123; int arr[15][15]; int i,j; for(i=0;i&lt;10;i++)&#123; arr[i][0]=1; arr[i][i]=1; &#125; //从第三行开始出现规律 for(i=2;i&lt;10;i++)&#123; for(j=1;j&lt;i;j++)&#123; arr[i][j]=arr[i-1][j]+arr[i-1][j-1]; &#125; &#125; //输出 for(i=0;i&lt;10;i++)&#123; for(j=0;j&lt;=i;j++)&#123; printf(\"%d\\t\",arr[i][j]); &#125; printf(\"\\n\"); &#125;&#125; 123456789101 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 思路分析： 从图中观察到规律，第二行开始，数字 2 是前一行的对应列和前一个位置相加所得结果。 每一行的第一个位置都是 1，每一行的最后一个位置都是 1。 第一步： 建立二维数组。先给每一行的的第一个位置和 n 行的第 n 个位置赋值1。 第二步：从第 3 行开始出现规律可得出 “arr[i][j]=arr[i-1][j]+arr[i-1][j-1]” 表达式。螺旋矩阵12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define len 9void luoxuan()&#123; int arr[len][len]; //开始初始化，给数组赋值0 for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;len;j++)&#123; arr[i][j] = 0; &#125; &#125; arr[0][0] = 1; //顶角确定了，我们可以算出第一行右边的数字 int circleTimes = len/2 + 1; int circelIndex = 0; //圈的数量 //赋值过程 while(circleTimes&gt;0)&#123; //测试时候，每一圈结束可以打印出看一下：&amp;&amp; circelIndex &lt;1 circelIndex ++; printf(\"第%d圈\\n\",circelIndex); for(int column = 1;column &lt;= len-circelIndex; column++)&#123; //往右排列 if(column &gt;= circelIndex-1)&#123; arr[circelIndex-1][column] = arr[circelIndex -1][column-1] + 1; &#125; &#125; for(int row = circelIndex; row&lt;= len-circelIndex; row++)&#123; //往下排列，从第二行，第X-i 列开始 arr[row][len-circelIndex] = arr[row-1][len-circelIndex] + 1; &#125; for(int column = len-circelIndex-1; column &gt;= circelIndex-1; column--)&#123; //往左排，下标递减1，值为后一个 + 1 arr[len-circelIndex][column] = arr[len-circelIndex][column+1] + 1; &#125; for(int row =len-circelIndex-1; row &gt; circelIndex-1; row--)&#123; //往上排列 arr[row][circelIndex-1] = arr[row+1][circelIndex-1] + 1; &#125; circleTimes--; &#125; //输出二维数组 for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;len;j++)&#123; printf(\"%d\\t\",arr[i][j]); &#125; printf(\"\\n\\n\"); &#125;&#125; 思路分析：由上图，当我们打印 9 行的时候，列也是 9 列。确定二维数组的长度。为了方便视觉上可以观察出每一次绕圈赋值的效果，可将二维数组每一个位置初始化赋值为 0。根据 9 行，我们确定绕圈数为 circleTimes = 5。确定循环条件之后，为每一次绕圈的二维数组某些位置赋值。依次从向右、向下、向左、向上进行赋值。circleTimes 圈数相对应减 1。 往右排列：列的起始位置为1，条件为 len - circleIndex，值为相同行的前一列的值加 1。赋值的时候还需控制列大于等于 circleIndex 减 1。如图所示控制 32，56，72，80，81 的列起始位置。 往下排列：行的起始位置为第几圈的索引， 值为前一行的相同列的值加 1。 往左排列：列起始位置为 len - 第几圈 - 1，值为同行的后一列值加 1。 往上排列：行的起始位置为 len - 第几圈 -1，值为相同列的后一行值加 1。 蛇形矩阵112345678910111213141516171819202122232425262728293031323334353637/* 1 3 6 10 15 2 5 9 14 4 8 13 7 12 11*/ public static void main(String[] args) &#123; Test3 t=new Test3(); t.test(5); &#125; public void test(int n) &#123; int arr[][]=new int[n][n]; arr[0][0]=1; int column=n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; column; j++) &#123; if(j==0)&#123; if(i&gt;0) arr[i][j]=arr[i-1][j]+i; &#125;else&#123; arr[i][j]=arr[i][j-1]+(i+1+j); &#125; &#125; column-=1; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if(arr[i][j]!=0) System.out.print(arr[i][j]+\" \"); &#125; System.out.println(); &#125; &#125; 思路分析： 第n行第一列值为前一行的第一列值加 n。 其他列赋值为前一列值加行 i 和列 j 再加 1。 控制第二层循环列的范围，列随行变化递减。 蛇形矩阵2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960打印结果：1 2 6 7 15 16 28 29 3 5 8 14 17 27 30 4 9 13 18 26 31 10 12 19 25 32 11 20 24 33 21 23 34 22 35 36 public static void main(String[] args) &#123; Test4 t=new Test4(); t.printData(t.test2(8)); &#125; public int[][] test2(int n)&#123; int arr[][]=new int[n][n]; for (int i = 0; i &lt; n; i++) &#123; for (int j=0,c=i;j&lt;=i&amp;&amp;c&gt;=0;j++,c--) &#123; if(i%2==0)&#123; if(c==i)&#123; if(c==0) arr[c][j]=1; //arr[0][0] = 1 else arr[c][j]=arr[c-1][j]+1; //前一行加1 &#125; else arr[c][j]=arr[c+1][j-1]+1; //后一行前一列加1 &#125;else&#123; if(c==i) arr[j][c]=arr[j][c-1]+1; //前一列加1 else arr[j][c]=arr[j-1][c+1]+1;//前一行后一列加1 &#125; &#125; &#125; return arr; &#125; public void printData(int arr[][])&#123; int n=arr.length; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if(arr[i][j]&gt;=10) System.out.print(arr[i][j]+\" \"); else if(arr[i][j]!=0) System.out.print(\"0\"+arr[i][j]+\" \"); &#125; System.out.println(); &#125; &#125; 思路分析：根据规律，根据行下标奇偶数拆分赋值。 数字 {02,07,16,29} 为在前一列加 1。数字 {03,08,17,30} 为前一行的后一列加 1。 数字 {05,06,15,28} 为后一行的前一列加 1。数字 4 为前一行加 1。 蛇形矩阵2123456789101112131415161718192021222324252627282930313233/* 1 5 2 8 6 3 10 9 7 4 观察 arr[1][0] arr[3][3] arr[2][0] arr[3][2] */ public static void main(String[] args) &#123; Test5 t=new Test5(); t2.printData(t.test(10)); &#125; public int[][] test(int n)&#123; int arr[][]=new int[n][n]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0,c=i;j&lt;n&amp;&amp;c&lt;n; j++,c++) &#123; if(c==i)&#123; if(c==0) arr[c][j]=1; //arr[0][0] = 1 else arr[c][0]=arr[n-1][n-c]+1; &#125; else&#123; arr[c][j]=arr[c-1][j-1]+1; &#125; &#125; &#125; return arr; &#125;&#125; 趣味习题打印某年某月日历排版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void showDateBookDetail()&#123; int year, month; int sumYearDays = 0; //该变量是统计到现在的总年数天数 int sumMonthDays = 0; //月份总天数 int sumDays = 0;//总天数 int week; //星期 int y, i; int monthArr[] = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; //12个月的天数 printf(\"请输入一个日期(列如 2019-10):\"); scanf(\"%d-%d\", &amp;year, &amp;month); //年-月-日 //思路: 1900年1月1日是星期一 for(y = 1900; y &lt; year; y++) &#123; if(y % 400 == 0 || (y % 4 == 0 &amp;&amp; y % 100 != 0))&#123; sumYearDays += 366; //闰年 加366天 &#125; else sumYearDays += 365; //平年 加365天 &#125; //闰年的二月份 if(year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0) )&#123; monthArr[1] = 29; &#125; //累加今年的月份天数 for(i=0; i &lt; month-1; i++)&#123; sumMonthDays += monthArr[i]; &#125; sumDays = sumYearDays + sumMonthDays + 1; //总天数= 年得总天数+月、号得总天数 //求本月的第一天是星期几 余数 week = sumDays % 7; printf(\"日\\t一\\t二\\t三\\t四\\t五\\t六\\n\\n\"); for(i = 0; i &lt; week; i++) &#123; printf(\"\\t\"); &#125; for(i = 1; i &lt;= monthArr[month - 1]; i++) &#123; printf(\"%d\\t\" , i); if((i + week) % 7 == 0) printf(\"\\n\\n\"); &#125;&#125; 1234567891011121314请输入一个日期(列如 2020-01):2020-01日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 Program ended with exit code: 0 思路分析： 打印日历首先要确定某个月的 1 号是星期几。 根据 1900 年 1 月 1 日至某月 1 日的总天数 %7 所得余数就得知某月 1 号是星期几。 循环当月总天数 %7 进行换行，依次打印每一天的排版。 找出最长的单词123456789101112131415161718192021222324252627282930313233#include &lt;string.h&gt;void countWords()&#123; char str[100] = \"hello, my name is gaogaoProgramer, welcome to come here!\"; int index; long len = strlen(str); int spaceIndex = 0; //从第一个下标开始算 int recordMax = 0; //单词空格之间下标最大差即为最长单词 int beforeIndex = 0,afterIndex = 0; //定义最长单词的前空格，后空格 for(index = 0; index &lt; len; index++)&#123; if(str[index] == 32)&#123; //判断空格 if(index - spaceIndex &gt; recordMax)&#123; recordMax = index - spaceIndex; //记录前下标和后下标。 beforeIndex = spaceIndex; afterIndex = index; &#125; spaceIndex = index; &#125; &#125; printf(\"原始单词为：%s\",str); printf(\"\\n单词空格之间下标最大差:%d 前下标:%d,后下标:%d\",recordMax,beforeIndex,afterIndex); //输出找到的单词； printf(\"\\n\\n找到的最长度单词为：\"); int charIndex; for(charIndex = beforeIndex; charIndex&lt; afterIndex ; charIndex++)&#123; printf(\"%c\",str[charIndex]); &#125;&#125; 思路分析：首先想到的是每个单词的划分简单规定认为是空格分隔即为一个单词。所以我们统计每一个空格的下标，记录空格下标的最大差值。记录起始下标和终止下标。这样就找到了一个最长的单词。 颠倒一串英文句子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void revertString()&#123; int i,start=0; char str[4096] = \"I am a SoftWare Programer\"; char min1 = str[0]; char t; printf(\"结果：%d \\n\",min1); int len = strlen(str); int end = len-1; while(start&lt;=end) //颠倒整个字符串 &#123; t=str[start]; str[start]=str[end]; str[end]=t; start++; end--; &#125; printf(\"颠倒后的字符串是：%s\",str); start=0; for(i=0;i&lt;len;i++) //颠倒一个单词 &#123; if(str[i]==32||str[i+1]==0) //如果是空格 或是结尾 &#123; if(i==len-1) //判断是否最后一个 end=i; else end=i-1; while(start&lt;=end) //调换空格与空格之间 &#123; t=str[start]; str[start]=str[end]; str[end]=t; start++; end--; &#125; start=i+1; //起始位置 &#125; &#125; printf(\"\\n输出：\"); for(i=0;i&lt;len;i++) &#123; printf(\"%c\",str[i]); &#125;&#125; 思路分析：C 语言版本首先我们想到的是倒转整个字符串，然后再根据空格分割循环依次再倒转每一个单词，这样就实现了倒转整个句子。 颠倒一串英文句子 Java版本123456789101112131415161718192021222324252627282930313233import java.util.Scanner;public class reverseString &#123; /** * 旋转字符串 如： I am a student * 结果为： student a am I * @param arr */ public static void reverse(String arr[]) &#123; int start = 0; for (int end = arr.length - 1; start &lt; end; end--) &#123; String temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; start++; &#125; System.out.println(\"\\n颠倒后的结果为：\"); for (int i = 0; i &lt; arr.length; i++) System.out.print((new StringBuilder(String.valueOf(arr[i]))).append(\" \").toString()); &#125; public static void main(String[] args) &#123; System.out.println(\"请输入一串字符\"); Scanner input=new Scanner(System.in); String str=input.nextLine(); String arr[]=str.split(\" \"); reverse(arr); &#125;&#125; 思路分析：Java 版本的倒转思路比较简单。我们可以直接利用字符窜方法根据空格分割成一个字符窜数组。然后再针对数组元素进行倒转调换位置。 生成不重复的随机数12345678910111213141516171819202122//标记法public void randomTest2()&#123; Random random = new Random(); long[] arr =new long[15]; boolean flag[] = new boolean[15]; flag[0] = true; for(int index=1; index&lt;flag.length; index++)&#123; flag[index] = false; &#125; for(int i=0; i&lt;arr.length; i++)&#123; int num = r.nextInt(15); if(!flag[num])&#123; //只需判断标记数组中对应的数字位置存储的状态就可以知道是否产生过该随机数 arr[i] = num; flag[num] = true; &#125;else&#123; i--; &#125; &#125; //输出15个数&#125; 思路分析： 生成不重复的小范围数字，我想到有两种方案。 第一种是每一次生成，要循环去检验已生成的随机数数组中是否包含该数字。 第二种方案是用另外一个数组布尔值来存储，当已生成随机某数时，就把对应的布尔值数组设置随机下标数值为 true。当下次再生成的时候，就可以直接命中无需查找数组元素。 这也是借鉴 map 存取数据的方式，直接根据 key 命中数据。key 则相当于那个随机数。 统计班级成绩排名 java版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Arrays;import java.util.Scanner;public class SameSCore &#123; /** * 统计同成绩的人数 * 推断过程： 第一名找出后 ，统计和第一名相等的分数有几个 * @param args */ public static void main(String[] args) &#123; int arr[] = &#123; 65, 70, 80, 50, 70, 80 &#125;; Arrays.sort(arr); // 升序排列 int len = arr.length - 1; System.out.println(\"请输入前多少名?\"); Scanner input=new Scanner(System.in); int num=input.nextInt(); int count[] = new int[num+1]; //由于第1个不取，所以长度比实际的加1 ，存储第多少名的 数据 int score[]=new int[len+1]; //成绩 //第几名 多少个同学 for (int k = 1; k &lt;= count.length-1; k++) &#123; int hasCount=0; for(int j=1;j&lt;=k;j++)&#123; hasCount+=count[j]; //已经统计的个数 &#125; for (int i = len - hasCount; i &gt;= 0; i--) &#123; //统计第几名重复了几个 if (arr[i] == arr[len - hasCount]) &#123; score[k]=arr[len - hasCount]; //第几名的分数 count[k]++; //第几名的个数 &#125; &#125; &#125; // 结果： for (int i = 1; i &lt;count.length; i++) &#123; try&#123; System.out.println(\"第\" + i + \"名,成绩为\"+score[i]+\"：\" + count[i]); &#125;catch(ArrayIndexOutOfBoundsException e)&#123; System.out.println(\"第\"+i+\"名超出范围哦!\"); &#125; &#125; &#125;&#125; 统计班级成绩排名 C 版本1234567891011121314151617181920212223242526272829303132333435363738394041424344void statisticsScoreDescCount ()&#123; int arr[10]=&#123;20,30,50,60,60,76,85,85,96,96&#125;; //已经升序的数组 char names[10][20]=&#123;\"jack\",\"running\",\"lucy\",\"mary\",\"hong\",\"liu\",\"wike\",\"smith\",\"boss\",\"younth\"&#125;; int hasCount=0; //已经统计了的个数 int count[ScoreSystemArrLen+1]=&#123;0&#125;; //第一个num[0]不要，记录第几名的个数。 int score[10]=&#123;0&#125;; //统计成绩 score[1]=96 score[2]=85 记录第几名的成绩 int k,j,i,c=0; for(k=1;k&lt;=ScoreSystemArrLen;k++) //处理过程 &#123; hasCount=0; for(j=1;j&lt;=k;j++) &#123; hasCount+=count[j]; // 统计前面出现的总个数 &#125; for (i = 9-hasCount; i &gt;= 0; i--) &#123; if (arr[i] == arr[9 - hasCount]) &#123; score[k]=arr[9 - hasCount]; //记录具体第几名的分数 count[k]++; //记录具体第几名的个数 &#125; &#125; &#125; //输出 for (i = 1; i &lt;ScoreSystemArrLen+1; i++) &#123; hasCount=0; for(j=1;j&lt;=i;j++)// 统计前面出现的总个数 &#123; hasCount+=count[j]; &#125; if(count[i] ==0)&#123; break; &#125; printf(\"\\n第 %d 名,个数%d,成绩为:%d\\n\",i,count[i],score[i]); for(c=1,k=10-hasCount;c&lt;=count[i];k++,c++) //count[i] 是 当前第几名的个数 &#123; printf(\"名字：%s\\n\",names[k]); &#125; &#125;&#125; 123456789101112131415161718192021222324第 1 名,个数2,成绩为:96名字：boss名字：younth第 2 名,个数2,成绩为:85名字：wike名字：smith第 3 名,个数1,成绩为:76名字：liu第 4 名,个数2,成绩为:60名字：mary名字：hong第 5 名,个数1,成绩为:50名字：lucy第 6 名,个数1,成绩为:30名字：running第 7 名,个数1,成绩为:20名字：jack 思路分析：假设有 10 个同学，则大循环 10 次。每次检查，分别将已统计的学生个数 hasCount 计算出来，然后从剩下的同学中取得其成绩标记为下一名的分数。内循环依次判断剩下同学的分数是否和本次名数的分相等，如果相等则为重复分数，记录重复分数的个数 count[k]++ , k 变量为排名。 报数123，报数3的童鞋退出，最后留下的是哪个同学。 Java 版本123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;public class TheLastPerson&#123; public static void main(String args[]) &#123; System.out.println(\"报数123，报3的同学退出，最后一个留下的同学\"); System.out.println(\"请输入总共有几个同学\"); Scanner input = new Scanner(System.in); int num = input.nextInt(); boolean bl[] = new boolean[num]; for (int i = 0; i &lt; bl.length; i++)&#123; bl[i] = true; &#125; int index = 0; int lastnum = num; int countNum = 0; while (lastnum &gt; 1) //最后留下来的人 &#123; if (bl[index] &amp;&amp; ++countNum == 3) &#123; countNum = 0; //报数3后需回归 bl[index] = false; //将报数为3的人状态标记为false lastnum--; //把队列人数减1 &#125; if (++index == num) //当报数到排在最后一个位置的人，第一个接着最后一个报数 index = 0; &#125; for (int i = 0; i &lt; num; i++)&#123; if (bl[i]) System.out.println((new StringBuilder(\"最后留下的是第\")).append(i + 1).append(\"个同学\").toString()); &#125; &#125; &#125; 思路分析： 根据全队员人数定义一个标记布尔类型的数组。标记所有人为 true 都在队列的意思。 当报数 3 的人标记为 false. 人数出队，剩余人数减 1。接着紧邻下一个队员报数 1。 每一次报数到最后当前队剩余人数的最后一个人的时候，接着再从下标为 0 的队员报数。直到最后队列剩余人数为 1。 最后再从布尔类型的数组中找出标记为 true 的位置，即可找到是哪一个同学。 报数 123，报数 3 的童鞋退出，最后留下的是哪个同学。 C 语言版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define N 28#define ScoreSystemArrLen 10#define MaxLen 50void findStudentWhichAskNumber()&#123; char S1S8[N][15]=&#123; \"廖同学\", \"吴同学\", \"陈聪同学\", \"颜同学\", \"梅同学\", \"昌同学\", \"刘同学\", \"钟同学\", \"黄同学\", \"生同学\", \"伟同学\", \"平同学\", \"余广同学\", \"朱宁同学\", \"陈鸿同学\", \"王同学\", \"东同学\", \"雄同学\", \"张同学\", \"林同学\", \"梁同学\", \"婷同学\", \"维同学\", \"英同学\", \"黄同学1\", \"斌同学\", \"全同学\", \"戴同学\"&#125;; printf(\"【报数游戏】规则：一群同学排队，从规定的第几个同学开始报数1，依次2，3。报数3的同学出队。求最后剩下的人是谁？\\n\\n\"); char bl[N]; int i,n; int index; //索引，轮到第几个人了 int lastnum=N; //剩余人数 int countNum=0; //报的数字 //输出 for(i=0;i&lt;N;i++) &#123; printf(\"%s\\t\",S1S8[i]); &#125; for(i=0;i&lt;N;i++) &#123; bl[i]=1; &#125; //28个人都参与报数 printf(\"\\r\\r请输入从第几个人开始报数：\"); scanf(\"%d\",&amp;n); printf(\"\\n从%s开始报数,\",S1S8[n-1]); index=n-1; while(lastnum&gt;1) //如果剩余人数大于1 说明还要继续报数 &#123; if(bl[index]) //表示还没报3的人。 &#123; countNum++; if(countNum==3) &#123; countNum=0; bl[index]=0; //标记报了3 lastnum--; //剩余人数-1 &#125; &#125; index++; //下一个人 if(index==N) //报到最后，回来继续报数 index=0; &#125; //输出 for(i=0;i&lt;N;i++) &#123; if(bl[i]) printf(\"最后留下来的是：%s\",S1S8[i]); &#125;&#125; 123456789【报数游戏】规则：一群同学排队，从规定的第几个同学开始报数1，依次2，3。报数3的同学出队。求最后剩下的人是谁？廖同学 吴同学 陈聪同学 颜同学 梅同学 昌同学 刘同学 钟同学 黄同学 生同学 伟同学 平同学 余广同学 朱宁同学 陈鸿同学 王同学 东同学 雄同学 张同学 林同学 梁同学 婷同学 维同学 英同学 黄同学1 斌同学 全同学 戴同学 请输入从第几个人开始报数：6从昌同学开始报数,最后留下来的是：戴同学Program ended with exit code: 0 模拟对象层级树结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.*;/* * 查找树节点 */public class LookWord &#123; private ArrayList&lt;TreeBean&gt; treeList = new ArrayList&lt;TreeBean&gt;(); public static void main(String[] args) &#123; LookWord lw = new LookWord(); lw.init();// lw.findAll(lw.treeList); //查找所有 lw.findWho(\"111\",lw.treeList); //查找某一个树节点 &#125; public void findWho(String id,ArrayList&lt;TreeBean&gt; ts) &#123; for (TreeBean t : ts) &#123; if(t.getId().equals(id)&amp;&amp;t.getChildren()!=null)&#123; findAll(t.getChildren()); &#125;else&#123; if(t.getChildren()!=null)&#123; findWho(id,t.getChildren()); &#125; &#125; &#125; &#125; public void findAll(ArrayList&lt;TreeBean&gt; findList) &#123; for (int i = 0; i &lt; findList.size(); i++) &#123; TreeBean tb = findList.get(i); System.out.println(tb.toString()); if (tb.getChildren() != null) &#123; findAll(tb.getChildren()); &#125; &#125; &#125; // 初始数据 private void init() &#123; ArrayList&lt;TreeBean&gt; children111 = new ArrayList&lt;TreeBean&gt;(); TreeBean tb111 = new TreeBean(\"1111\", \"one1111\", \"111\"); TreeBean tb112 = new TreeBean(\"1112\", \"one1112\", \"111\"); children111.add(tb111); children111.add(tb112); TreeBean tb11 = new TreeBean(\"111\", \"one111\", \"11\"); tb11.setChildren(children111); TreeBean tb12 = new TreeBean(\"112\", \"one112\", \"11\"); TreeBean tb13 = new TreeBean(\"113\", \"one113\", \"11\"); ArrayList&lt;TreeBean&gt; children11 = new ArrayList&lt;TreeBean&gt;(); children11.add(tb11); children11.add(tb12); children11.add(tb13); TreeBean tp11 = new TreeBean(\"11\", \"one1\", \"1\"); tp11.setChildren(children11); TreeBean tp12 = new TreeBean(\"12\", \"one2\", \"1\"); ArrayList&lt;TreeBean&gt; children1 = new ArrayList&lt;TreeBean&gt;(); children1.add(tp11); children1.add(tp12); TreeBean tb1 = new TreeBean(\"1\", \"one\", \"0\"); tb1.setChildren(children1); ArrayList&lt;TreeBean&gt; children2 = new ArrayList&lt;TreeBean&gt;(); children2.add(new TreeBean(\"21\", \"two1\", \"2\")); children2.add(new TreeBean(\"22\", \"two2\", \"2\")); TreeBean tb2 = new TreeBean(\"2\", \"two\", \"0\"); tb2.setChildren(children2); treeList.add(tb1); treeList.add(tb2); &#125;&#125; 12345678//TreeBean 的树结构模型public class TreeBean &#123; private String id; private String text; private String pid; private ArrayList&lt;TreeBean&gt; children=new ArrayList&lt;TreeBean&gt;();&#125; 思路分析： 树结构最重要的一点是递归思想。无论查找全部还是查找单独某一个树节点，都需得到他的子节点。遍历子节点时候根据 children 可得到是否还有三级子节点 有则递归调用。注意父节点与子节点的绑定关系即可。 基础排序插入排序12345678910111213141516171819202122232425/* 插入排序，效率大于选择排序。* 方法：将一个记录插入到已排好序的有序表（有可能是空表）中* 每次和最后一个比较，若比前面小则再换位置，直到不比前面小。*/public static void insert(int arr[])&#123; int count=0; int pos ; for ( int i = 1; i &lt; arr.length; i++) &#123; pos=count; //一开始进来就是和最后一个数比 int index=i; while( arr[index]&lt;arr[pos ]&amp;&amp;pos&gt;=0)&#123; //排序数 如果比已经排好的最后一个数小则，和前一个比较 int t=arr [pos]; arr[pos ]=arr[index]; arr[index]=t; index-=1; //注意：这是个换了位置的数 pos--; //准备和前一个比较 &#125; count++; &#125;&#125; 思路分析：将一个记录插入到已排好序的有序表（有可能是空表）中每次和最后一个比较，若比前面小则再换位置，直到不比前面小。 选择排序1234567891011121314151617181920/** 直接选择排序* 方法：每一趟从待排序的数据元素中选出最小（或最大）的一个元素，* 顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。*/public static void directChoose(int[] arr) &#123; int index; int temp; for(int i=1;i&lt;arr.length;i++)&#123; index=0; for(int j=1;j&lt;=arr.length-i;j++)&#123; if(arr[j]&lt;arr[index])&#123; index=j; &#125; &#125; temp=arr[arr.length-i]; arr[arr.length-i]=arr[index]; arr[index]=temp; &#125;&#125; 思路分析：每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。 冒泡排序12345678910111213141516//每一趟排序 都可以找出最大或最小值，下一趟排序的时候，就可以排除最后已筛选出的数，和剩下的数比较。冒泡排序每一轮都是相邻的两数在比较。public static void maopao(int arr[])&#123; int temp = 0; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) //n个数 比较n-1轮 第n轮 比较n-1次， 第一轮可找出最大值。 if (arr[i] &lt; arr[j]) &#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125;&#125; 思路分析：每一趟排序 都可以找出最大或最小值，下一趟排序的时候，就可以排除最后已筛选出的数，和剩下的数比较。冒泡排序每一轮都是相邻的两数在比较。 快速排序12345678910111213141516171819202122232425262728293031323334353637383940public class QuickSort &#123; public static void main(String[] args) &#123; long start=System.currentTimeMillis(); int arr[] =&#123;12,34,11,99,54,21,9,5,101&#125;; QuickSort t=new QuickSort(); t.quicksort(arr,0,arr.length-1); t.print(arr); System.out.println(\"快速排序:\"+(System.currentTimeMillis()-start)); &#125; public void quicksort(int arr[], int left, int right)&#123; if(left &lt; right)&#123; int key = arr[left]; int low = left; int high = right; while(low &lt; high)&#123; while(low &lt; high &amp;&amp; arr[high] &gt; key)&#123; high--; &#125; arr[low] = arr[high]; while(low &lt; high &amp;&amp; arr[low] &lt; key)&#123; low++; &#125; arr[high] = arr[low]; &#125; arr[low] = key; quicksort(arr,left,low-1); quicksort(arr,low+1,right); &#125; &#125; public void print(int arr[]) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+\" \"); &#125; &#125;&#125; 思路分析：每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。巧妙运用分治思想。 二分法查找123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class HalfSelect &#123; /** * 二分法查找 * * @param arr * 数组 * @param num * 要查找的数字 * @return 返回位置 */ private static int halfLook(int[] arr, int num) &#123;// 二分法查找 int middle; int start = 0, last = arr.length - 1; if (num &lt; arr[start] || num &gt; arr[last]) return -1; while (true) &#123; middle = (last + start) / 2; // 求中间位置 if (start &gt; last) &#123; break; &#125; if (num &gt; arr[middle]) &#123; start = middle + 1; &#125; else if (num &lt; arr[middle]) &#123; last = middle - 1; &#125; else return middle; // 相等则返回 &#125; return -1; &#125; public static void halfShow(int arr[]) &#123; Scanner input = new Scanner(System.in); System.out.println(\"请输入你要查找的数:\"); int n = input.nextInt(); int w = halfLook(arr, n); if (w &gt;= 0) System.out.println((new StringBuilder(\"位置：\")).append(w).toString()); else System.out.println(\"没有该数！\"); &#125; &#125; 思路分析：二分法查找前提是数据要先排好序，然后才能折半查找。不断取得中间位置的数字进行比较查询出目标数。 Json 格式的校验在讲解之前，我们先熟悉一下 Promise.all()方法的用法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 testPromiseAll() &#123; function washFood()&#123; console.log('做饭第一步：洗菜'); let hasError = false; if(hasError)&#123; return \"发现了一只虫子！洗掉它。\"; &#125;else&#123; return '菜洗干净了。'; &#125; &#125; function cutFood() &#123; console.log('做饭第二步：切菜'); var p = new Promise(function (resolve, reject) &#123; //做一些异步操作 setTimeout(function () &#123; let cutFoodHasError = true; //控制默契切菜时 是否发生异常 if(cutFoodHasError)&#123; reject(\"呜呜~ 割到手了，流血！\") &#125;else&#123; resolve('切好了菜。'); &#125; &#125;, 1000); &#125;) /* 试试打开这里的注释 .catch(error=&gt;&#123; console.log(\"切菜异常:\"+error); //异常本身就是返回resolve状态，值是null console.log(\"用创口贴止血，继续做菜。\"); &#125;); */ return p; &#125; function cooking() &#123; console.log('做饭第三步：炒菜'); var p = new Promise(function (resolve, reject) &#123; //做一些异步操作 setTimeout(function () &#123; resolve('菜已做好!'); &#125;, 2000); &#125;); return p; &#125; //数组里，如果放Promise 一定要返回状态。 Promise.all([washFood(), cutFood(),cooking()]) .then((result) =&gt; &#123; console.log('上桌，吃饭了：'+result); console.log(result); &#125;).catch(error=&gt;&#123; console.log(\"菜没做成，出现了小事故:\"+error); &#125;) /* 结果： 1. 当cutFoodHasError = true；打印如下结果： 菜没做成，出现了小事故:呜呜~ 割到手了，流血！ 2. 当cutFoodHasError = true 且 cutFood方法里的Promise有异常捕捉时： 切菜异常:呜呜~ 割到手了，流血！ 上桌，吃饭了：菜洗干净了！,,菜已做好 3. 当cutFoodHasError = false 上桌，吃饭了：菜洗好了。切好了菜。菜已做好！ */ /* Promise.all使用总结： 数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态改变 当所有的子Promise都完成，该Promise完成，返回值是全部值得数组 有任何一个失败，该Promise失败，返回值是第一个先失败的子Promise结果 */&#125; 服务返回 json 字符串 result 12345//以下注释很重要：采用分治和递归的思想。另外结合Promise.all方法 做一个异步队列控制。boolean isJsonFlag = checkJsonObject(result);function checkJsonObject(obj)&#123; return jsonFlag;&#125;思路分析： 获取每一个 key, 和对应 value 。 对 value 进行类型判断,如果是 [ ] 数组类型，foreach 每一项判断是否为 { } 对象 ，如果是 递归调用 checkObject(itemObject) 方法；对于 value 为普通类型时，只需更具正则或算法匹配是否符合 key: value 格式。 根据服务端返回的 result 字符窜分割后依据 第一层级的 value类型为 [] 数组类型的个数的多少，分批用类似 Promise.all 方法 异步执行多个 Promise，一旦有一个校验返回 reject，则立即是返回 false。判断不匹配。无需等待所有的 Promise 任务执行完成。而全部 Promise 校验正确才会返回 true; 总结：通过本 chat 的学习和手动敲码实践，你将收获到对分治和递归的思想的理解。对状态的标记思想，以及对图形的观察分析思路。重点是你的思维逻辑得到了提升！ 如果本 chat 对你有用，那我就太高兴了。最后，感谢大伙的支持！","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.littlewhale.xyz/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Runtime 到底是个什么鬼","slug":"iOSRuntime","date":"2020-01-07T03:31:19.000Z","updated":"2020-05-27T00:37:41.000Z","comments":true,"path":"2020/01/07/iOSRuntime/","link":"","permalink":"https://www.littlewhale.xyz/2020/01/07/iOSRuntime/","excerpt":"Runtime 到底是个什么鬼？Runtime是Objective-C中底层的一套C语言API，是一个将C语言转化为面向对象语言的拓展。Runtime的一切都围绕两个中心：类的动态配置 和 消息传递 能干啥？ 动态的在内存中创建一个类 给类增加一个属性 给类增加一个协议实现 给类增加一个方法实现IMP 遍历一个类的所有成员变量、属性和方法等 拦截系统自带的方法调用（Method Swizzling黑魔法） 将某些OC代码转化为Runtime代码，探究底层。如block的实现原理 实现给分类增加属性 实现NSCoding的自动归档和接档 实现字典的模型和自动转换","text":"Runtime 到底是个什么鬼？Runtime是Objective-C中底层的一套C语言API，是一个将C语言转化为面向对象语言的拓展。Runtime的一切都围绕两个中心：类的动态配置 和 消息传递 能干啥？ 动态的在内存中创建一个类 给类增加一个属性 给类增加一个协议实现 给类增加一个方法实现IMP 遍历一个类的所有成员变量、属性和方法等 拦截系统自带的方法调用（Method Swizzling黑魔法） 将某些OC代码转化为Runtime代码，探究底层。如block的实现原理 实现给分类增加属性 实现NSCoding的自动归档和接档 实现字典的模型和自动转换 基本元素的认识 class 和 id 都被称为类对象。 selector 可以理解为方法的ID, 通过 @selector 可以找到方法的地址。 IMP是implementation 被称为 函数指针。 Method 代表类中的某个方法类型。 lvar 代表 实例变量类型。 objc_property_t 是属性。 定义一个属性：typedef struct objc_property *objc_property_t; Category 分类。 可动态为已知类添加新的方法。 消息的传递过程调用实例方法时，它会首先在自身isa指针指向的类（class）methodLists中查找该方法，如果找不到则会通过class的super_class指针找到父类的类对象结构体，然后从methodLists中查找该方法，如果仍找不到则继续通过super_class向上查找知道metaclass 实现例子1234567891011121314&#x2F;&#x2F; 遍历类中所有的变量-(void) getALLVariable&#123; unsigned int count &#x3D; 0; Ivar *allVariables &#x3D; class_copyIvarList([Student class], &amp;count); for (int i &#x3D; 0 ; i&lt; count; i++) &#123; &#x2F;&#x2F;遍历每一个变量,包括名称和类型 Ivar ivar &#x3D; allVariables[i]; const char *VariableName &#x3D; ivar_getName(ivar); const char *VariableType &#x3D; ivar_getTypeEncoding(ivar); NSLog(@&quot;(Name:%s)-------(Type:%s)&quot;,VariableName,VariableType); &#125;&#125; 若是想遍历属性列表可以将class_copyIvarList替换为class_copyPropertyList。 12345678910111213141516&#x2F;&#x2F;遍历类的方法-(void) getAllMethod&#123; unsigned int count &#x3D; 0; Method *AllMethods &#x3D; class_copyMethodList([Student class], &amp;count); for (int i &#x3D; 0 ; i&lt;count; i++) &#123; Method method &#x3D; AllMethods[i]; &#x2F;&#x2F;获取SEL：SEL类型,即获取方法选择器@selector() SEL sel &#x3D; method_getName(method); &#x2F;&#x2F;得到sel的方法名：以字符串格式获取sel的name，也即@selector()中的方法名称 const char *methodName &#x3D; sel_getName(sel); NSLog(@&quot;-------the method :%s&quot;,methodName); &#125;&#125; 动态改变一个类变量的数值123456789101112131415161718&#x2F;&#x2F;改变Person变量的数值-(void) changeVariable&#123; NSLog(@&quot;before change person : %@ -------&quot;,_person); unsigned int count &#x3D; 0; Ivar *allList &#x3D; class_copyIvarList([Person class], &amp;count); for (int i &#x3D; 0; i&lt; count; i++) &#123; Ivar var &#x3D; allList[i]; const char *varName &#x3D; ivar_getName(var); NSString *name &#x3D; [NSString stringWithUTF8String:varName]; if ([name isEqualToString:@&quot;_name&quot;]) &#123; object_setIvar(_person, var, @&quot;lannis&quot;); &#125; &#125; NSLog(@&quot;after change person : %@ -------&quot;,_person);&#125; 动态添加方法12345678910111213-(void) addMethod&#123; class_addMethod([self class], @selector(addfunc3), (IMP)func3, &quot;v@:&quot;); if ([self respondsToSelector:@selector(addfunc3)]) &#123; [self performSelector:@selector(addfunc3)]; &#125;else&#123; NSLog(@&quot;add method error&quot;); &#125;&#125;void func3(id self,SEL _cmd)&#123; NSLog(@&quot;%s&quot;,__func__);&#125; 调用class_addMethod(__unsafe_unretained Class cls, SEL name, IMP imp, const char *types)方法给指定类添加方法。imp参数：实现被添加方法的函数，在本例中func3是指func3的地址指针；types参数：一个定义该函数返回值类型和参数类型的字符串。本例中”v@:”意思是v代表无返回值void，@代表id sel；：代表SEL _cmd；要注意的是：func3方法前的void不加+、-号，因为这是C的代码；必须有指定两个参数（id self，SEL _cmd）； 动态交换方法将存在的两个方法的实现进行交换 123456-(void) exchangeImplementations&#123; Method m1 &#x3D; class_getInstanceMethod([Person class], @selector(func1)); Method m2 &#x3D; class_getInstanceMethod([Person class], @selector(func2)); method_exchangeImplementations(m1, m2);&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"TextView富文本插入图片","slug":"textViewPicture","date":"2020-01-07T03:26:39.000Z","updated":"2020-05-27T00:36:02.000Z","comments":true,"path":"2020/01/07/textViewPicture/","link":"","permalink":"https://www.littlewhale.xyz/2020/01/07/textViewPicture/","excerpt":"welcome look this NoteTextView Small Demo l., you can use NoteTextView insertPicture that you can process the data to your server. also, it will not be hide TextView ‘s point position by keyboard . ok , just try . you can find it on my github.com/gaoyingqiu.","text":"welcome look this NoteTextView Small Demo l., you can use NoteTextView insertPicture that you can process the data to your server. also, it will not be hide TextView ‘s point position by keyboard . ok , just try . you can find it on my github.com/gaoyingqiu. Quick Start图片插入textView中，对数据进行分割。解决textView在tableView 中键盘遮挡问题。 show you screen photos .","categories":[{"name":"技术","slug":"技术","permalink":"https://www.littlewhale.xyz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"富文本","slug":"富文本","permalink":"https://www.littlewhale.xyz/tags/%E5%AF%8C%E6%96%87%E6%9C%AC/"}]},{"title":"iOS中高级阶段路线图","slug":"iOSAdvancedRoute","date":"2020-01-07T03:25:46.000Z","updated":"2020-05-27T00:39:36.000Z","comments":true,"path":"2020/01/07/iOSAdvancedRoute/","link":"","permalink":"https://www.littlewhale.xyz/2020/01/07/iOSAdvancedRoute/","excerpt":"1、iOS 11之前的导航栏的高度是64px（状态条+导航栏），iOS11之后如果设置了prefersLargeTitles = YES（默认NO）则为96pt。所以一般不用管。 2、在iOS 11上运行tableView向下偏移64px或者20px，因为iOS 11废弃了automaticallyAdjustsScrollViewInsets，而是给UIScrollView增加了contentInsetAdjustmentBehavior属性。避免这个坑的方法是要判断 3、tableView的sectionHeader、sectionFooter高度与设置不符，因为tableView的estimatedRowHeight、estimatedSectionHeaderHeight、 estimatedSectionFooterHeight三个高度估算属性由默认的0变成了UITableViewAutomaticDimension。最简单的方法就是直接设置为0。 4、iPhone X状态条由20px变成了44px，UITabBar由49px变成了83px。设置布局时y直接写成64的就要根据机型设置。可以设置宏 #define Device_Is_iPhoneX ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1125, 2436), [[UIScreen mainScreen] currentMode].size) : NO)， 推送模块，推送消息存储 H5 的webView 跳转 与原生交互。 图片压缩缓存。 发表话题。","text":"1、iOS 11之前的导航栏的高度是64px（状态条+导航栏），iOS11之后如果设置了prefersLargeTitles = YES（默认NO）则为96pt。所以一般不用管。 2、在iOS 11上运行tableView向下偏移64px或者20px，因为iOS 11废弃了automaticallyAdjustsScrollViewInsets，而是给UIScrollView增加了contentInsetAdjustmentBehavior属性。避免这个坑的方法是要判断 3、tableView的sectionHeader、sectionFooter高度与设置不符，因为tableView的estimatedRowHeight、estimatedSectionHeaderHeight、 estimatedSectionFooterHeight三个高度估算属性由默认的0变成了UITableViewAutomaticDimension。最简单的方法就是直接设置为0。 4、iPhone X状态条由20px变成了44px，UITabBar由49px变成了83px。设置布局时y直接写成64的就要根据机型设置。可以设置宏 #define Device_Is_iPhoneX ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1125, 2436), [[UIScreen mainScreen] currentMode].size) : NO)， 推送模块，推送消息存储 H5 的webView 跳转 与原生交互。 图片压缩缓存。 发表话题。 （自定义控件） 1）图片编辑， 富文本操作 3）话题处理； (正则表达式) （媒体库操作） 2）音频，直播 ,相机美颜等技术 3) 蓝牙 操作 4）设计模式 阅读CYLTabBarController YYCache 中级知识点 设计模式 UIScrollView/UITableView/UICollectionView 的嵌套 动态行高 通知/代理/block 程序启动原理 触摸事件/手势 图文混编 Runtime NSRunLoop GCD ReactiveCocoa开发 3DTouch 界面渲染 Charles花瓶抓包 区分模拟器/真机项目 常用知识 多线程 ，网络请求；；推送/远程推送 源代码管理Git 苹果内购/广告 音频/视频/二维码 蓝牙/传感器 物理仿真器UIDynamic iOS高级知识点 iOS高级知识点 Socket XMPP 加密 MD5详解 Base64加密解密 RSA非对称加密 AES对称加密 音频 基础 Core Audio Audio Toolbox OpenAL AVFoundation Speex语音聊天 AudioQueue/AudioSession Speex简介 视频 AAC视频.H264推流 P2P传输 直播 直播的技术分析与实现 RTMP协议 RTMP直播应用与延时分析 如果做一款inke版的App 推流发布和播放RTMP FFmpeg 基于FFmpeg的推流器 HLS流媒体传输协议(HTTP Live Streaming) FFmpeg ijkPlayer 算法 简介 冒泡排序 快速排序 插入排序 归并排序 二分查找 希尔排序 动态规划 堆排序","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"HTTP协议详解","slug":"http","date":"2020-01-07T03:25:30.000Z","updated":"2020-05-27T00:41:56.000Z","comments":true,"path":"2020/01/07/http/","link":"","permalink":"https://www.littlewhale.xyz/2020/01/07/http/","excerpt":"","text":"请求头 请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息，如Host: 主机名， Use-Agent: 浏览器基本资料， Accept: 浏览器能够识别的响应类型， Accept-Language: 浏览器默认语言， Accept-Encoding: 浏览器能够识别的压缩方式， Referer: 来路页面， Connecton：是否保持连接。 GET GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），如果数据是英文字母/数字，原样发送；如果是空格，转换为+；如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 限制GET:特定浏览器和服务器对URL长度有限制. POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置 http请求content-Typeapplication/x-www-form-urlencoded：数据被编码为名称/值对。这是标准的编码格式。这种方式用的比较多。 multipart/form-data： 数据被编码为一条消息，页上的每个控件对应消息中的一个部分。一般上传文件才会使用这种方式。 text/plain： 数据以纯文本形式(text/json/xml/html)进行编码，其中不含任何控件或格式字符。一般向服务端发送json数据会使用这种方式。 HTTPS数据加密 HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.littlewhale.xyz/tags/HTTP/"}]},{"title":"iOS初级阶段","slug":"iOSPrimaryRoute","date":"2020-01-07T03:24:45.000Z","updated":"2020-05-27T00:40:51.000Z","comments":true,"path":"2020/01/07/iOSPrimaryRoute/","link":"","permalink":"https://www.littlewhale.xyz/2020/01/07/iOSPrimaryRoute/","excerpt":"苹果自带框架 第三方框架 AFNetworking SDAutoLayout YYKit SDWebImage MJRefresh MJExtension Bugly Qiniu Masonry TZImagePickerController Hyphenate_CN","text":"苹果自带框架 第三方框架 AFNetworking SDAutoLayout YYKit SDWebImage MJRefresh MJExtension Bugly Qiniu Masonry TZImagePickerController Hyphenate_CN 基础UI控件 UILabel 标题栏 UIButton 按钮 UIImageView 图片视图 UITextField 文本输入框 UITextView 文本展示视图 UIProgressView 进度条 UISlider 滑动开关 UIGesture 手势 UIActivityIndicator 菊花控件 UIAlertView(iOS8废除) 警告框 UIActionSheet(iOS8废除) 操作表单 UIAlertController(iOS8出现) 警告视图控制器 UIScrollView 滚动视图 UIPageControl 页面控制器 UISearchBar 搜索框 UITableView 表视图 UICollectionView集合视图 UIWebView网页浏览器 UISwitch开关 UISegmentControl选择按钮 UIPickerView选择器 UIDatePicker日期选择器 UIToolbar工具栏 UINavigationBar通知栏 UINavigationController通知视图控制器 UITabbarController选择视图控制器 UIImagePickerController相册 UIImage图片 Xcode的使用 基础操作 状态栏 偏好设置 Xcode Source Control 源代码管理器 Xcode workSpace工作组 Xcode Scheme 计划 Xcode AutoLayout 约束 Xcode CoreData数据库 LLDB 断点调试 StoryBoard 界面预览 界面适配 内存监测 全局断点 全局搜索替换 数据存储 plist NSKeyedArchiver SQLite FMDB CoreData NSUserDefault 沙盒存储 NSDictionary归档 App生命周期 应用生命周期 控制器生命周期 alloc init 创建View ViewDidLoad ViewWillAppear ViewDidAppear ViewWillDisappear 视图将要消失 (做一些视图将要消失时的UI的处理) ViewDidDisappear 视图已经消失 (做一些视图消失之后数据的处理) viewDidDisappear销毁定时器 dealloc didReceiveMemoryWarning 通信 NS系列 宏定义 视图层次 切换视图 深浅拷贝 对象序列化 写入文件 获取沙盒路径 翻转视图 延伸视图 九大基本数据类型 九宫格 坐标比较 UIColor 、CIColor和CGColor 之间的关系 画图 静态变量 tag值 延时执行方法 界面旋转+状态栏隐藏 plist文件 KVC/KVO 谓词NSPredicate 帧动画 AutoLayout isKindOfClass 与 isMemberOfClass Return/Break/Continue Core Animation CALayer Quartz2D 真机调试 静态库 内存管理 iPad与iPhone的区别 响应链 异常捕捉 国际化 代码模块化 类别/扩展","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"找出字符串最长单词","slug":"longWord","date":"2019-12-10T10:52:26.000Z","updated":"2020-05-27T00:46:56.000Z","comments":true,"path":"2019/12/10/longWord/","link":"","permalink":"https://www.littlewhale.xyz/2019/12/10/longWord/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233#include &lt;string.h&gt;void countWords()&#123; char str[100] = \"hello, my name is gaogaoProgramer, welcome to come here!\"; int index; long len = strlen(str); int spaceIndex = 0; //从第一个下标开始算 int recordMax = 0; //单词空格之间下标最大差即为最长单词 int beforeIndex = 0,afterIndex = 0; //定义最长单词的前空格，后空格 for(index = 0; index &lt; len; index++)&#123; if(str[index] == 32)&#123; //判断空格 if(index - spaceIndex &gt; recordMax)&#123; recordMax = index - spaceIndex; //记录前下标和后下标。 beforeIndex = spaceIndex; afterIndex = index; &#125; spaceIndex = index; &#125; &#125; printf(\"原始单词为：%s\",str); printf(\"\\n单词空格之间下标最大差:%d 前下标:%d,后下标:%d\",recordMax,beforeIndex,afterIndex); //输出找到的单词； printf(\"\\n\\n找到的最长度单词为：\"); int charIndex; for(charIndex = beforeIndex; charIndex&lt; afterIndex ; charIndex++)&#123; printf(\"%c\",str[charIndex]); &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.littlewhale.xyz/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"促销方式","slug":"promotionMethod","date":"2019-12-10T10:36:56.000Z","updated":"2020-05-27T00:58:06.000Z","comments":true,"path":"2019/12/10/promotionMethod/","link":"","permalink":"https://www.littlewhale.xyz/2019/12/10/promotionMethod/","excerpt":"","text":"","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"职场硬核与软实力","slug":"softPower","date":"2019-12-09T10:45:07.000Z","updated":"2020-05-27T00:46:14.000Z","comments":true,"path":"2019/12/09/softPower/","link":"","permalink":"https://www.littlewhale.xyz/2019/12/09/softPower/","excerpt":"我们的从事的大多数都是平凡工作。没有科学家在实验室科研的高科技创新，没有宇宙航天科技探索的奥秘。或许每天都做着重复单一的工作，或许很多岗位都被智能自动化机器给替代。14年之后，很多企业都转型成移动互联网企业，很多线下店铺都实现了线上支付功能。我们不断接触着新事物和被新事物洗礼。 那些不愿意改变，不愿意学习新事物的企业和个人 都慢慢退出了历史舞台。","text":"我们的从事的大多数都是平凡工作。没有科学家在实验室科研的高科技创新，没有宇宙航天科技探索的奥秘。或许每天都做着重复单一的工作，或许很多岗位都被智能自动化机器给替代。14年之后，很多企业都转型成移动互联网企业，很多线下店铺都实现了线上支付功能。我们不断接触着新事物和被新事物洗礼。 那些不愿意改变，不愿意学习新事物的企业和个人 都慢慢退出了历史舞台。 尤其是IT行业从业人员，基本每年都有一次技术革新。新产物，新工种也逐渐生存在这个市场中。我们每天都要不断地学习新知识，为提升技术，为升职加薪垫定基础；如果不学习，我们将和新时代技术拖轨，被时代抛弃。 除了在专业技术过硬以外，在软技能方面我们通过这节Chat谈一谈。 信赖度依据：要求任何人做事，不论对上/对下还是平行，在没有卓越的表现可以预期的时候，我们就只能希望他/她“可靠” 1、可以严格要求自己按照指令或需求，完成他人交付的任务或工作。用心把事情做到完美。2、在执行任务或工作的过程中，多注意细节，能主动发现并报告“偏差”。3、在任务或工作没有完全结束以前，能始终保持注意力，不会松懈。4、任务或工作结束时，尽快告知对方并征询意见，如果有疏忽或差错，先道歉，并说明以后的防范方法。5、对所有不足或不懂的地方，会不断地问，不断地学。 洁净度美和整洁确实可以给自己个人形象加分。但我们在工作的洁净度上也可以给自己带来加分。 1、交付出去的文件/档案/物品/工作内容，一定要清清楚楚，一定要有条理，一定要仔细。2、不论任何东西，只要从我手中出去，自己先检查，先校对，先确认。3、每月，每周，每天做了什么，有什么结果，自己怎么想的，任何工作项自己都要有数据记录。 诚信度专业和高效可以提升我们的业绩。真诚信任可以给我们带来更多的用户和伙伴。通过信任的维持，我们可以把产品做得更好。管理层人员的筛选基本也是从最亲临的下属来进行提拔。因为基于信任，基于了解。 1、随时注意自己应该负责的工作，定期让部门主管知道。2、对与自己有关的一切工作，经常思考如何能把它做得更好。3、不要养成不好的工作习惯，以免他人怀疑你的专业性。4、不要总在背后议论，有话心平气和并大胆的说，眼睛没有看到的东西议论久了把自己容易把自己都骗了。 多面手1、除了应有的专业知识，还要广泛地涉猎一些和工作、有关的各种信息，并建立自己的知识库。2、在适当的时机，对工作相关的市场，产品、技术等问题，提出多元化的反思。3、工作之余培养其他的兴趣和能力，比如影视，动漫，运行，工艺，写作等。完全没有爱好的人，很难有突破性的创造力。4、尽量让人觉得不庸俗，不市侩，不短视，不肤浅（不要随随便便的提问，随随便便的讨论，多做功课，多了解清楚）。 身边典范少看成功学，多去了解你身边成功的人成功的事是怎么一点一点起来的。他们都不是单纯靠运气，仔细的找总会找到一两个特质，是你没有的。有一些你不去看，不去找，是无知。有一些你找到了，你做不到，是无能。你不做，永远是0，你做了至少能成为1，没有很多的1，永远不可能到10。 人才是什么？你给他一件事，他把它干好了；你又给他一件事他又把他干好了…… 学会承担个人责任为事情的结果负责，属于自己管辖区域的工作任务要能够数据追踪，对成功的结果要总结，对失败的结果要反思。在职场不要”努力地表现”，假装很努力；不要去辩解或甩锅。要认识到自己的错误，多观察别人的优点。 让自己成长总是说自己没有 条件(时间\\环境\\机会)去提高。这些都是给自己懒惰找的借口。不断挤出时间去学习。“努力地请教”，不断的逼自己去与人交流学习。结构化自己的知识体系，离目标还差多少。量化到每一天，每一周，每一月的计划中去。锻炼自己各方面的能力：包括学习能力，交流能力，组织能力，执行能力。 注重过程，关注结果平庸混日子的人总认为自己牛逼，想要高收入，想要高职位，想要高地位。实干的人总是在不断思考，不断收集情报，不断的学习，不断计划，不断实践，不断用结果向所有人证明自己的能力。你的想法决定了你的行动；你的行动 取决于你的习惯；你的习惯来源于你的性格； 学着用不同的方法去处理事情：对事不对人 或许80% 都是对的，但有时候的确需要对人对事去处理；当你是职场管理者时，管理不同性格的人可以采用不同的沟通方法。有的人心理比较脆弱，多次批评甚至都会离职走人。 每件事（人）都不一样，不要用同一种方式去处理所有的事（人） 创造价值不以工作时长为价值计算，以产出结果为价值计算。形成自我管理，主动学习，让之前的做事方法更加高效，创造更多的价值。不要总认为自己只能干一件事情，这个时代要的是多元化复合型人才。要好好学习，坚持充电补充自己的短板。 紧看目标，解决问题不要总描述困难，然后最后被困难给吓趴了而放弃自己的目标。要去克服困难，然后把事情干好。勿忘自己短、中、长期目标，并时刻询问自己。（你的长期目标是什么？中期目标是什么？短期目标是什么？）华为在中美贸易战的时候没有天天强调困难，而是自己制造芯片。利用这次机会扭转全球竞争的格局并真的取得成功。如果没有这次贸易战，可能还要落后业界大腕更多年份。 立场鲜明 立场鲜明，以事实结果为导向。 在工作上要有立场，工作与生活要分开，否则谁为目标负责？工作的时候展现出你的专业度，对工作负责，对客户负责。 不要纵容自己能力不足不是要去比谁最受欢迎，谁资历老，是要比谁能创造更大的价值。拒绝学习的人站在重要的位置上，对组织有欠公平。对自己要求低，社会对你的回馈会体现到你的收入低，地位低，职位低。就算你走了狗屎运，也难以服众。 什么时候求助大神？遇到难一点的工作任务，如果总是等待上司来指导。那就相当于放弃了成长。如果不想让别人的思想主动你的思维，那你只有不断努力训练自己的思维，用结果去证明自己。 思考的过程：1 、自己思考，分模块 要解决什么问题。2、 不懂的问题查找资料，再手动实践。3、查找网上别人做过的，参考。4、总结。 归类，整理。 记录（笔记，大脑），输出（文章，博客）。 只要你不断的努力的思考，努力的学习，努力的创造价值，终有一天你会把所有人甩出几条街，你自然成了企业的优秀人才。 成功是不断的努力加上机会，机会来了你是不是把握得住。而把握机会的实力你是否储存足够？你愿意努力多久，3年？5年？10年？一辈子？","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"软实力","slug":"软实力","permalink":"https://www.littlewhale.xyz/tags/%E8%BD%AF%E5%AE%9E%E5%8A%9B/"}]},{"title":"螺旋矩阵","slug":"spiralMatrix","date":"2019-12-08T01:09:04.000Z","updated":"2020-05-27T00:52:08.000Z","comments":true,"path":"2019/12/08/spiralMatrix/","link":"","permalink":"https://www.littlewhale.xyz/2019/12/08/spiralMatrix/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define len 9void luoxuan()&#123; int arr[len][len]; //开始初始化，给数组赋值0 for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;len;j++)&#123; arr[i][j] = 0; &#125; &#125; arr[0][0] = 1; //顶角确定了，我们可以算出第一行右边的数字 int circleTimes = len/2 + 1; int circelIndex = 0; //圈的数量 //赋值过程 while(circleTimes&gt;0)&#123; //测试时候，每一圈结束可以打印出看一下：&amp;&amp; circelIndex &lt;1 circelIndex ++; printf(\"第%d圈\\n\",circelIndex); for(int column = 1;column &lt;= len-circelIndex; column++)&#123; //往右排列 if(column &gt;= circelIndex-1)&#123; arr[circelIndex-1][column] = arr[circelIndex -1][column-1] + 1; &#125; &#125; for(int row = circelIndex; row&lt;= len-circelIndex; row++)&#123; //往下排列，从第二行，第X-i 列开始 arr[row][len-circelIndex] = arr[row-1][len-circelIndex] + 1; &#125; for(int column = len-circelIndex-1; column &gt;= circelIndex-1; column--)&#123; //往左排，下标递减1，值为后一个 + 1 arr[len-circelIndex][column] = arr[len-circelIndex][column+1] + 1; &#125; for(int row =len-circelIndex-1; row &gt; circelIndex-1; row--)&#123; //往上排列 arr[row][circelIndex-1] = arr[row+1][circelIndex-1] + 1; &#125; circleTimes--; &#125; //输出二维数组 for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;len;j++)&#123; printf(\"%d\\t\",arr[i][j]); &#125; printf(\"\\n\\n\"); &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.littlewhale.xyz/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"沪江-C语言课程精选32讲","slug":"hujiang_classC","date":"2019-12-06T02:41:30.000Z","updated":"2020-05-27T00:56:15.000Z","comments":true,"path":"2019/12/06/hujiang_classC/","link":"","permalink":"https://www.littlewhale.xyz/2019/12/06/hujiang_classC/","excerpt":"","text":"编程逻辑精选32讲沪江课程： 打卡鸭： 公众号： 高高编程小屋","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.littlewhale.xyz/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"iOS开发商品规格设置模块","slug":"iOSSku","date":"2019-12-06T01:55:20.000Z","updated":"2020-05-27T01:14:35.000Z","comments":true,"path":"2019/12/06/iOSSku/","link":"","permalink":"https://www.littlewhale.xyz/2019/12/06/iOSSku/","excerpt":"前言SKU百度百科为 库存保有单位 （Stock keeping Unit 或者SKU）是对每一个产品和服务的唯一标示符。 也就是说sku 为商品对应的很多种类规格情况下的 库存，价格 各有不同。需要通过sku 这样一种组合结构存储这些计量值。在移动电商时代，网购已然成为潮流。更是全民参与。每一年都有购物节 ： 京东618 , 淘宝天猫双11, 双12 。 一个淘宝店家月销售额30万背后 ，他的商品sku有上千种。 一个卖橱柜的，小到抽屉，拉篮，五金 ，把手，螺丝钉 都可以细分成很小的SKU。移动电商商品背后的SKU种类的复杂性。可正是因为商品SKU的多样化，才能商家带来巨量的销售额。 从详情页认识SKU123456789101112131415161718192021这个商品包含的SKU信息:&#123; 规格类型:[&#123; 尺寸:[XS, S， M, L，XL， XXL] &#125;,&#123; 颜色: [白色，珊瑚粉，草木绿] &#125;], 规格明细组合描述: &#123; XS-白色:&#123; 图片: 图片url, 价格: ￥328, 库存: 188件, 扩展..字段: 值 &#125;, 其他规格组合:&#123; 图片: 图片url, 价格: 价格.., 库存: 库存数量.., 扩展..字段: 值 &#125; &#125;&#125;","text":"前言SKU百度百科为 库存保有单位 （Stock keeping Unit 或者SKU）是对每一个产品和服务的唯一标示符。 也就是说sku 为商品对应的很多种类规格情况下的 库存，价格 各有不同。需要通过sku 这样一种组合结构存储这些计量值。在移动电商时代，网购已然成为潮流。更是全民参与。每一年都有购物节 ： 京东618 , 淘宝天猫双11, 双12 。 一个淘宝店家月销售额30万背后 ，他的商品sku有上千种。 一个卖橱柜的，小到抽屉，拉篮，五金 ，把手，螺丝钉 都可以细分成很小的SKU。移动电商商品背后的SKU种类的复杂性。可正是因为商品SKU的多样化，才能商家带来巨量的销售额。 从详情页认识SKU123456789101112131415161718192021这个商品包含的SKU信息:&#123; 规格类型:[&#123; 尺寸:[XS, S， M, L，XL， XXL] &#125;,&#123; 颜色: [白色，珊瑚粉，草木绿] &#125;], 规格明细组合描述: &#123; XS-白色:&#123; 图片: 图片url, 价格: ￥328, 库存: 188件, 扩展..字段: 值 &#125;, 其他规格组合:&#123; 图片: 图片url, 价格: 价格.., 库存: 库存数量.., 扩展..字段: 值 &#125; &#125;&#125; SKU功能操作流程图说明 新增商品SKU1) 从规格容器中选择需要的规格。已选择的规格类型也可移除。2) 在已选规格类型下 可新增规格属性。已新增的规格属性可选中或取消。3) 规格属性的选择或取消 触发自有组合排列。生成规格明细的表单。4) 填写规格明细 单项填写： 挨个填写，过滤条件填写。 批量填写。5) 提交sku明细项数据。 修改商品SKU1) 加载已选择的规格类型属性； 注意：根据业务控制已选规格类型 是否可新增 ，是否可删除的条件，因为直接涉及到规格明细的排列组合结构。 当商品库的某商品已经在店铺上线了，如果再新增规格类型的话，排列组合将改变，之前设置的价格和库存都会跟着改变。所以不可以再新增或删减规格类型。 2) 自由排列组合 ，把各项值 赋值到规格明细表中。3) 修改数据后，重新提交SKU 的明细表单。 修改SKU的场景1) 以衣服为例：白色 + M 卖完的时候，在规格sku 修改的时候，可以把已选的颜色为白色去掉。2) 以手机 为例：由于热销，厂家又上了 升级版本玫瑰金色。可新增一个玫瑰金色再设置相应的价格。 1、技术讲解1.1 服务器下发的Json数据结构123456789101112131415161718//注释： 服务器返回的商品规格类型属性。用于页面头部显示已选的规格类型，和其属性。&#123; type : 101, //规格类型id值。 name : 颜色, types : [ &#123; propertyId : 123255, //属性值唯一Id值 propertyCatId : 101, state : 1, //记录是否被选中该颜色 name : 绿色 &#125;, &#123; propertyId : 123254, propertyCatId : 101, state : 1, name : 白色 &#125;]&#125; 1234567891011121314151617181920//规格明细描述 结构,用于SKU 编辑的时候，把规格明细各项组合数据 填充到表单。skuDesc : [&#123; skuId : 167977, //sku项 id productId : 166224, //商品id price : 334, //普通售价 groupPrice :300, //拼团售价 image : https://cdn.gaogao.com/image/e0ecd00c2sw2f23f29df6d504987d60d.png, //图片 properties : 101:123253-102:123257 //规格属性 自由组合排列值&#125;,&#123; skuId : 167971, productId : 166224, price : 200, groupPrice : 188, image : https://cdn.gaogao.com/image/e0ecd00c2d5f442c49df6d504987d60d.png, properties : 101:123253-102:123258&#125;] 123456789//向服务器提交某商品的SKU 规格明细数据:product_id : 176294; //商品idproperties : [ //规格属性排列组合项&#123;\"price\":100,\"groupPrice\":88,\"properties\":\"11:167918-101:123253-102:123259\"&#125;,&#123;\"price\":100,\"groupPrice\":88,\"properties\":\"11:172957-101:123253-102:123259\"&#125;,&#123;\"price\":100,\"groupPrice\":88,\"properties\":\"11:167918-101:123253-102:123258\"&#125;]; 说明:先根据已选的 规格大类型propertyCatId 值排序。 这样做的原因是：无论 A+B+C ，B+A+C 或 C+A+B 都是表示同一种SKU组合。以 “11:167918-101:123253-102:123259” 为列，根据规格大类型id值排序。 最终都以 A：aa+B:bb+C:cc 组合提交给服务器, 以此来维护该组合对应的价格和库存； 2、页面组成2.1 页面全局变量NSMutableArray datas; //规格明细列表：排列组合的数据源NSMutableArray sectionMenuArr; //记录选中的大类型；NSMutableDictionary itemArrDic; //map 存放key:为id , 值为已选的规格类型对象NSMutableDictionary itemSelectedArrDic; //已选的规格类型下的规格属性数组。 2.2 构建一个树结构根据提交给服务器的组合字符窜如 “11:167918-101:123253-102:123258”, 这个是一个有三个层级表示的SKU 组合。举例：天猫购买手机，加入购物车的时候选择 内存：64g + 颜色：白色 + 套餐类型： 官方标配其中包含内容：1）规格大类型要先排好序 ，属性要一一对应类型。 三个层级的SKU组合应该比较常见。通过这里，我们构件一个model实体。结构如下：1234567891011121314151617@interface ConditionFilter : NSObject&lt;NSCopying,NSMutableCopying&gt;@property(nonatomic,assign) NSInteger value; // id值@property(nonatomic,strong) NSString *name; //名称@property(nonatomic,copy) NSArray&lt;ConditionFilter&gt; *statusItem; //子级@property(nonatomic,assign) NSInteger state; //选中状态： 1已选择 0未选择@property(nonatomic,strong) NSString * propertyCatId; //规格类型： 一级分类的id@property(nonatomic,strong) NSString * propertyId; //规格属性： 二级分类id@property(nonatomic,strong) NSString * pid; //父节点编号(随机生成)@property(nonatomic,strong) NSString * nodeId; //节点编号(随机生成)@property(nonatomic,strong) ConditionFilter *parent; //父节点（父只有一个）@property(nonatomic,assign) BOOL extend; //是否展开@property(nonatomic,assign) NSInteger level;//当前层级@end 2.3 根据已选的规格类型 自由排列组合 出明细列表各项组合数据12345678910111213141516171819202122232425262728293031323334353637383940#pragma mark - 从最后一个层级算起；往父类赋值；(核心: 给statusItem赋值)-(void)configDataSectionReload&#123; //先把已选择的大类，过滤出已选择的属性项的大类 NSMutableArray *hasChooseSectionMenuArr = [[NSMutableArray alloc] init]; for(ConditionFilter *sectionMenu in self.sectionMenuArr)&#123; NSArray * itemChooseArr = [self.itemSelectedArrDic objectForKey:@(sectionMenu.value)]; if(itemChooseArr.count)&#123; [hasChooseSectionMenuArr addObject:@(sectionMenu.value)]; &#125; &#125; //确定树的层级：为选择的已选大类型个数。并绑定子节点集合statusItem NSMutableArray *childArr = nil; for (NSInteger level = hasChooseSectionMenuArr.count; level&gt;0; level -- ) &#123; NSNumber *cellSectionTag = [hasChooseSectionMenuArr objectAtIndex:level-1]; //可变集合的copy 和 mutableCopy 是一样；深拷贝，地址不一样；如果不用copy会造成多个地方引用地址对象；值会随着关联； NSMutableArray *itemSelectArr = [[self.itemSelectedArrDic objectForKey:cellSectionTag] mutableCopy]; for(NSInteger i=0; i&lt; itemSelectArr.count; i++)&#123; ConditionFilter *item = [itemSelectArr objectAtIndex:i]; item.level = level; //标记等级 item.extend = NO; item.nodeId = nil; item.pid = nil; //（这里使用拷贝），为子节点赋值。 item.statusItem = [[NSMutableArray alloc] initWithArray:childArr copyItems:YES]; &#125; childArr = [itemSelectArr mutableCopy]; //（防止对childArr的来源数据源污染,这里使用拷贝）（fillParentNodeId 会对数据源childArr 进行污染；如改变对象的name等设置） &#125; //清空 [self.datas removeAllObjects]; //填充子节点绑定父节点pid; childArr是形成的一颗树结构。 [self fillParentNodeId:childArr parentNode:nil];&#125; 12345678910111213141516171819202122232425262728293031323334353637#pragma mark - 从前往后赋值（ 给子节点绑定标识父类parent）,用于拼装properties 组合的id字符窜-(void)fillParentNodeId:(NSArray *)itemArr parentNode:(ConditionFilter *)parent&#123; for(NSInteger i =0 ;i &lt; itemArr.count; i++)&#123; ConditionFilter *filter = [itemArr objectAtIndex:i]; filter.pid = parent.nodeId; filter.parent = parent; //绑定父级节点 NSString *nodeStr = [NSString uniqueStringForMessage]; filter.nodeId = nodeStr; filter.extend = filter.statusItem.count; if(self.dataShowLayoutStyle == LayoutComposeStyle)&#123; //排列组合样式； if(filter.statusItem.count == 0)&#123; //根据statusItem等于0 设置层级为1级的时候name值 组合成: 白色+XL , 白色+L 格式；赋值给最后一个层级models的name属性 NSMutableArray *allJoinNamesArr = [[NSMutableArray alloc] init]; [allJoinNamesArr addObject:filter.name]; ConditionFilter *parent = filter.parent; while (parent) &#123; [allJoinNamesArr insertObject:parent.name atIndex:0]; parent = parent.parent; &#125; NSString *allJoinName = [allJoinNamesArr componentsJoinedByString:@\"+\"]; filter.name = allJoinName; //拼接UI显示的name filter.level = 1; //排列组合样式都为1级UI显示的间距.（label显示时候的左边距） [self.datas addObject:filter]; //只添加最后一个层级； &#125; &#125;else&#123; //树层级 样式（全部添加） [self.datas addObject:filter]; &#125; //递归 [self fillParentNodeId:filter.statusItem parentNode:filter]; &#125;&#125; 2.4 自由排列组合 ，把各项值 赋值到规格明细表中先把各项值赋值给SKUModel ，存到根据排列组合字符窜为key ，存放到map中。12345678910111213141516171819202122//设置SKU值NSArray *skuArr = [response.responseObject objectForKey:@\"sku\"];for(NSInteger i=0 ;i &lt;self.datas.count; i++)&#123; ConditionFilter *filter = [self.datas objectAtIndex:i]; NSString *storeCellKey = filter.name; NSString *properties = [self processPropertiesByFilter:filter]; //找到sku 设置信息； for(SkuDetailModel *sku in skuArr)&#123; if([sku.properties isEqualToString:properties])&#123; SKUModel *writeSku = [[SKUModel alloc] init]; writeSku.properties = sku.properties; writeSku.groupPrice = sku.groupPrice; writeSku.price = sku.price; writeSku.image = sku.image; [self.writeFieldBoxDic setObject:writeSku forKey:storeCellKey]; break; &#125; &#125;&#125; 2.5 properties的自由组合id值拼接循环取出其父节点. 记录大类型：属性 格式。 根据key 排序，拼接成 A:aa - B:bb - C:cc 格式1234567891011121314151617181920212223242526272829#pragma mark - 处理每行规格填写的 普通价和拼团价 返回 sku的组合properties值-(NSString *)processPropertiesByFilter:(ConditionFilter *)filter&#123; NSMutableDictionary *mDic = [[NSMutableDictionary alloc] init]; [mDic setObject:filter.propertyId forKey:filter.propertyCatId]; ConditionFilter *parent = filter.parent; while (parent) &#123; [mDic setObject:parent.propertyId forKey:parent.propertyCatId]; parent = parent.parent; &#125; //排序 NSArray *keyArr = [mDic.allKeys sortedArrayUsingComparator:^NSComparisonResult(id _Nonnull obj1, id _Nonnull obj2) &#123; NSNumber *num1 = [NSNumber numberWithInteger:[obj1 integerValue]]; NSNumber *num2 = [NSNumber numberWithInteger:[obj2 integerValue]]; NSComparisonResult result = [num1 compare:num2]; return result == NSOrderedDescending; // 升序 &#125;]; NSMutableArray *joinStrArr = [[NSMutableArray alloc] init]; for(NSString *key in keyArr)&#123; NSString *str = [NSString stringWithFormat:@\"%@:%@\",key,[mDic objectForKey:key]]; [joinStrArr addObject:str]; &#125; NSString *properties = [joinStrArr componentsJoinedByString:@\"-\"]; return properties;&#125; 2.6 列表的UI显示： tableView相关委托1234567891011121314151617181920212223242526272829//共两个分组。第一个分组展示选择的规格类型。 第二个分组是规格明细表单项-(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123; return self.sectionMenuArr.count + 1;&#125;//当为第二个分组时,显示的行数为排列组合数-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; if(section == self.sectionMenuArr.count)&#123; return self.datas.count; &#125; return 1;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; if(indexPath.section == self.sectionMenuArr.count)&#123; //排列组合的Cell显示 //排列组合的名字 ConditionFilter *filter = [self.datas objectAtIndex:indexPath.row]; cell.nameLabel.text = filter.name; //某一排列组合名称对应的 skuModel 记录的表单值和properties值 SKUModel *sku = [self.writeFieldBoxDic objectForKey:filter.name]; &#125;&#125; 2.7 修改规格明细 的表单值修改每一个明细项的时候，可对应根据TextFieldValueChange 事件变化，把值赋值给每一项排列组合的key对应的skuModel中。skuModel对象: {“price”:100,”groupPrice”:88,”properties”:”11:167918-101:123253-102:123259”}准备一个字典或map：writeFieldBoxDic 根据排列组合的字符窜 “A+B+C”作为key, skuModel作为value 存储；writeFieldBoxDic {“A+B+C”: skuModel…}cell 取值显示的时候，根据key 取得 skuModel 的值；field值改变得时候，根据key取得skuModel. 存在直接修改model的属性，不存在则创建一个新的skuModel 存到writeFieldBoxDic中； 2.8 提交的表单条件判断123456789101112131415161718192021222324-(void)submitAction&#123; BOOL needReturnFlag = NO; //是否需要阻止提醒； NSMutableArray *skuArr = [[NSMutableArray alloc] init]; for(NSInteger i=0; i&lt;self.datas.count; i++)&#123; ConditionFilter *filter = [self.datas objectAtIndex:i]; SKUModel *sku = [self.writeFieldBoxDic objectForKey:filter.name]; if(sku)&#123; [skuArr addObject:[sku mj_JSONObject]]; if(sku.price == nil || sku.groupPrice == nil)&#123; needReturnFlag = YES; break; &#125; &#125;else&#123; needReturnFlag = YES; &#125; &#125; if(needReturnFlag || skuArr.count == 0)&#123; [MBProgressHUD showMessage:@\"所有规格普通价需填写完整！\"]; return ; &#125; //...保存到服务器&#125; 3、业务：店铺商品和产品库关系图 说明产品库：只负责管理产品的价格：无论拼团价 还 是秒杀价，活动价 或普通价 都可统一在库中管理该规格明细信息。 这样做的目的是提供商品信息的复用。当在店铺上架一个商品时，不用每次都去创建一个全新的商品，可通过产品库进行选择添加。从商户角色进行区分： 个人开淘宝店模式：店铺需单独管理商品的库存, 运费的设置 是否包邮等信息。 厂家和连锁店模式：连锁店去库存只负责代销，无需管理库存和发货。当用户下单，统一指向厂家来发货。 厂家统计设置产品信息 ， 价格， 库存。 联盟的概念： 联盟设置好了商品。已加入联盟的商家可直接代销联盟总店的商品进行售卖，取得分佣。类似多多进宝，可售卖平台已存在的可分成的商品。 4、 技术总结 所有的重点在于建立树层级结构，根据已选的规格大类型循环其已选择的规格属性数组。通过ConditionFilter实体的属性statusItem 可以取到子节点ConditionFilter 的数组。 从最后一个层级一次往上一层级的节点赋值子节点数组statusItem。为防止对数据来源的污染，一定要使用深拷贝。深拷贝model 要实现NSCopying,NSMutableCopying 相关协议方法。 从向服务器提交每一项规格明细的组合项来看，我们对ConditionFilter 的属性parent 进行遍历，依次取得上一节点的相关属性，直到最上一级节点的parent 属性为null 的时候便停止拼接。properties的拼接就完成了。 在表单填写的时候，采取对存储的模型skuModel属性作更改。而每一项skuModel 所存储的map 字典的key 是由排列组合得到的UI显示的拼接字符窜。如商品手机： 64G+黑色+标准版。 方便在cell显示的时候直接读取。 UI交互上提供批量和条件过滤快速筛选 进行填写每一项明细的表单值。有利于商户高效填写设置sku 组合。 以下几个UI页面，仅供参考百度脑图：店铺商品 与 产品库 功能操作关系图 文章代码片段较多，但也都是技术核心部分。里面逻辑性较强，需要慢慢理解透彻。希望能对再看的你有所帮助。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.littlewhale.xyz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SKU","slug":"SKU","permalink":"https://www.littlewhale.xyz/tags/SKU/"}]},{"title":"SKU商品属性多级动态树","slug":"skuTree","date":"2019-04-25T07:56:01.000Z","updated":"2020-05-27T00:36:50.000Z","comments":true,"path":"2019/04/25/skuTree/","link":"","permalink":"https://www.littlewhale.xyz/2019/04/25/skuTree/","excerpt":"","text":"GYLevelTreeSKU 商品属性 价格或库存 设置； 动态多层级树，自由排列组合，递归，深拷贝,浅拷贝; 源码","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[{"name":"SKU","slug":"SKU","permalink":"https://www.littlewhale.xyz/tags/SKU/"}]},{"title":"自定义双向Slider选范围","slug":"doubleSliderRange","date":"2019-04-20T07:50:22.000Z","updated":"2020-05-27T00:44:49.000Z","comments":true,"path":"2019/04/20/doubleSliderRange/","link":"","permalink":"https://www.littlewhale.xyz/2019/04/20/doubleSliderRange/","excerpt":"","text":"GYSliderBar双向Slider, 选择范围控件；支持阶梯值滑动； 可用于筛选界面，筛选价格，其他业务等； 源码","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[{"name":"Slider","slug":"Slider","permalink":"https://www.littlewhale.xyz/tags/Slider/"}]},{"title":"2019年四月","slug":"2019_April","date":"2019-04-16T06:52:58.000Z","updated":"2020-05-27T00:59:37.000Z","comments":true,"path":"2019/04/16/2019_April/","link":"","permalink":"https://www.littlewhale.xyz/2019/04/16/2019_April/","excerpt":"","text":"时间在快马加鞭地前行，身边的人，在做的事，也都发生了变化；回顾过去一年，做过的项目不少，也经历了生命周期销毁的企业；那些盲目迭代没有思考力地堆砌功能对于用户来说是多余无用的，对于整个产品战略来说似乎渐渐步入深渊；过去一年的开发中，自己也变得被动，整个思考力和行为都被牵着走； “安分守己”一词 形容自己成了一个”标准“的职业码农，时间之河上，有一刻 似乎意识到脑洞齿轮已经生锈 转动缓慢，对，需要着手动起来了，起身，去做！","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://www.littlewhale.xyz/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"解决ScrollView嵌套多手势冲突问题","slug":"scrollViewNested","date":"2019-02-14T15:05:34.000Z","updated":"2020-05-27T00:54:37.000Z","comments":true,"path":"2019/02/14/scrollViewNested/","link":"","permalink":"https://www.littlewhale.xyz/2019/02/14/scrollViewNested/","excerpt":"","text":"嵌套ScrollView, ScrollView嵌套CollectView, Tab随内容固定滑动到顶部，解决UIScrollView 多手势冲突； ScrollView 嵌套ScrollView ScrollView 嵌套CollectionView Demo 源码Demo源码","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"自定义日期选择视图","slug":"customerDatePicker","date":"2019-02-11T10:06:24.000Z","updated":"2020-05-27T00:45:07.000Z","comments":true,"path":"2019/02/11/customerDatePicker/","link":"","permalink":"https://www.littlewhale.xyz/2019/02/11/customerDatePicker/","excerpt":"","text":"自定义日期选择视图 Demo 源码Demo源码","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[{"name":"DatePicker","slug":"DatePicker","permalink":"https://www.littlewhale.xyz/tags/DatePicker/"}]},{"title":"转盘抽奖小功能","slug":"sweepstakes","date":"2019-02-09T13:02:48.000Z","updated":"2020-05-27T00:45:29.000Z","comments":true,"path":"2019/02/09/sweepstakes/","link":"","permalink":"https://www.littlewhale.xyz/2019/02/09/sweepstakes/","excerpt":"抽奖功能模块源码产品出发点1、通过动态抽奖数据和排行激发用户抽奖消费；2、通过技能和宝石等以及转盘的燃爆值，中奖率翻倍等等吸引用户；3、根本上是为了激发用户活跃性以及刺激消费 技术难点1、抽奖转盘分为两种转盘，业务逻辑分一个parentVC 管理两个 子 VC；2、抽奖奖品服务端返回，显示在每一个扇形区域的中间，金额同似；3、点击抽奖，拿到奖品id, 找出是在转盘中的哪个区域，让转盘指针停止在那一区域；4、抽奖动态弹幕；5、燃烧值 和 倒计时的控制； 业务操作说明1、两个转盘，某个转盘点击开始抽奖 互不影响； 黄金转盘具有宝箱和技能；2、每抽取一次，扣除相应的金额，如有中奖，则弹出中奖奖品；抽奖分为单次，十连抽，三十连抽等；3、抽奖后产生记录；在记录中可看到每次抽奖消费情况；4、转盘有燃烧值，当满时候，触发倒计时3分钟，倒计时内 中奖率将翻倍；5、燃烧值每3秒刷新一次，当中途离开再次打开，则拿到最新倒计时显示；6、弹幕从最新100条记录 每隔2秒随机生成一条记录； 模块设计1、整个框架布局在一个 MainVC中控制转盘类型，请求余额，通知等刷新金额； 管理childVC ；2、childVC 中 处理抽奖业务逻辑；UI 布局，抽奖请求， 燃烧值处理，弹幕处理；3、其他功能性子View 单独自定义视图； 转盘视图，燃烧值进度视图，倒计时进度视图， 弹窗类视图；弹幕视图；4、弹窗类视图 以一个ParentView公共视图容器 ，其中子视图由枚举参数值控制自定义；有玩法视图，记录视图，保险视图，技能视图，排行榜视图；","text":"抽奖功能模块源码产品出发点1、通过动态抽奖数据和排行激发用户抽奖消费；2、通过技能和宝石等以及转盘的燃爆值，中奖率翻倍等等吸引用户；3、根本上是为了激发用户活跃性以及刺激消费 技术难点1、抽奖转盘分为两种转盘，业务逻辑分一个parentVC 管理两个 子 VC；2、抽奖奖品服务端返回，显示在每一个扇形区域的中间，金额同似；3、点击抽奖，拿到奖品id, 找出是在转盘中的哪个区域，让转盘指针停止在那一区域；4、抽奖动态弹幕；5、燃烧值 和 倒计时的控制； 业务操作说明1、两个转盘，某个转盘点击开始抽奖 互不影响； 黄金转盘具有宝箱和技能；2、每抽取一次，扣除相应的金额，如有中奖，则弹出中奖奖品；抽奖分为单次，十连抽，三十连抽等；3、抽奖后产生记录；在记录中可看到每次抽奖消费情况；4、转盘有燃烧值，当满时候，触发倒计时3分钟，倒计时内 中奖率将翻倍；5、燃烧值每3秒刷新一次，当中途离开再次打开，则拿到最新倒计时显示；6、弹幕从最新100条记录 每隔2秒随机生成一条记录； 模块设计1、整个框架布局在一个 MainVC中控制转盘类型，请求余额，通知等刷新金额； 管理childVC ；2、childVC 中 处理抽奖业务逻辑；UI 布局，抽奖请求， 燃烧值处理，弹幕处理；3、其他功能性子View 单独自定义视图； 转盘视图，燃烧值进度视图，倒计时进度视图， 弹窗类视图；弹幕视图；4、弹窗类视图 以一个ParentView公共视图容器 ，其中子视图由枚举参数值控制自定义；有玩法视图，记录视图，保险视图，技能视图，排行榜视图； 弹幕处理NSTimer 每2秒中往弹幕父视图中添加一条弹幕view;CADisplayLink 调动 setNeedsDisplay 方法 触发 系统drawRect 方法；drawRect 方法中 ，把弹幕父视图所有的弹幕都每次移动x值，再 移除屏幕中的弹幕 x值 小于0 的弹幕（判断 每条弹幕view 有自己的位置）； 倒计时处理在自定义视图中 ，drawRect 方法中 贝塞尔曲线 绘制 两个曲线园；clockwise 逆方向； 每次通过设置剩余时间 调用setNeedLayout 会触发drawRect ; 倒计时启动timer，每0.05秒 重复一次，改变剩余时间；剩余时间 小于 或 为0 时候，则倒计时走完，停止timer; 转盘处理一个点围绕 某个起点 旋转 n 度 后 的转标 通过这个公式计算 ： #define pointRotatedAroundAnchorPoint(point,anchorPoint,angle) CGPointMake((point.x-anchorPoint.x)cos(angle) - (point.y-anchorPoint.y)sin(angle) + anchorPoint.x, (point.x-anchorPoint.x)sin(angle) + (point.y-anchorPoint.y)cos(angle)+anchorPoint.y) 拿到奖品后，根据扇形个数 计算每个扇形的角度，正起点方向 为原点 旋转角度以便设置每个奖品的中心位置point ； 和transform; 转盘指针停在的位置： 指针不动，实际是转动底盘； 需将底盘视图 旋转到固定角度即可；顺时针是 360度 - 固定角度； 每次转动前，需将上一次转动角度归位；1234567891011CABasicAnimation *layer &#x3D; [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation&quot;];&#x2F;&#x2F; 顺时针(所有这里需要用360-对应的角度) 逆时针不需要layer.toValue &#x3D; @((M_PI*2 - (_perSection*index +_perSection*0.5)) + M_PI*2*4); &#x2F;&#x2F;先转4圈layer.duration &#x3D; 4;layer.removedOnCompletion &#x3D; NO;layer.fillMode &#x3D; kCAFillModeForwards;layer.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];layer.delegate &#x3D; self;[self.gameBgView.layer addAnimation:layer forKey:nil];123456789-(void)backToStartPosition&#123; &#x2F;&#x2F;归位 CABasicAnimation *layer &#x3D; [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation&quot;]; layer.toValue &#x3D; @(0); layer.duration &#x3D; 0.001; layer.removedOnCompletion &#x3D; NO; layer.fillMode &#x3D; kCAFillModeForwards; [self.gameBgView.layer addAnimation:layer forKey:nil];&#125;弹出视图12345678910111213141516171819202122232425262728293031#import &lt;UIKit&#x2F;UIKit.h&gt;#import &quot;PrizeRecord.h&quot;typedef void(^GYActionDateDoneBlock)(id selectedDate);typedef enum : NSInteger &#123;Prize_Ranking, &#x2F;&#x2F;抽奖Prize_Gift, &#x2F;&#x2F;奖品Prize_SkillDesc, &#x2F;&#x2F;描述Prize_PlayDesc, &#x2F;&#x2F;描述Prize_Record, &#x2F;&#x2F;中奖记录Prize_RecordDetail &#x2F;&#x2F;中奖详情&#125; PrizeStyle;@interface GYPrizeContairView : UIView- (instancetype)initSheetStyle:(PrizeStyle)prizeStyle actionBlock:(GYActionDateDoneBlock)actionDateDoneBlock;-(void)showInView;&#x2F;&#x2F;中奖奖品；-(void)fetch_Prize_Gift:(NSArray *)datas;&#x2F;&#x2F;默认选中查询的转盘-(void)fetch_Record_DefaultChooseSelect:(DrawPrizeType)drawType;-(void)fetch_Record_Detail:(PrizeRecord *)record;&#x2F;&#x2F;排行榜-(void)fetch_Ranking_DrawType:(DrawPrizeType)drawType;@end 12345678910111213141516171819if(_sheetCellStyle &#x3D;&#x3D; Prize_Ranking)&#123; [self createRankingView]; &#x2F;&#x2F;排行榜； titleLabel.text &#x3D; @&quot;排行榜&quot;;&#125;else if(_sheetCellStyle &#x3D;&#x3D; Prize_Gift)&#123; [self createPrizeGiftView]; &#x2F;&#x2F;奖品 titleLabel.text &#x3D; @&quot;恭喜您获得以下奖品&quot;;&#125;else if(_sheetCellStyle &#x3D;&#x3D; Prize_SkillDesc)&#123; [self createSkillDescView]; &#x2F;&#x2F;技能描述 titleLabel.text &#x3D; @&quot;技能&quot;;&#125;else if(_sheetCellStyle &#x3D;&#x3D; Prize_PlayDesc)&#123; [self createPlayPrizeDescView]; &#x2F;&#x2F;技能描述 titleLabel.text &#x3D; @&quot;玩法说明&quot;;&#125;else if(_sheetCellStyle &#x3D;&#x3D; Prize_Record)&#123; [self createPlayPrizeRecordView]; &#x2F;&#x2F;技能记录描述 titleLabel.text &#x3D; @&quot;抽奖记录&quot;;&#125;else if(_sheetCellStyle &#x3D;&#x3D; Prize_RecordDetail)&#123; [self createPlayPrizeDetailRecordView]; &#x2F;&#x2F;奖品记录详情 titleLabel.text &#x3D; @&quot;抽奖详情&quot;;&#125; 如图： 抽奖功能模块源码","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[{"name":"抽奖","slug":"抽奖","permalink":"https://www.littlewhale.xyz/tags/%E6%8A%BD%E5%A5%96/"}]},{"title":"地图多手势的应用","slug":"mapGesture","date":"2018-09-28T07:45:56.000Z","updated":"2020-05-27T00:57:45.000Z","comments":true,"path":"2018/09/28/mapGesture/","link":"","permalink":"https://www.littlewhale.xyz/2018/09/28/mapGesture/","excerpt":"当需要在地图上层覆盖一个列表时候，我们想看到更多的内容，列表被拉出来后翻看数据；当想收起时候，可用下拉，或者随着手势滑落下来； 需解决的问题：1、滑动表格，地图不移动；手势来回滑时候，列表要跟着高度变化；2、当滑到最高时候，不再往上滑动；相反，滑到最低高度时候不再继续向下；3、滑上去之后，再往下滑动 不影响列表数据的查看与浏览； 思考 手势开始：记录 开始点startY， 手势移动：根据起始位置移动差 确定上滑动 ， 下滑动； 起点B 点 记录方向 0；B-A 正向， 记录方向符号 1；B-C 反向 ，记录方向 -1； 偏移值 大于0 ， 上滑动；当B-A-C 后，立马记录 1 变成 -1； 记录标记状态前， 正向如：B-A 的过程 ，需判断是否为 为 -1 到1 还是 0-1 ， 如果是-1 则是来回拖动；否则为正向拖动； code :以下是重点逻辑代码；","text":"当需要在地图上层覆盖一个列表时候，我们想看到更多的内容，列表被拉出来后翻看数据；当想收起时候，可用下拉，或者随着手势滑落下来； 需解决的问题：1、滑动表格，地图不移动；手势来回滑时候，列表要跟着高度变化；2、当滑到最高时候，不再往上滑动；相反，滑到最低高度时候不再继续向下；3、滑上去之后，再往下滑动 不影响列表数据的查看与浏览； 思考 手势开始：记录 开始点startY， 手势移动：根据起始位置移动差 确定上滑动 ， 下滑动； 起点B 点 记录方向 0；B-A 正向， 记录方向符号 1；B-C 反向 ，记录方向 -1； 偏移值 大于0 ， 上滑动；当B-A-C 后，立马记录 1 变成 -1； 记录标记状态前， 正向如：B-A 的过程 ，需判断是否为 为 -1 到1 还是 0-1 ， 如果是-1 则是来回拖动；否则为正向拖动； code :以下是重点逻辑代码； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758if(gestureRecognizer.state &#x3D;&#x3D; UIGestureRecognizerStateChanged)&#123; CGPoint point &#x3D; [gestureRecognizer locationInView:self.view]; CGFloat topDistance &#x3D; startSpanPoint.y - point.y; if(topDistance &gt;0)&#123; &#x2F;&#x2F;&gt;100 就是向上滑，但是要控制滑动的距离限制； if(pointB1_Y &#x3D;&#x3D; -1)&#123; blChange &#x3D; YES; &#x2F;&#x2F;记录从往下变成往上； &#125;else if(pointB1_Y &#x3D;&#x3D; 0)&#123; blChange &#x3D; NO; &#x2F;&#x2F;方向没有变更； &#125; pointB1_Y &#x3D; 1; &#x2F;&#x2F;记录当前是往上推； &#x2F;&#x2F;往上推； if(self.tableView.top &#x3D;&#x3D; self.listViewMinTop)&#123; self.tableView.scrollEnabled &#x3D; YES; &#125;else&#123; if(self.datas.count &gt; 0)&#123; &#x2F;&#x2F;无数据时候 不给往上推 &#x2F;&#x2F;向上；上剩多少留多少 ; if(bBottom_Top_Flag &#x3D;&#x3D; NO)&#123; if(!blChange &amp;&amp; self.mapViewHeight - topDistance &gt;&#x3D; self.listViewMinTop)&#123; self.tableView.top &#x3D; self.mapViewHeight - topDistance; &#125; &#125;else&#123; if(self.mapViewHeight - topDistance &gt;&#x3D; self.listViewMinTop)&#123; self.tableView.top &#x3D; self.mapViewHeight - topDistance; &#125; &#125; &#125; &#125; &#125;else if(topDistance&lt;0)&#123; if(pointB1_Y &#x3D;&#x3D; 1)&#123; blChange &#x3D; YES; &#x2F;&#x2F;记录从往上变成往下； &#125;else if(pointB1_Y &#x3D;&#x3D; 0)&#123; blChange &#x3D; NO; &#x2F;&#x2F;方向没有变更； &#125; pointB1_Y &#x3D; -1; &#x2F;&#x2F;记录当前是往下拉； if(self.tableView.contentOffset.y&lt;&#x3D;0 &amp;&amp; self.tableView.top &lt; self.mapViewHeight)&#123; &#x2F;&#x2F;并且是在顶部小于0时候 self.tableView.contentOffset &#x3D; CGPointMake(0, 0); &#x2F;&#x2F;可写可不写； self.tableView.scrollEnabled &#x3D; NO; if(bBottom_Top_Flag &#x3D;&#x3D; YES)&#123; if(!blChange &amp;&amp; self.listViewMinTop - topDistance &lt;&#x3D; self.mapViewHeight)&#123; self.tableView.top &#x3D; self.listViewMinTop - topDistance; &#125; &#125;else&#123; if(self.listViewMinTop - topDistance &lt;&#x3D; self.mapViewHeight)&#123; self.tableView.top &#x3D; self.listViewMinTop - topDistance; &#125; &#125; &#125; &#125;&#125; 单独写了个demo ，仿boss 直聘 查看更多职位，仿哈喽出现 app 扫码底部按钮 查看更多活动Demo 源码","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"MVC设计模式见解","slug":"mvc","date":"2018-09-28T06:34:52.000Z","updated":"2020-05-27T00:38:33.000Z","comments":true,"path":"2018/09/28/mvc/","link":"","permalink":"https://www.littlewhale.xyz/2018/09/28/mvc/","excerpt":"","text":"（控制器Controller）- 负责转发请求，网络处理，控制业务逻辑。 （视图View） - 页面视图UI交互； 模型与视图不能通信，需通过控制器controller来实现； （模型Model） - 数据业务模型的呈现； 涉及到的UI 改动， 数据驱动UI，改动数据状态即可实现UI的变更； 演进（ViewModel模型） - 在原有MVC 基础上多了一层，Controller不直接控制Model, 直接操作ViewModel 来间接管理； ViewModel （NSObject）的职责：数据逻辑处理,控制，算法，解析，网络处理等等； 不直接管理View;三层模式可有效降低项目偶尔度，有效业务规整，分类； 大大提高项目开发效率；","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.littlewhale.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://www.littlewhale.xyz/tags/MVC/"}]},{"title":"几种典型的设计模式","slug":"designPatterns","date":"2018-09-28T06:07:37.000Z","updated":"2020-05-27T00:55:04.000Z","comments":true,"path":"2018/09/28/designPatterns/","link":"","permalink":"https://www.littlewhale.xyz/2018/09/28/designPatterns/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253---------- 简单工厂模式：---------- 定义一个计算接口。 定义四个加减乘除 的具有该接口功能 的类。定义一个工厂类。 用来创建 不同的 接口功能类。 根据不同的需要，通过 接口 接收对象， 调用不同的功能操作类的实现方法。---------- 模板模式：---------- 父类运行的时候，调用子类 重写的方法。---------- 工厂模式：---------- 定义一个接口功能。 两个数变量 ，有计算功能。 定义 不同的 功能接口实现类。 使用变量时候 用 @synthesize numberA &#x3D; _numberA;定义一个类，定义创建工厂方法，不实现。改抽象工厂 具有计算接口功能。定义不同的工厂子类，实现创建工厂对象。 调用的时候，通过 不同的计算方法。---------- 责任模式：---------- 请假：定义一个 领导。 Manager 领导 具有批准请假功能。 内包含直属领导。领导有三级层次的领导。（内包含直属领导。如果自己审批时候发现 需要直属领导审批 则直接让直属领导操作）普通请假 普通领导批准，请假天数超过一定数需要更高级领导 批准。 普通领导 有直属 领导 。 普通领导处理时候 一级一级 处理上去 。---------- 命令模式，享元模式：---------- 定义一个菜单。Order . 菜单有很多种菜单。 子类 order . 菜单中 厨师 cook 执行这个菜单。多个客户下单 。 waiter 统一接受 菜单。（不管点的什么菜）。watier 去传达给 cook 去 做不同的菜系。调用不同的子类菜单 让厨师去 做菜。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.littlewhale.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"HTTPS连接过程","slug":"https","date":"2018-09-25T06:03:27.000Z","updated":"2020-05-27T00:41:20.000Z","comments":true,"path":"2018/09/25/https/","link":"","permalink":"https://www.littlewhale.xyz/2018/09/25/https/","excerpt":"","text":"【HTTPS连接过程】https协议就是http+ssl协议，如下图所示为其连接过程：￼ 1.https请求客户端向服务端发送https请求；2.生成公钥和私钥服务端收到请求之后，生成公钥和私钥。公钥相当于是锁，私钥相当于是钥匙，只有私钥才能够打开公钥锁住的内容；3.返回公钥服务端将公钥（证书）返回给客户端，公钥里面包含有很多信息，比如证书的颁发机构、过期时间等等；4.客户端验证公钥客户端收到公钥之后，首先会验证其是否有效，如颁发机构或者过期时间等，如果发现有问题就会抛出异常，提示证书存在问题。如果没有问题，那么就生成一个随机值，作为客户端的密钥，然后用服务端的公钥加密；5.发送客户端密钥客户端用服务端的公钥加密密钥，然后发送给服务端。6.服务端收取密钥，对称加密内容服务端收到经过加密的密钥，然后用私钥将其解密，得到客户端的密钥，然后服务端把要传输的内容和客户端的密钥进行对称加密，这样除非知道密钥，否则无法知道传输的内容。7.加密传输服务端将经过加密的内容传输给客户端。8.获取加密内容，解密客户端获取加密内容后，用之前生成的密钥对其进行解密，获取到内容。中间人劫持攻击https也不是绝对安全的，如下图所示为中间人劫持攻击，中间人可以获取到客户端与服务器之间所有的通信内容。￼￼ 中间人截取客户端发送给服务器的请求，然后伪装成客户端与服务器进行通信；将服务器返回给客户端的内容发送给客户端，伪装成服务器与客户端进行通信。通过这样的手段，便可以获取客户端和服务器之间通信的所有内容。使用中间人攻击手段，必须要让客户端信任中间人的证书，如果客户端不信任，则这种攻击手段也无法发挥作用。","categories":[],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://www.littlewhale.xyz/tags/HTTPS/"}]},{"title":"新浪微博 推和拉","slug":"sinaPullPush","date":"2018-09-25T04:25:06.000Z","updated":"2020-05-27T00:49:08.000Z","comments":true,"path":"2018/09/25/sinaPullPush/","link":"","permalink":"https://www.littlewhale.xyz/2018/09/25/sinaPullPush/","excerpt":"","text":"每个人的feed就是一个list，存储到redis;用户前端产生的所有事件 发送到消息队列 RabbitMQ,Server 根据 业务逻辑将新的item插入到下游用户的feed里面； 在线推，推给活跃在线用户，离线拉； 任务调度 ：选用了Celery； 每个用户都有一个收件箱 和 发件箱；保存自己发过的动态以及Feed动态； 用户A关注了用户B ， 用户B发布动态则将动态推进用户A的feed，这里使用redis的zset实现，sort为time（记得以毫秒为时间戳，秒级在数据量达到一定程度后，会有读取不到的问题，比如以时间戳为分页页码），value为具体的动态 ID（为什么是动态ID， 其实很简单， 就是因为动态的内容可以进行缓存，在redis里面全部走ID，修改动态内容也需要修改一处，动态内容可以保存在hash结构里）， 每个用户维护一个zset保存我发布的动态，一个zset保存我的feed动态，过期时间3~7天看情况而定。 全局维护一个在线用户列表，怎么设计这个就自己琢磨了，为了防止用户挂后台导致与服务端为离线状态，所以最好是1~3小时未操作或者离线时间不大于3小时的，都当做在线处理， 那么，当用户发了一条动态后，后台会有以下这些操作： 在线推： 异步遍历在线的粉丝，将动态ID，添加到粉丝的Feed中。 离线拉： 离线用户打开APP后，我们是会请求一个公共的入口接口，主做统计以及其他初始化操作，在这里，我们也开了一个异步线程，对用户进行Feed更新操作，防止用户进入APP后等待拉取时间过长，毕竟关注成千上万的人肯定有（其实万单位以下遍历都很快）。拉取过程其实就是把自己最后一条Feed的时间戳取出，去遍历关注的人的feed，将大于该时间的ID全部拉取回来。用户进入APP后，刷新即可看到最新操作。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.littlewhale.xyz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"聊聊动态多类型cell的设计","slug":"typeCells","date":"2018-09-25T03:41:47.000Z","updated":"2020-05-27T01:08:36.000Z","comments":true,"path":"2018/09/25/typeCells/","link":"","permalink":"https://www.littlewhale.xyz/2018/09/25/typeCells/","excerpt":"","text":"红包实体，文章实体 都属于动态 ，定义时候实现该协议DynamicPro,相当于java中的接口。dataList 数组中 存放的是通过网络请求拿到的 DynamicPro 类型的动态列表。 123456789101112131415161718192021222324252627282930313233343536373839404142 @protocol DynamicPro &lt;NSObject&gt; @end 红包实体，文章实体 都属于动态 ，定义时候实现该协议DynamicPro。 dataList 数组中 存放的是通过网络请求拿到的 DynamicPro 类型的动态列表。 DynamicCell: UITableViewCell &#123; 属性 Id&lt;DynamicPro&gt; dynamic; //文章动态，普通动态，直播动态，红包类型动态 &#125; @implementation DynamicCell -(void)setDynamic:(id&lt;DynamicPro&gt;)dynamic&#123; _dynamic = dynamic; //DynamicCell 有很多子类cell: 红包cell ,文章cell,直播cell 等 //在子类cell 渲染具体UI数据绑定 &#125; @end 表格 cellFor 渲染的时候：&#123; DynamicPro *dynamic = self.dataList[indexPath.row]; DynamicCell * cell = [红包cell new]; //根据dynamic类型 创建 不同的 动态cell //最终统一设置动态数据 [cell setDynamic: dynamic]; &#125; 表格高度 heightFor 渲染的时候：&#123; DynamicPro *dynamic = self.dataList[indexPath.row]; if(dynamic 高度不变的)&#123; return 44; &#125;else&#123; //高度变动的用自动布局 return UITableViewAutomaticDimension; &#125; &#125; 表格 estimatedHeightForRowAtIndexPath 进行自动布局的估算 &#123; return 100; &#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"关于聊天页面的多类型消息的封装","slug":"messageUIDesign","date":"2018-07-21T01:25:29.000Z","updated":"2020-05-27T00:57:02.000Z","comments":true,"path":"2018/07/21/messageUIDesign/","link":"","permalink":"https://www.littlewhale.xyz/2018/07/21/messageUIDesign/","excerpt":"","text":"消息布局观察：周边头像，昵称，间距 ，气泡 及其他统一，内容视图挖空； 采取自定义注入视图配置； 从CellFor 方法说起；聊天消息页面，我们看到 有 聊天消息 还有时间戳；根据 ModelItem项 的 class类型 分别去创建 两种cell ; 只里只讲 聊天消息cell; 流程：当为聊天消息Model 时候，名 messageModel（messageModel 里面 大致有以下属性: 记录消息模型，消息布局，头像，昵称 显示控制，消息内容size; （不足 后补））； 取得消息布局； 相对应的content类字符串；根据 identify = content 去重用cell (不同消息类型重用标识不同 ); 创建MessageCell 根据 content 去创建 对应的内容视图 即可；再刷新视图数据 赋值； 布局来源：定义 一个 layoutconfigInterface;layoutconfig 配置包含：{1）message的内容大小；2）需要创建显示的CellContent 类名3）气泡的配置间距等4）控制是否显示头像5）控制是否 显示昵称6）控制消息显示在左边还是在右边 （是否是自己发的）} Content来源1、contentConfigInterface 接口：考虑到message的内容大小 和 cellContent 类名 是 属于 CellContent 配置； 于是 考虑用一个 cellConentConfigFactory 的工厂来生产这些配置 ； 2、contentConfigInterface 实列message的内容大小 和 cellContent 类名 抽出来 定义一个接口 ContentConfigInterface；（考虑到有文本配置，图片配置，以及图文配置，后期 的扩展 声音配置，红包配置 ， 好友分享配置） 准备一个超级父类BaseContentConfig （具有message属性，方便计算message内容的大小）； 后期配置只需继承 BaseContentConfig、实现ContentConfigInterface 接口 方法即可； 3、最终要把配置contentConfigInterface 这样的实列 反馈给 布局管理器; 为了不暴露太多的详细contentConfig 细节 以及 低耦合；用一个ConentConfigFactory 工厂生产这些配置玩意 ，根据消息类型 返回 消息内容配置 contentConfig （工厂单列，实列化的时候 创建了一个Map或者字典， 记录了消息类型 对应的 消息contentConfig;）","categories":[{"name":"技术","slug":"技术","permalink":"https://www.littlewhale.xyz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"iOS客户端请求模块","slug":"iOSNetworkDesign","date":"2018-07-20T01:28:50.000Z","updated":"2020-05-27T00:58:38.000Z","comments":true,"path":"2018/07/20/iOSNetworkDesign/","link":"","permalink":"https://www.littlewhale.xyz/2018/07/20/iOSNetworkDesign/","excerpt":"","text":"探究原生网络请求业务接口API设计与网络请求Swift 版 Alnofire 框架使用Swift 中的Json解析VC 发起请求， 一个专门发请求的发射器；我给它取名字 叫 NetManager , 显然 ，为 了不重复创建http 请求基础配置（请求头，Https证书配置等），这是个单例； 发射器 发的是请求； 考虑到每个业务 都有不同的请求；我准备了 一个 超级父类请求 ；取名 DataRequest; 具体的请求，只需传 具体的子类request； 一个APP 请求有很多，为了区分 及 维护方便 ，于是我定义了一个枚举；每个业务请求，只需给它表明一个标识； 请求具有什么特性呢？ 1）有请求的API url地址，2）请求的参数，请求的标识（请求的枚举值）， 3）对请求回来的数据解析好封装（业务数据封装等处理）； 于是我定义了一个名叫APIInterface 的接口协议； 父类请求去实现这个APInterface接口协议； 子类去Override 这几个方法即可； 发出一个请求，必然有 回答；要么成功，要么失败 （有的失败是业务码失败）； 于是 ，我定义了已一个请求回调的接口；RequestCallBackInterface ； （具有三个方法： 业务成功，业务失败，网络其他原因失败） 我从VC 发出去的请求，相当于Android 的Activity; 熟称视图控制器；当然是希望请求回调 回到 视图控制器；于是我 在 基类视图控制器 BaseViewController 或者BaseActivity(Android) 实现 请求回调 接口协议；实现其中的方法。具体视图控制器 继承基类， 只需覆盖Override 这三个方法 （具体VC 实现回调后的业务） 最后；页面逻辑就显示得比较简单了，一个单例 NetManager 执行一个 DataRequest (传具体请求子类) ； 视图控制器在具体RequestCallBackInterface 的回调方法 中处理 成功 ，失败后的数据； 12345678910111213141516171819202122232425262728293031//登录请求self.loginRequest.userLogin = self.userName;self.loginRequest.userPass = self.userPwd;[[GYNetworkingManager shareInstance] executeRequest:self.loginRequest];//朋友圈列表请求self.dynamicListRequest.pageIndex = 1;self.dynamicListRequest.pageSize = 20;[[GYNetworkingManager shareInstance] executeRequest:self.dynamicListRequest];-(void) onRequestSuccess:(BaseResponse *)response&#123;switch (response.requestAPICode ) &#123; //请求的枚举case Http_Login:&#123;//返回的登录对象// LoginData *data = response.responseObject;break;&#125;case Http_DynamicList:&#123;//如果是列表,则从取数组NSArray *dataList = response.tableList.dataList;[self allLoadingCompleted:dataList];break;&#125;default:break;&#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"一个杯子的8中营销方式","slug":"marketingMethods","date":"2017-09-04T03:53:54.000Z","updated":"2020-05-27T00:48:42.000Z","comments":true,"path":"2017/09/04/marketingMethods/","link":"","permalink":"https://www.littlewhale.xyz/2017/09/04/marketingMethods/","excerpt":"","text":"一个杯子的8种营销方案： 卖产品的本身使用价值，只能卖3元/个。 卖产品的文化价值，可以卖5元/个。 卖产品的品牌价值，可以卖7元/个。 （品牌标签） 卖产品的组合价值，卖15元/个。（情侣，亲情套装） 卖产品的延伸价值。（对人体有什么好处之类的） 卖产品的细分市场价值 （情侣套装，12生肖，卡通动漫 之类的，精装礼盒） 卖产品的包装价值。 买产品的纪念价值。 营销解码：消费者往往购买商品时，除了产品本身的使用价值外，更多的是购买一种感觉，文化，期望，面子，圈子，尊严，尊重，理解，地位等象征性的意义。同样一个杯子，杯子里面的世界，它的功能，结构，作用，依然如故，随着外面的包装，它的价值就在提升。采用不同的价值创新策略，精美的策划，就会让你的产品价值大大提升。","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"创业前的几点","slug":"beforeEntrepreneurship","date":"2017-09-04T03:37:44.000Z","updated":"2020-05-27T00:59:00.000Z","comments":true,"path":"2017/09/04/beforeEntrepreneurship/","link":"","permalink":"https://www.littlewhale.xyz/2017/09/04/beforeEntrepreneurship/","excerpt":"","text":"创业建议在合作方面不一定要找和自己相差不多的，因为这样彼此的眼光或者视野都比较短浅，合伙本来就是一种互助和学习的机会！我认为找合适的是必须的，同时先要了解对方的为人，因为合伙很容易出纠纷的！ 至于真正的合伙创业，我建议你慎重，至于网络工作室的想法是好的，一来你没有技术、没有太多的资金都不是最主要的问题，关键是，能否找到合适的人选！比如技术不到位下面的工作是无法继续的，同时技术需要专业，不然谈判的过程中没有说服力！ 至于资金，网络工作室的起步资金不需要太高，再加上合伙创业要给对方希望，大家有共同兴趣和目标这样才行，不然一切都是空谈！生意如此，合作也是如此！ 个人认为，一个网站的发展好坏，更多的取决于推广和管理运营，再好的商业模式，没有强有力的执行力也只不过是泡影而已。在这个过程中也认识不少做技术的朋友，开发了不少在技术上非常过硬的产品出来，做出不少有新概念的网站或者产品出来，但是我不知道他们在做的时候有没有考虑过市场的需求，或者有没有想过东西做出来谁会花钱买？ 一个不懂技术的人，不一定就一定不懂互联网，试问当今的互联网创业的大亨们，有几个是正统科班出身的？马云、朱俊、史玉柱。。。。。。他们懂得更多的是什么东西赚钱，怎么去做能赚钱。比起追求理想和境界的技术大师们，显得更现实了一些，更铜臭味了一些。 创业准备易犯的错误 准备不足。（认真思考和对待自己的创业，是不是能聚合做这件事需要的要素，包括经验积累，团队，启动资金，资质牌照，商务渠道等，最基本的是经验和团队，另外最起码要有团队领导力等） 过于重视点子，忽视执行。（创业的核心在执行。过于追求点子，一味求新求变，追求不同，反而导致一堆没有可执行性的计划。） 选择过于复杂，超出创业公司能力的项目。 长时间兼职创业。（创业准备，和研究时间不辞职是可以的，但长时间兼职创业是不可取的。兼职往往导致执行力低下，思考不深入，团队无法正真组建，不能吸引好的人加入。无法融资，最重要的是轻易放弃了市场机会。） 多线开发，同时想做太多的事情。希望产品功能丰富，堆砌功能，没有抓住核心需求和核心价值。不注意政策和限制，选择太狭窄的方向，不去考虑推广的渠道，盈利模式等。 什么是创业者 在做每一件事情的时候，把这个事情的每一个阶段的步骤，然后每个阶段里面的重要性，都想得非常清楚。 能够笼络非常好的优秀团队。要有优秀的能人。对产品的细节和操作流程要很敏感。及时发现自己的劣势，找到优势互补的合伙人。 敏锐的洞察力，善于把握一些创业机会。 创业的激情。创业者最重要的是问自己，解决的问题是什么，第二，为什么只有你能解决，第二就是你的执行力，或者你的判断力。 创业者是否同时具有格局的高度，又能够有执行力，既有独特的观点，又能够有空杯的心态去听取别人的意见，学习别人的长处。既有乐观的精神，又能够有这种危机的意识(可能来自巨头的打压和同行的竞争，所以要有危机潜意识)。","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"如何打造理想中的团队","slug":"goodTeam","date":"2017-09-04T03:26:20.000Z","updated":"2020-05-27T00:50:44.000Z","comments":true,"path":"2017/09/04/goodTeam/","link":"","permalink":"https://www.littlewhale.xyz/2017/09/04/goodTeam/","excerpt":"","text":"一.诚实正直 对自己诚实，方能看清楚真实的情况，进而能发现问题的所在，并找到问题的解决方案。 二.友善 友善是一种态度，这意味着在你与人相处时除了过于殷切和敌视之间，有着广阔的空间。 三.独立责任感 你应该为你的所有选择负责任，你应该为你的工作效率负责任，你应该为你的时间规划负主要责任。你应该为你的薪酬和所得负主要责任，你应该为你的职业成长负主要责任。 四.沟通能力 在高度竞争的市场下，单兵作战能取胜的例子越来越少了，相信拥有良好的沟通能力的天才所得的成就远高于那些孤独的天才。 五.灵活度 记得随时退后三步审视自己，包括团队在做的事，并做好随时推翻昨天自己的准备。 能否在必要时候高效地否定自己，及时承认自己考虑的错误和疏漏，并快速地切换到“如何修正错误和调整策略”上。 六.有效且小 小团队需要多面手，单兵素质远高于多面手，不仅仅意味着效率，还意味着跨领域跨技术的思维交叉。 小团队用较少成本实现大团队的用户规模，资金使用效率高。 同样资源情况下，小团的的生存期更长。 小团的内部沟通成本远低于大团队。意味着会议、人事、行政等边缘活动耗时更低。 七.锋利的一致性 当团队价值观建立起来了后，团队本身具有了意识，其思考很行为都会有一定的自主性。这样更容易提高效率。 审美趣味一致性越早建立起来，产品和用户体验的设计师和开发过程越高校。 八.团队中的那些事儿 正确看待Ta 的知识空缺。 保证良好的合作关系，心平气和地沟通，放低身段，耐心倾听和思考，不较真，融洽协作才是王者风范。 引导他们之间沟通。 坦诚。 与人交流，尤其是请教问题的时候，坦诚一点，错了就错了，没有想到就是没有想到，没有必要昂着头问问题。谦虚不会降低人的地位，降低身价的，往往是徒有的高调。 乐于分享果实。每周做一次技术交流，学习几个人的知识。 充分信任自己的伙伴， 放权让Ta去做。","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"互联网思维到底说啥？","slug":"InternetThinking","date":"2017-09-04T03:19:20.000Z","updated":"2020-05-27T00:56:37.000Z","comments":true,"path":"2017/09/04/InternetThinking/","link":"","permalink":"https://www.littlewhale.xyz/2017/09/04/InternetThinking/","excerpt":"","text":"互联网思维指的是什么思维？快速迭代，用户参与。通过不断地迭代使产品日臻完善，而不是追求一次性做出完美的产品。并且，用户的反馈会作为设计决策的部分依据。基于海量数据分析进行决策。互联网产品的一大便利是可以实时获取大量用户的行为数据，基于这些数据可进行产品决策。也可以采用AB测试等方法主动比较不同的设计方案。病毒式营销，星火燎原。 利用互联网的传播特点，促成产品在社交网络，社会化媒体的渗透，并通过制造轰动性事件，争议性话题，实现大范围病毒传播，这是一种无本万利的营销手段。小而美，少即多。互联网产品通常不追求大而全，而是抓住用户的某个痛点或价值点，针对性地做出定位明确的产品。在功能上尽量简单明确，即便要做大做复杂也是慢慢加上去的。体验上尽量做到简单易上手。 免费策略，平台战争。 互联网产品大多不向用户直接收费，而是用免费策略极力争取用户，锁定用户。并且，同时致力于使Im，搜索引擎，浏览器，杀毒软件等从专用产品变成平台产品，凭借庞大的用户基数，推广和销售其他服务。 粉丝经济，草根品牌。培育和勾引死忠用户，壮大粉丝规模，营造粉丝文化乃至构建话语体系。同时必须在品牌中注入草根基因，放低身段，讨好甚至都弄粉丝，保持高频，全方位的互动，比较成功的互联网产品：小米，逻辑思维，梁欢。 激发用户创造，自组织构筑网络生态。 使用户也成为产品的一部分，激励用户进行创造，生成高价值内容，用户在创造的同时还能自组织，自发形成多层次，多样性的网络单元，使互联网产品扩展为一个复杂的生态系统，最典型如豆瓣，自行繁荣壮大。","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"提高执行力","slug":"execution","date":"2017-09-04T03:13:02.000Z","updated":"2020-05-27T00:49:26.000Z","comments":true,"path":"2017/09/04/execution/","link":"","permalink":"https://www.littlewhale.xyz/2017/09/04/execution/","excerpt":"","text":"概念:什么是执行力? 第一， 静态管理，也就是说，我们遵守制度。 第二，指令如山。就是把所有的指令放在方向上，就是上司交代的事情，布置的任务如何尽快有效、高效地把它完成。 第三，做事要有结果。所谓的做事就是一个工作流程，结果就是工作价值。 思考:怎样提高执行力? 积极选拔合适的人到恰当的岗位上，还要锻炼员工队伍的执行能力. 从服从开始抓，因为不服从怎么谈执行？服从也应当是员工的第一美德，任何发展战略、营销模式都要建立在员工服从的基础之上，每一位员工都必须服从上级领导的指挥安排，服从是执行的第一步。 能够提高执行力的管理动作必须具备三个要素：标准、制约、责任。也就是说，事情怎么做必须要制订标准，要关注细节，要有人检查，形成监督和制约；最后，事情做的好与坏一定要追究责任，好的奖，坏的罚。 把工作项和任务进行排序。重要，紧要等。积极的态度去参与。 坚持。注重结果。","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"何为运营？","slug":"operation","date":"2017-09-04T02:52:23.000Z","updated":"2020-05-27T00:55:24.000Z","comments":true,"path":"2017/09/04/operation/","link":"","permalink":"https://www.littlewhale.xyz/2017/09/04/operation/","excerpt":"","text":"产品运营往往是紧紧围绕三个目标： 产品，用户，渠道。 成功的运营能够挖掘用户的特点和需求。 产品运营具体工作有哪些？ 运营策划： 主要是以数据为依据的产品运营方案策划，这块是重点。 BD : 运营会接触到不同的渠道的转化效率，因此相对的需要和渠道商打交道或者公司内部的销售人员接触，这块实际也会涉及到一定的沟通协调公关的工作。 媒介： 这里又包括文案的撰写，话题策划，软文发布等。 活动营销： 结合产品推广和品牌宣传，策划活动营销方案并有力执行，促使达到提高产品和品牌知名度的目的，以及用户的调研奖励等。 数据分析： 数据决定运营的执行。 市场监控： 主要是战略层面，包括行业市场的监控以及竞争对手的监控。 产品运营有极为明确的目标。 营收：运营要找到商业模式，或者为现有的产品扩大营收。 扩大用户群：让更多人知道，产品将更成功。 用户活跃度：沉默的用户是没有多少商业价值的，只有活跃方能带来价值。 好的产品是运营出来的。第一，它能在一个点上打动用户。第二， 它一定是靠持续改进，持续运营的东西。互联网本质就是服务，用户的需求不断在变，你就得随时调整。 目标决定数据取样，找到关键值并努力执行。 看数据，分析数据，找到需要及时调整的数据。进行后续执行工作。 首先是要有数据，其次是准确性，然后数据要有连贯性。再者，一切数据要有对比才能产生价值。最后得到结论。 同时，关键数值是重要一环，可以省力高效；但真正每天围绕这个数值不断地努力执行下去才会有真正的提高。 产品运营不要寄予希望最后一击命中用户需求，而重点应该稳定有效地一步步接触，引导，尝试，认知，渗透，熟悉 的过程。","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"你是个合格的产品经理？","slug":"productManager","date":"2017-09-04T02:05:34.000Z","updated":"2020-05-27T00:51:50.000Z","comments":true,"path":"2017/09/04/productManager/","link":"","permalink":"https://www.littlewhale.xyz/2017/09/04/productManager/","excerpt":"","text":"首先，产品经理应该做什么？ 帮助企业/用户为用户打造有价值的产品。 产品经理思维包括哪些？ 抓住需求的本质 - 人性 （一个优秀的产品经理需要具备抓住用户欲望的能力，而不是仅仅在产品上增加一个功能这么简单） 核心需求的把控能力。(无论功能如何增加和外界给予任何干扰，都需要时刻保证产品的核心不被影响) 时刻描画产品的蓝图 - 未来 （走一步，看百步。需要时刻心中明白产品的将来会是如何，最重要的是在走向未来的过程中又需要哪些助力） 不断复盘产品的现在 - 总结 （这个决定做的对吗？有什么数据支撑？ 产品人需一日三省，不断总结，不断修正，给自己日后决策更加充足的依据） 无懈可击的思维 - 逻辑思维 （慎密的思维能力，对整个业务流程要非常熟悉。） 产品的终极价值 - 商业盈利 （不断迭代的过程中，我们需要懂得如何帮助产品走到商业实现） 做减法如同做加法 - 极简 （做产品不是做功能，产品不是功能的不断累加，我们需要给产品瘦身的机会，给用户极简的体验，设问：每个版本要上的功能，你能删掉一个吗？） 懂得和不同的人打交道 - 沟通（应该好好思考如何与不同岗位的同学打交道，知道大家的性格特点，懂得如何把信息有效地传递。） 管理好自己的时间和任务 - todolist (对时间管理要更加细分化，多用TodoList ，会有不少的帮助。) 宰相肚里能撑船 - 抗压 （产品经理的特殊位置，导致了人人可喷的境遇。在如此逆境中，需要有一个广阔的胸怀和极强的抗压能力，其实这些都不是什么，因为我们眼里只有产品。）","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"营销六心理","slug":"marketingPsychology","date":"2017-09-04T01:43:52.000Z","updated":"2020-05-27T00:48:23.000Z","comments":true,"path":"2017/09/04/marketingPsychology/","link":"","permalink":"https://www.littlewhale.xyz/2017/09/04/marketingPsychology/","excerpt":"","text":"法则一： 从众心理 1，比如淘宝。用户购物时候往往会参考别人的购物体验，当某件东西很畅销，人们会本能地把它当作一个正确有效的选择。 借助销售排行榜将一个品牌与最畅销的品牌联系在一起。 可在社交平台分享消费者生动感人的购买经历获得其他用户的认同感。 通过巧妙的方式让消费者心甘情愿地宣传产品的各种优势。 利用技术手段，通过社会化推荐系统，对相似消费群体的挖掘并推荐他们可能喜好的商品。 法则二：影响力 利用明星或者权威人士进行产品推荐。 向名人推出试用活动，并鼓励他们在 社交媒体发布。 法则三：稀缺原则 进行限量体验，限量机会，限量提供，限量版本等基于稀缺性的促销活动。 推出只针对社交媒体的促销计划。 法则四：喜好原则 充分利用购物者的社交圈进行产品推荐，例如微博群组或QQ群。 利用社会化媒体平台关注，分享并传播一些目标消费者喜欢的信息。新闻或科普知识。 经常与活跃粉丝互动以获得他们的好感，这样更容易树立产品品牌形象。 法则五：一致性原则 定期开展免费试用，线上的免费体验等。 设计与品牌相关的小游戏在社交平台推广。 保留消费者各种购物信息，并提供良好的服务，使消费者形成依赖。 法则六：互惠原则 经常在节日与消费者互动，赠送消费者免费的试用装，产品宣传，杂志等。 电商可以透过社会心理层面利用社会化媒体平台塑造品牌。","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"用户体验","slug":"userExperience","date":"2017-09-03T02:56:37.000Z","updated":"2020-05-27T00:47:18.000Z","comments":true,"path":"2017/09/03/userExperience/","link":"","permalink":"https://www.littlewhale.xyz/2017/09/03/userExperience/","excerpt":"","text":"优质的用户体验通常是怎样表达？ 传统方式可通过观察用户，用户访谈，问卷，面对面沟通，可以得到很多的细节之处。 互联网时代，利用数据驱动设计，大数据量来分析用户体验。 现实实例：网购，选产品，购物过程是否畅通，支付流程方便快捷？买家好不好，物流快不快等。这就是用户体验。 用户体验包括具体哪些角色？ 用户体验由产品经理，用户体验人员，设计师，运营人员和市场人员，商务拓展人员。用户在意的是最终的体验如何，而不是具体的中间流程。 用户体验由谁来做？ 用户体验一定是由整个团队来实现，而不是靠单几个专业人员。任何一个环节出了问题，都会给用户体验带来灾难性的后果。 用户体验要靠大家的集思广益，更多的讨论，更多的方案，和探索实验。 用户体验，要靠快速把想法表达出来，快速尝试尽可能多的可能性。 用户体验是典型自上而下的事情。这件事情必须是公司最高层，公司的创始人很在意的，才有可能用好。 用户体验靠研发的每一个环节重点切入，尽早开始，快速设计，快速检验，充分利用数据反馈，请专业人士进行评审。 用户体验要在哪些方面提高？ 用户体验包括产品性能（使用起来快不快，是否流畅），产品的功能（能够实现哪些方面的功能），合适的价格（能不亏本的情况下，又能让人买得起）。 用户体验最重要的一点就是你的产品针对核心用户是谁。把握用户的特点和使用习惯。就是要站在用户的角度去开发产品（用户思维）。 公司什么样的人适合做用户体验？ 有一定的研发背景，然后又是个开放，愿意学习新东西，愿意接受用户体验，能够带领团队，能够从点点滴滴的细节做起。 什么才是好的用户体验？ 最基础，有用，实用，很容易理解。 易用（前提：针对某些合适的产品，如果是游戏或者企业级的应用的话，可能就不同了，反而比较复杂，可能还要经过培训或者较长的一段时间后才能了解）。 使用后不容易遗忘，容易操作不容易犯错，有及时的反馈，有很好的一致性。有很多具体的元素。 在用户体验的前提下，看是不是美观，是不是适合自己公司的品牌，氛围，气质。 具有激发性。能够激发用户。 现实实例：微博。我们之所以使用微博，最主要的原因是因为我们能看到好朋友的一些分享，动态等。看到关注我的人是不是又增加了几个，看看谁又转发了我的微博等。根据这点，我们做的产品可以根据用户产生的内容加上社交元素，使产品和用户的关系转向用户和用户的关系，点赞等，使得用户之间相互激励。 具有漂亮的图标。尤其是消费者类型的产品。用户可能看到漂亮的图标就下载了。 在消费领域的产品，一定要拿起就可以用。 用户体验，产品一开始是针对种子用户，而后是调整面向大众。同时也不会影响种子用户的体验。 总结一点：产品做得好了，挣钱，名誉所有的其他东西都会随之而来。不然的话，即便是获得了，也只是短暂的获得。","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"巧用图解构思-百度脑图","slug":"brainMap","date":"2017-08-11T04:17:40.000Z","updated":"2020-05-27T00:51:29.000Z","comments":true,"path":"2017/08/11/brainMap/","link":"","permalink":"https://www.littlewhale.xyz/2017/08/11/brainMap/","excerpt":"","text":"很多情况，软件功能实现遇到比较复杂的业务情况下，都会借助于草稿或者流程图 去简单画出业务的流程，然后再编码实现。这样有助于提高程序的编写效率，减少bug 的出现。 以下，是基于实时聊天的会议功能设计流程图。逻辑紧代表本人草稿设计思路。 使用百度脑图画图","categories":[{"name":"技术","slug":"技术","permalink":"https://www.littlewhale.xyz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"关系图","slug":"关系图","permalink":"https://www.littlewhale.xyz/tags/%E5%85%B3%E7%B3%BB%E5%9B%BE/"}]},{"title":"Android-TableView","slug":"Android-TableView","date":"2016-11-11T05:22:42.000Z","updated":"2020-05-27T00:43:47.000Z","comments":true,"path":"2016/11/11/Android-TableView/","link":"","permalink":"https://www.littlewhale.xyz/2016/11/11/Android-TableView/","excerpt":"How to development a Android AppBefore you begin, Let’s talk about Android lifecycle first . Learn about Android’s four major components,And to be familiar with Android development tool -Android Studio.Activity 1234Activity1-&gt;Activity2: onCreate()——&gt;onStart()——&gt;onResume()Note left of Activity2: 第一个 Pause，第二个Create，Start，Resume。第一个 StopActivity2--&gt;Activity1: back to the activity1Note left of Activity2: 暂停，restart第一个，start，resume,第二个stop,destory. when you push a new Activity or back Activity, it’s due to the stack to manage the Activity status, but how to push a new Activity? 12345Intent intent &#x3D; new Intent(ReorderFour.this, ReorderTwo.class); intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);startActivity(intent);","text":"How to development a Android AppBefore you begin, Let’s talk about Android lifecycle first . Learn about Android’s four major components,And to be familiar with Android development tool -Android Studio.Activity 1234Activity1-&gt;Activity2: onCreate()——&gt;onStart()——&gt;onResume()Note left of Activity2: 第一个 Pause，第二个Create，Start，Resume。第一个 StopActivity2--&gt;Activity1: back to the activity1Note left of Activity2: 暂停，restart第一个，start，resume,第二个stop,destory. when you push a new Activity or back Activity, it’s due to the stack to manage the Activity status, but how to push a new Activity? 12345Intent intent &#x3D; new Intent(ReorderFour.this, ReorderTwo.class); intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);startActivity(intent); Activity Extentedafter we know the android activity, i want tall about fragment.Perhaps you have seen the most app interfaces is like this. YEs ,it’s Tabbar UI Interface.效果图 so, what about the fragment ? tabbar interface is a activity contains one or more fragments. fragments lifecycle is rely one activity. what did I do to make layout the UITabarActivity?app gradle 配置 项目结构 Tabbar Activity Layout 布局 界面Fragment配置 ok,after you see my screenshots, you can know , i use the ViewpagerIndicator to make a tabbar Activity . it can manager fragments. you can easy to change every fragment you need. app gradle instroduce1. use the fastjson to make json parse.2. use the butterknife replace the frequent findViewById.3. use the ViewPagerIndicator to achieve a tabbarActivity interface.4. use the android-smart-image-view to make the image cache.5. use the android-async-http to make http request.6. use the recycleView-v7 replace the android system listView.7. use the bga-refreshlayout to make the pull refresh cool header.8. finally, use cn.bingoogolapple:bga-adapter to make the recycleView cell Item can right move delete, long press event ,ItemChildClickListener ,and so on . all in all, bga-adapter is perfect ! For your convenience, i encapsulated a tableview like iOS UITableView , you can use the group style or plain style decide by youself; you can find it in the package com.lvj.bookoneday-&gt;widget.view 123456&#x2F;&#x2F;定义表格的数据源接口public interface TableViewDataSource&lt;T&gt; &#123; RecyclerViewCell&lt;T&gt;[] getRecyclerCells(); &#x2F;&#x2F;获取cell int getItemViewType(int position); &#x2F;&#x2F;获取position: cell类型的tag&#125; 12345678910&#x2F;&#x2F;定义表格的事件委托源 public interface TableViewDelegate &#123; void onTableViewDidSelectRow(int row);&#x2F;&#x2F;点击单行 void onTableViewDidLongClickRow(int row); &#x2F;&#x2F;长按单行 void onTableViewDidChangeCheckRow(int row, boolean isChecked); &#x2F;&#x2F;选中行 void onItemChildClick(View childView, int position); &#x2F;&#x2F;item 点击 void onTableViewRefresh();&#x2F;&#x2F;下拉刷新 void onTableViewLoadMore(); &#x2F;&#x2F;加载更多&#125; I create two java interface : TableViewDelete, TableViewDataSoucre. that you can easyimplements there’s methods . when you use the activity or fragment need tableView layout , you can easy and fastlayout ,and implements TableViewDelegate, TableViewDatasource. for examples Talk about Http requestyou know, when your app ask a request, may be have two Design Patterns . it named “block”（anonymous inner classes） ,”delegate”(delegate is named by iOS. on java, it’s interface or ask “OOP” thoughts). My HttpRequest Designthere is a abstract class named BaseDataService. if you have a new request . you just extend BaseDataService and @Override three methods. “getAPIRequestMethodName, setRequestParams,parseResponse”. look these screenshots. And on your Activity or Fragments , you just implemets RequestCallBackDelegate , and you can use your son of BaseDataService to make some request. 父类 子类继承父类 界面用子类请求实现 For more info about the tableView how to work, you can find my open source on my Github Android-TableView,welcome make you suggestion. if you like this project, on my github, I hope you can click on the star in the upper right corner to give me more encouragement. thank you! TO Do: Introduce Android Service components","categories":[],"tags":[{"name":"AndroidTableView","slug":"AndroidTableView","permalink":"https://www.littlewhale.xyz/tags/AndroidTableView/"}]},{"title":"客户端网络请求模块的设计","slug":"iOSDataTransmission","date":"2016-05-29T14:11:19.000Z","updated":"2020-05-27T00:54:15.000Z","comments":true,"path":"2016/05/29/iOSDataTransmission/","link":"","permalink":"https://www.littlewhale.xyz/2016/05/29/iOSDataTransmission/","excerpt":"AFNetworking也被广泛使用。其它的ASIHttpRequest，MKNetworkKit啥的其实也都还不错，苹果对网络请求部分已经做了很好的封装。但不管如何，APP端还是要对网络进行一个封装。在实际的App开发中，Afnetworking已经成为了事实上各大App的标准配置。 iOS开发领域有很多对象间数据的传递方式，我看到的大多数App在网络层所采用的方案主要集中于这三种：Delegate，Notification，Block。我的意见是Delegate为主，Notification可以用在网络发生变化时候使用。","text":"AFNetworking也被广泛使用。其它的ASIHttpRequest，MKNetworkKit啥的其实也都还不错，苹果对网络请求部分已经做了很好的封装。但不管如何，APP端还是要对网络进行一个封装。在实际的App开发中，Afnetworking已经成为了事实上各大App的标准配置。 iOS开发领域有很多对象间数据的传递方式，我看到的大多数App在网络层所采用的方案主要集中于这三种：Delegate，Notification，Block。我的意见是Delegate为主，Notification可以用在网络发生变化时候使用。 谈谈Notification使用Notification来进行网络层和业务层之间数据的交换， 但是使用Notification给跨层数据交流开了一道口子，因为Notification的影响面不可控制，只要存在实例就存在被影响的可能。Notification因为支撑一对多的情况，这也给代码散落提供了条件。同时，Notification所对应的响应方法很难在编译层面作限制。 关于Block 之谈1、block很难追踪，难以维护。调试的时候有个block，如果想知道这个block里面都做了些什么事情，这时候就要从之前写的代码往回查了。。2、block会延长相关对象的生命周期。block会给内部所有的对象引用计数加一，这一方面会带来潜在的retain cycle。这个时候在block块中需要使用weak self 修饰词。因为block会延长生命好周期，所以可能请求还在执行中，ViewController pop之后，请求还在飞。而delegate是弱引用，哪怕请求仍然在外面飞，ViewController还是能够及时被回收的，回收之后指针自动被置为了nil。 Delegate 委托封装请求基类 h 文件 BaseDataService 网络请求基类 m文件 初始化 BaseDataService 配置请求参数，调用具体业务请求子类 BaseDataService 请求结束，通过委托调用viewController 所实现的成功 或失败的方法","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"谈谈iOS的多线程","slug":"iOSThread","date":"2016-05-16T04:00:08.000Z","updated":"2020-05-27T00:49:58.000Z","comments":true,"path":"2016/05/16/iOSThread/","link":"","permalink":"https://www.littlewhale.xyz/2016/05/16/iOSThread/","excerpt":"ios线程形式有三种。 ios4后，苹果改用GCD多线程。线程可以用来干什么呢？多线程可以用来后台加载图片更新主线程UI,或者请求网络数据等等。 Thread使用 NSThread 来创建线程有两种方法:12345678[NSThread detachNewThreadSelector:@selector(myThreadMainMethod:) toTarget:self withObject:nil];NSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(myThreadMainMethod:) object:nil];[myThread start]; // Actually create the thread","text":"ios线程形式有三种。 ios4后，苹果改用GCD多线程。线程可以用来干什么呢？多线程可以用来后台加载图片更新主线程UI,或者请求网络数据等等。 Thread使用 NSThread 来创建线程有两种方法:12345678[NSThread detachNewThreadSelector:@selector(myThreadMainMethod:) toTarget:self withObject:nil];NSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(myThreadMainMethod:) object:nil];[myThread start]; // Actually create the thread 如果你拥有一个 NSThread 对象,它的线程当前正运行,你可以给该线程发送 消息的唯一方法是在你应用程序里面的任何对象使用 performSelector:onThread:withObject:waitUntilDone:方法。它是实现线程间通 信的便捷方法. 线程通信：1.在指定线程上执行操作[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES]; 2.在主线程上执行操作 [self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES]; 3.在当前线程执行操作 [self performSelector:@selector(run) withObject:nil]; NSOperation通常 NSOperation 会和NSOperationQueue 结合起来使用。 在之前，我们应该了解一下NSOperation .Cocoa operations是基于 Obective-C实现的，类 NSOperation 以面向对象的方式封装了用户需要执行的操作，我们只要聚焦于我们需要做的事情，而不必太操心线程的管理，同步等事情，因为NSOperation已经为我们封装了这些事情。 NSOperation 是一个抽象基类，我们必须使用它的子类。iOS 提供了两种默认实现：NSInvocationOperation 和 NSBlockOperation。代码示例：12345NSOperationQueue *mainQueue = [NSOperationQueue mainQueue]; //主队列NSOperationQueue *queue = [[NSOperationQueue alloc] init]; //自定义队列NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123; //任务执行 &#125;];[queue addOperation:operation];如果我们想在一个NSOperation执行完毕后做一些事情，就调用NSOperation的setCompletionBlock方法来设置想做的事情operation.completionBlock = ^() { NSLog(@”执行完毕”);}; NSInvocationOperation基于一个对象和selector来创建操作。如果你已经有现有的方法来执行需要的任务,就可以使用这个类// 这个操作是：调用self的run方法NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];// 开始执行任务(同步执行)[operation start]; GCD单列模式单例就是全局都只有一个对象存在，而且是在整个App运行过程中都存在。 做用户数据存储时，通常都会用单例存储，因为应用在所有操作中，经常要求先登录.1234567891011+ (instancetype)shared &#123; static HYBUserManager *sg_userManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; if (sg_userManager == nil) &#123; sg_userManager = [[HYBUserManager alloc] init]; &#125; &#125;); return sg_userManager;&#125;相信大家对dispatch_once都不陌生了，我将和大家一起探究dispatch_once的更多细节。dispatch_once的作用正如其名：对于某个任务执行一次，且只执行一次。 dispatch_once函数有两个参数，第一个参数predicate用来保证执行一次，第二个参数是要执行一次的任务block。static dispatch_once_t predicate;dispatch_once(&amp;predicate, ^{ // some one-time task});dispatch_once被广泛使用在单例、缓存等代码中，用以保证在初始化时执行一次某任务。dispatch_once在单线程程序中毫无意义，但在多线程程序中，其低负载、高可依赖性、接口简单等特性，赢得了广大消费者的一致五星好评。 dispatch_once使得block中的代码执行且只执行一次，在多线程竞态时，使其他线程进入等待状态直至block执行完毕，并且还保证无竞态时执行效率与非线程安全的if语句效率相当。dispatch_once内部使用了大量的原子操作来替代锁与信号量，这使得其效率大大提升，但带来的是维护和阅读性的降低。dispatch_once被大量使用在构建单例上，apple也推荐如此。 Dispatch Group我们可以使用dispatch_group_async函数将多个任务关联到一个Dispatch Group和相应的queue中，group会并发地同时执行这些任务。而且Dispatch Group可以用来阻塞一个线程, 直到group关联的所有的任务完成执行。有时候你必须等待任务完成的结果,然后才能继续后面的处理。下面用Dispatch Group优化上面的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501. // 根据url获取UIImage 2. - (UIImage *)imageWithURLString:(NSString *)urlString &#123; 3. NSURL *url = [NSURL URLWithString:urlString]; 4. NSData *data = [NSData dataWithContentsOfURL:url]; 5. // 这里并没有自动释放UIImage对象 6. return [[UIImage alloc] initWithData:data]; 7. &#125; 8. 9. - (void)downloadImages &#123; 10. dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 11. 12. // 异步下载图片 13. dispatch_async(queue, ^&#123; 14. // 创建一个组 15. dispatch_group_t group = dispatch_group_create(); 16. 17. __block UIImage *image1 = nil; 18. __block UIImage *image2 = nil; 19. 20. // 关联一个任务到group 21. dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; 22. // 下载第一张图片 23. NSString *url1 = @\"http://car0.autoimg.cn/upload/spec/9579/u_20120110174805627264.jpg\"; 24. image1 = [self imageWithURLString:url1]; 25. &#125;); 26. 27. // 关联一个任务到group 28. dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; 29. // 下载第一张图片 30. NSString *url2 = @\"http://hiphotos.baidu.com/lvpics/pic/item/3a86813d1fa41768bba16746.jpg\"; 31. image2 = [self imageWithURLString:url2]; 32. &#125;); 33. 34. // 等待组中的任务执行完毕,回到主线程执行block回调 35. dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; 36. self.imageView1.image = image1; 37. self.imageView2.image = image2; 38. 39. // 千万不要在异步线程中自动释放UIImage，因为当异步线程结束，异步线程的自动释放池也会被销毁，那么UIImage也会被销毁 40. 41. // 在这里释放图片资源 42. [image1 release]; 43. [image2 release]; 44. &#125;); 45. 46. // 释放group 47. dispatch_release(group); 48. &#125;); 49. &#125;dispatch_group_notify函数用来指定一个额外的block，该block将在group中所有任务完成后执行. 异步下载图片1&gt; GCD提供一个特殊的dispatch queue,可以在应用的主线程中执行任务。只要应用主线程设置了run loop(由CFRunLoopRef类型或NSRunLoop对象管理),就会自动创建这个queue,并且最后会自动销毁。非Cocoa应用如果不显式地设置run loop, 就必须显式地调用dispatch_main函数来显式地激活这个dispatch queue，否则虽然你可以添加任务到queue,但任务永远不会被执行。2&gt; 调用dispatch_get_main_queue函数获得应用主线程的dispatch queue,添加到这个queue的任务由主线程串行化执行3&gt; 代码实现，比如异步下载图片后，回到主线程显示图片123456789101. // 异步下载图片 2. dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; 3. NSURL *url = [NSURL URLWithString:@\"http://car0.autoimg.cn/upload/spec/9579/u_20120110174805627264.jpg\"]; 4. UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL:url]]; 5. 6. // 回到主线程显示图片 7. dispatch_async(dispatch_get_main_queue(), ^&#123; 8. self.imageView.image = image; 9. &#125;); 10. &#125;);","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"Xmpp协议","slug":"xmpp","date":"2016-05-15T11:31:12.000Z","updated":"2020-05-27T01:11:12.000Z","comments":true,"path":"2016/05/15/xmpp/","link":"","permalink":"https://www.littlewhale.xyz/2016/05/15/xmpp/","excerpt":"基于TCP的长连接。在使用 TCP 长连接的 IM 服务设计中，往往都会涉及到心跳。心跳一般是指某端(绝大多数情况下是客户端)每隔一定时间向对端发送自定义指令，以判断双方是否存活，因其按照一定间隔发送，类似于心跳，故被称为心跳指令。","text":"基于TCP的长连接。在使用 TCP 长连接的 IM 服务设计中，往往都会涉及到心跳。心跳一般是指某端(绝大多数情况下是客户端)每隔一定时间向对端发送自定义指令，以判断双方是否存活，因其按照一定间隔发送，类似于心跳，故被称为心跳指令。 保持心跳的必要服务器需要及时清理无效连接以减轻负载，另一方面也是业务的需求，如游戏副本中服务器需要及时处理玩家掉线带来的问题。 为什么TCP KeepAlive 不能用于检测TCP KeepAlive用于检测连接的死活，心跳机制用于检查双方的存活状态。考虑一种情况，某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针则仍旧能够确定连接状态，这就是典型的连接活着但业务提供方已死的状态，对客户端而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态，一直向当前服务器发送些必然会失败的请求。 心跳的做法每隔 30 秒心跳一次，15 秒内没有收到心跳回包则认为当前连接已失效，断开连接并进行重连。连接可靠性可在心跳超时 n 次后才判定当前连接不可用，这样做可以减少心跳连接的次数，减少流量。 消息可达在移动网络下，丢包，网络重连等情况非常之多，为了保证消息的可达，一般需要做消息回执和重发机制。参考易信，每条消息会最多会有3次重发，超时时间为15秒，同时在发送之前会检测当前连接状态，如果当前连接并没有正确建立，缓存消息且定时检查(每隔2秒检查一次，检查15次)。所以一条消息在最差的情况下会有2分钟左右的重试时间，以保证消息的可达。 因为重发的存在，接受端偶尔会收到重复消息，这种情况下就需要接收端进行去重。通用的做法是每条消息都带上自己唯一的message id(一般是uuid)。 消息加密为了保证协议不容易被破解，市面上几乎所有主流IM都会对协议进行加密传输。常见的流程和HTTPS加密相似:建立连接后，客户端和服务器进行进行协商，最终客户端获得一个当前Sessino的秘钥，后续的数据传输都通过这个秘钥进行加解密。一般出于效率的考虑都会采用流式加密，如RC4。而前期协商过程则推荐使用RSA等非对称加密以增加破解难度。 IM协议包包头：struct PackHeader{ int32t length; //包长度 int32t serial; //包序列号 int32t command; //包请求类型 int32t code; //返回码}; IM聊天App 登录后要做得事情 好友列表 好友个人信息 群组列表 群成员列表 群成员个人信息 离线消息 1，客户端永远只更新比本地缓存数据新的数据。2、登录时候LBS可放在登录后或者网络空闲时去请求。3、有些数据只是在请求时候去更新UI. 使用XMpp协议的一个聊天应用程序，当程序退到后台的时候，如果想要继续接收到聊天信息或icon显示badge, 该怎么做？GCDAsyncSocketYou need to set the VoIP flag in your app’s (appname)-info.plist file, and then in (void)xmppStream:(XMPPStream )sender socketWillConnect:(AsyncSocket )socketYou’ll need to set the socket stream flags to include kCFStreamNetworkServiceTypeVoIP: CFReadStreamSetProperty([socket getCFReadStream], kCFStreamNetworkServiceType, kCFStreamNetworkServiceTypeVoIP); CFWriteStreamSetProperty([socket getCFWriteStream], kCFStreamNetworkServiceType, kCFStreamNetworkServiceTypeVoIP);Then, your app will be woken up briefly when a new XMPP message arrives. In your normal (void)xmppStream:(XMPPStream )sender didReceiveMessage:(XMPPMessage )messagehandler, you would want to create a local notification for the message if you are backgrounded (you can keep track of background state via UIApplicationDidEnterBackgroundNotification and UIApplicationWillEnterForegroundNotification). The local notification handler can set the application badge number, etc (just like you would for a push notification). EDITNewer versions of the XMPP Framework (specifically, GCDAsyncSocket) now support a call to make this easier, so you can just have: (void)xmppStream:(XMPPStream )sender socketWillConnect:(GCDAsyncSocket )socket{ // Tell the socket to stay around if the app goes to the background (only works on apps with the VoIP background flag set) [socket performBlock:^{[socket enableBackgroundingOnSocket]; }];}在这篇文章中你或许能找到答案 不得不说StackOverFlow真是个好东西。 聊聊IOS后台应用程序进入后台状态不久后转入暂停状态。在这种状态下，应用程序不执行任何代码，并有可能在任意时候从内存中删除。应用程序提供特定的服务，用户可以请求后台执行时间，以提供这些服务。三种类型的可以运行在后以，1.音乐2.location3.voip声明你需要的后台任务Info.plist中添加UIBackgroundModes键值，它包含一个或多个string的值，包括audio:在后台提供声音播放功能，包括音频流和播放视频时的声音location：在后台可以保持用户的位置信息voip：在后台使用VOIP功能 实现VOIP应用：VOIP程序需要稳定的网络去连接和它相关的服务，这样它才能接到来电和其他相关的数据。系统允许VOIP程序被挂断并提供组件去监听它们的sockets，而不是在任意时候都处于唤醒状态。设置VOIP应用程序如下：A、 添加UIBackgroundModes中的VOIP键值B、 为VOIP设置一个应用程序socketC、 在移出后台之前，调用setKeepAliveTimeout:handler:方法去建立一个定期执行的handler，你的应用程序可以运行这个handler来保持服务的连接。(BOOL backgroundAccepted = [[UIApplication sharedApplication] setKeepAliveTimeout:600 handler:^{ [self backgroundHandler]; }]; if (backgroundAccepted) { NSLog(@”VOIP backgrounding accepted”); }为了防止断连，voip程序需要定期被唤醒去检查它的服务。为了容易实现这个行为，IOS通过使用（UIApplication setKeepAliveTimeout:handler:）方法建立一个特殊的句柄。你可以在applicationDidEnterBackground方法中建立该句柄。一旦建立，系统至少会在超时之前调用该句柄一次，来唤醒你的应用程序。这个keep-alive handler在后台执行，必须尽快的返回参数，它有最多30秒的时间来执行所需的任务，如果这段时间内句柄没有返回，那么系统将终止应用程序。当你建立了handler之后，确定应用程序所需的最大超时。系统保证会在最大超时之前调用handler，但是这个时间是不确定的，所以你的handler必须在你申明的超时之前做好执行程序的准备)D、 设置你的audio session去处理这种切换 安排Local Notification的传递UILocalNotification类提供了一种方法来传递local notifications。和push notifications需要设置remote server不同，local notifications 在程序中安排并在当前的设备上执行。满足如下条件可以使用该能力：1、一个基于时间的程序，可以在将来特定的时间让程序post 一个alert，比如闹钟2、一个在后台运行的程序，post 一个local notification去引起用户的注意为了安排local notification 的传递，需要创建一个UILocalNotification的实例，并设置它，使用UIApplication类方法来安排它。Local notification对象包含了所要传递的类型（sound，alert，或者badge）和时间何时呈现） 。UIApplication类方法提供选项去确定是立即传递还是在指定的时间传递。Listing 4-3 Scheduling an alarm notification (void)scheduleAlarmForDate:(NSDate)theDate{UIApplication app = [UIApplication sharedApplication];NSArray oldNotifications = [app scheduledLocalNotifications];// Clear out the old notification before scheduling a new one.if ([oldNotifications count] &gt; 0)[app cancelAllLocalNotifications];// Create a new notification.UILocalNotification alarm = [[[UILocalNotification alloc] init] autorelease];if (alarm){alarm.fireDate = theDate;alarm.timeZone = [NSTimeZone defaultTimeZone];alarm.repeatInterval = 0;alarm.soundName = @”alarmsound.caf”;alarm.alertBody = @”Time to wake up!”;[app scheduleLocalNotification:alarm];}}(可以最多包含128个 local notifications active at any given time, any of which can be configured to repeat at a specified interval.)如果在调用该notification的时候，程序已经处于前台，那么application：didReceiveLocalNotification：方法将取而代之。 voip与socket实现后台推送1.找到该文件,添加该项(1)蜗牛帮-Info.plist(2)Required background modes它的item：App provides Voice over IP services 2.在socket连接成功代理里面1234567-(void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port//建立连接成功后执行的代理&#123; //后台挂起voip [socket performBlock:^&#123; [socket enableBackgroundingOnSocket]; &#125;]; &#125; 3.在收到socket消息代理里面1234567891011121314151617181920212223242526-(void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag//接收到消息执行的代理。&#123; [socket readDataWithTimeout:-1 tag:0];//这句话太重要了 UIApplication *application=[UIApplication sharedApplication]; if (application.applicationState==UIApplicationStateBackground||application.applicationState==UIApplicationStateInactive ) &#123; NSArray *oldNotifications=[application scheduledLocalNotifications]; if ([oldNotifications count]&gt;0) &#123; [application cancelAllLocalNotifications]; &#125; UILocalNotification *alarm=[[UILocalNotification alloc] autorelease]; if (alarm) &#123; alarm.fireDate=[NSDate date]; alarm.timeZone=[NSTimeZone defaultTimeZone]; alarm.repeatInterval=0; [Single sharedSingle].iconNumber++; alarm.applicationIconBadgeNumber=[Single sharedSingle].iconNumber; alarm.soundName=@\"alarmsound.caf\"; alarm.alertBody=[jsonDictionary valueForKey:@\"sendmsg\"]; [application scheduleLocalNotification:alarm]; &#125; &#125; 4.//挂起时，本操作是为了600秒重写连接一次socket，保持socket在线12345678910111213141516171819202122232425262728293031- (void)applicationDidEnterBackground:(UIApplication *)application&#123; [[UIApplication sharedApplication] setKeepAliveTimeout:600 handler:^&#123; [[NSNotificationCenter defaultCenter]postNotificationName:@\"CreatSocket\" object:nil userInfo:nil];&#125;];&#125;-(void)creatSocket&#123; if (![[Single sharedSelfMemberID] isEqualToString:@\"\"]) &#123;//登陆了 [Single sharedSingle].socket.delegate=self; [Single sharedSingle].socket.delegateQueue=dispatch_get_main_queue(); NSError *err = nil; if(![socket connectToHost:socketURL onPort:socketPort error:&amp;err]) &#123; NSLog(@\"%@\",err); [[Single sharedSingle].socket readDataWithTimeout:-1 tag:0]; &#125; else &#123; [[Single sharedSingle].customStatueBar show]; [Single sharedSingle].customStatueBar.messageLabel.text=@\"连接中...\"; NSLog(@\"ok\"); &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.littlewhale.xyz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"AFNNetWorking-分析","slug":"AFNNetWorking","date":"2016-05-13T10:42:40.000Z","updated":"2020-05-27T00:44:21.000Z","comments":true,"path":"2016/05/13/AFNNetWorking/","link":"","permalink":"https://www.littlewhale.xyz/2016/05/13/AFNNetWorking/","excerpt":"基于ASI之后，AFN应该是比较流行的ios第三方。GIthub AFNetWorking.这里，先贴我之前做项目 基于AFN的封装。之后，解释下AFNetWorking 的相关知识，AFURLConnectionOperation,SSL 安全AFSecurityPolicy。","text":"基于ASI之后，AFN应该是比较流行的ios第三方。GIthub AFNetWorking.这里，先贴我之前做项目 基于AFN的封装。之后，解释下AFNetWorking 的相关知识，AFURLConnectionOperation,SSL 安全AFSecurityPolicy。 项目AFNetWorking 请求封装部分代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215 #关于 基于AFN网络请求的get,post方法// BaseDataService.m// LvJinKu//// Created by lvjinku on 15/9/8.// Copyright (c) 2015年 lvjinku. All rights reserved.//#import \"BaseDataService.h\"#import \"DFReachabilityUtil.h\"#import \"NSString+RRAPI.h\"#import \"JSONKit.h\"static const NSString *LvJinKuAgency = @\"root\";static const NSString *LvJinKuSecurity = @\"permission\";@interface BaseDataService()@property (nonatomic,strong) NSMutableDictionary *requestParams;-(NSString *) acquireBaseRequestParamDictionary;@end@implementation BaseDataService@synthesize manager,requestType,requestParams;#pragma mark - Lifecycle- (instancetype)init&#123; self = [super init]; if (self) &#123; manager = [[AFHTTPRequestOperationManager alloc] init]; manager.requestSerializer.timeoutInterval = NetworkTimeoutInterval; requestType = RequestTypeGet; requestParams = [NSMutableDictionary dictionary]; &#125; return self;&#125;#pragma mark - Method-(void)executeRequest&#123; //网络不可用 if (![DFReachabilityUtil isNetworkAvailable]) &#123; NSError *error = [NSError errorWithDomain:CustomErrorDomain code:CustomErrorConnectFailed userInfo:nil]; [self onError:error]; return; &#125; switch (requestType) &#123; case RequestTypeGet: &#123; NSDictionary *requestParamsDic = @&#123;@\"xml\":[self acquireBaseRequestParamDictionary]&#125;; NSLog(@\"get请求参数：%@\", [self acquireBaseRequestParamDictionary]); //参数,简单的get请求 [manager GET:[self getRequestDomain] parameters:requestParamsDic success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; [self onSuccess:responseObject]; &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; NSLog(@\"错误日志：%@\",error.localizedDescription); [self onError:error]; &#125;]; break; &#125; case RequestTypePost: &#123; //参数,简单的post请求 NSDictionary *requestParamsDic = @&#123;@\"xml\":[self acquireBaseRequestParamDictionary]&#125;; [manager POST:[self getRequestDomain] parameters:requestParamsDic success:^(AFHTTPRequestOperation *operation, id responseObject)&#123; [self onSuccess:responseObject]; &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; [self onError:error]; &#125;]; break; &#125; case RequestTypePostMultipart: &#123; //检查是否为文件类型 BOOL isFile = NO; for (NSString * key in requestParams.allKeys) &#123; id value = requestParams[key]; //判断请求参数是否是文件数据 if ([value isKindOfClass:[NSData class]]) &#123; isFile = YES; break; &#125; &#125; if(isFile) &#123; //上传文件 [manager POST:[self getRequestDomain] parameters:requestParams constructingBodyWithBlock:^(id formData) &#123; for (NSString *key in requestParams) &#123; id value = requestParams[key]; if ([value isKindOfClass:[NSData class]]) &#123; [formData appendPartWithFileData:value name:key fileName:key mimeType:@\"image/jpeg\"]; &#125; &#125; &#125; success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; [self onSuccess:responseObject]; &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; [self onError:error]; &#125;]; &#125; break; &#125; default: break; &#125; &#125;-(NSString *) getRequestDomain&#123; return @\"https://www.lvjinku.com/Home/Router/doRoute\";&#125;-(void) onSuccess:(id)result&#123; if (result) &#123; BaseResponse *response = [[BaseResponse alloc] initWithData:result]; response.requestAPICode = self.requestApiCode; if (response.error == 0) &#123; NSLog(@\"reqest finished:%@\",result); //解析，将responseObject设置成model对象 [self parseResponse:response]; if (_delegate &amp;&amp; [_delegate conformsToProtocol:@protocol(DataServiceDelegate)] &amp;&amp; [_delegate respondsToSelector:@selector(onRequestSuccess:)]) &#123; [_delegate onRequestSuccess:response]; &#125; &#125;else&#123; if (_delegate &amp;&amp; [_delegate conformsToProtocol:@protocol(DataServiceDelegate)] &amp;&amp; [_delegate respondsToSelector:@selector(onRequestStatusError:)]) &#123; [_delegate onRequestStatusError:response]; &#125; &#125; &#125; &#125;-(void) onError:(NSError *)error&#123; if (_delegate &amp;&amp; [_delegate conformsToProtocol:@protocol(DataServiceDelegate)] &amp;&amp; [_delegate respondsToSelector:@selector(onRequestError:)]) &#123; [_delegate onRequestError:error]; &#125;&#125;//配置请求参数 xml的值-(NSString *) acquireBaseRequestParamDictionary&#123; [self setRequestParams:self.requestParams]; //json字符串 NSMutableDictionary *baseRequestDictionary = [NSMutableDictionary dictionary]; [baseRequestDictionary setObject:LvJinKuAgency forKey:@\"agency\"]; [baseRequestDictionary setObject:LvJinKuSecurity forKey:@\"security\"]; [baseRequestDictionary setObject:[self getAPIRequestMethodName] forKey:@\"serviceCode\"]; [baseRequestDictionary setObject:self.requestParams forKey:@\"params\"]; NSString *requestParamJsonStr = [self.requestParams JSONString]; NSString *tokenIdStr = [NSString stringWithFormat:@\"%@%@%@%@\",LvJinKuAgency,LvJinKuSecurity,[self getAPIRequestMethodName],requestParamJsonStr]; NSString *tokenId = [tokenIdStr MD5Code]; [baseRequestDictionary setObject:tokenId forKey:@\"tokenid\"]; //md5加密 NSString *baseRequestParamJsonStr = [baseRequestDictionary JSONString]; return baseRequestParamJsonStr; &#125;/** * 获取请求api的具体接口方法名 * * @return &lt;#return value description#&gt; */-(NSString *) getAPIRequestMethodName&#123; return @\"\";&#125;/** * 解析response 字段 * * @param response &lt;#response description#&gt; */-(void) parseResponse:(BaseResponse *)response&#123; //子类覆盖该方法进行解析&#125;@end 【后面我将会结合Http请求封装解耦 写一个系列关于HTTP请求自定义封装的解析，结合AFN封装，JSON解析，下拉刷新，分页】 AFNetWorking.h 文件代码12345678910111213141516171819202122#import &lt;Foundation/Foundation.h&gt;#import &lt;Availability.h&gt;#ifndef _AFNETWORKING_ #define _AFNETWORKING_ #import \"AFURLRequestSerialization.h\" #import \"AFURLResponseSerialization.h\" #import \"AFSecurityPolicy.h\" #import \"AFNetworkReachabilityManager.h\" #import \"AFURLConnectionOperation.h\" #import \"AFHTTPRequestOperation.h\" #import \"AFHTTPRequestOperationManager.h\"#if ( ( defined(__MAC_OS_X_VERSION_MAX_ALLOWED) &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= 1090) || \\ ( defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000 ) ) #import \"AFURLSessionManager.h\" #import \"AFHTTPSessionManager.h\"#endif#endif /* _AFNETWORKING_ */ 一、综述#类库的头文件AFNetworking.h引入了下面的所有类库，并可以根据不同的系统使用不同的实现方式。 1、AFURLConnectionOperation12AFURLConnectionOperation.h 文件 @interface AFURLConnectionOperation : NSOperation &lt;NSURLConnectionDelegate, NSURLConnectionDataDelegate, NSSecureCoding, NSCopying&gt; AFN最基础的类继承自NSOperation类，将网络请求依附到一个operation上。从而让我们能够有效的控制并观察一个网络请求的创建、进行、取消、完成、暂停恢复、异常等问题及状态。 2、AFHTTPRequestOperation12345AFHTTPRequestOperation.h 文件 /**`AFHTTPRequestOperation` is a subclass of `AFURLConnectionOperation` for requests using the HTTP or HTTPS protocols. It encapsulates the concept of acceptable status codes and content types, which determine the success or failure of a request.*/@interface AFHTTPRequestOperation : AFURLConnectionOperation HTTP或HTTPS协议请求的AFURLConnectionOperation的子类。它封装的可接受状态码和内容的类型，判定一个请求结果是成功或失败。实际上对系统的HTTP网络请求增加了几个HTTP需要用到的参数。 3、AFHTTPRequestOperationManager这个类是AFN类库的核心类。它封装完成了一种通用的模式，可以帮助我们轻松友好的完成请求的创建、响应的系列化，网络状态的监控以及安全策略以及每一个请求operation的管理（operation的相互依赖或状态改变）。 4、AFURLSessionManageriOS7之后，苹果增加了新的网络请求类–NSURLSession。AFN官方推荐iOS 7 或者 Mac OS X 10.9以上的，最好使用该类发起网络请求，取代AFHTTPRequestOperationManager。基于目前国内app大都最低适配的iOS6，该类的用途还不是太广泛。 5、AFNetworkReachabilityManager网络的连通状态监控以及网络的类型。实际是将苹果官方提供的Reachability的类名和通知名更换了一下，防止和系统提供的类的通知名以及类名的冲突。 6、AFURLRequestSerialization1：符合这个协议的对象用于处理请求，它将请求参数转换为 query string 或是 entity body 的形式，并设置必要的 header。2：构建multipart请求。 7、AFURLResponseSerialization遵循AFURLResponseSerialization协议的对象，用于验证、序列化响应及相关数据，转换为有用的形式，比如 JSON 对象、图像、甚至基于mantle的模型对象。 8、AFSecurityPolicy基于HTTPS 配置一些请求证书相关的安全策略。讲到AFSecurityPolicy ，有必要先了解一下HTTPS.HTTPS 连接建立过程大致是，客户端和服务端建立一个连接，服务端返回一个证书，客户端里存有各个受信任的证书机构根证书，用这些根证书对服务端 返回的证书进行验证，经验证如果证书是可信任的，就生成一个pre-master secret，用这个证书的公钥加密后发送给服务端，服务端用私钥解密后得到pre-master secret，再根据某种算法生成master secret，客户端也同样根据这种算法从pre-master secret生成master secret，随后双方的通信都用这个master secret对传输数据进行加密解密。12345678910111213141516171819AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; AFSecurityPolicy *securityPolicy = [[AFSecurityPolicy alloc] init]; [securityPolicy setAllowInvalidCertificates:NO]; [securityPolicy setSSLPinningMode:AFSSLPinningModeCertificate]; [securityPolicy setValidatesDomainName:YES];[securityPolicy setValidatesCertificateChain:NO]; manager.securityPolicy = securityPolicy;## SSL Pinning Modes The following constants are provided by `AFSSLPinningMode` as possible SSL pinning modes. enum &#123; AFSSLPinningModeNone, AFSSLPinningModePublicKey, AFSSLPinningModeCertificate, &#125;AFSSLPinningModeNone: 代表客户端无条件地信任服务器端返回的证书。AFSSLPinningModePublicKey: 代表客户端会将服务器端返回的证书与本地保存的证书中，PublicKey的部分进行校验；如果正确，才继续进行。AFSSLPinningModeCertificate: 代表客户端会将服务器端返回的证书和本地保存的证书中的所有内容，包括PublicKey和证书部分，全部进行校验；如果正确，才继续进行。AFSecurityPolicy相关更多知识可以了解这篇文章 AFSecurityPolicy AFURLConnectionOperation 实现分析1、综述AFURLConnectionOperation将Operation和URLConnection结合到一起，利用operation可以监听到状态以及可以建立相互之间的依赖关系的特性，实现了对于一个NSURLConnection对象的完美控制，并将请求的结果通过block友好的返回。 2、实现文件.m我们总结下.m中这个类主要有哪些方法。 1）：首先我们可以看到它创建了一个单例线程。这个线程将会常驻内存，用来处理AFN发起的所有请求任务。当然，线程也跟随着一个runloop，AFN将这个runloop的模式设置为NSDefaultRunLoopMode。NSDefaultRunLoopMode是无法检测到connection的状态的。这说明了，AFN将不会在这该线程处理connection完成后的UI刷新等工作，而是会将数据抛给主线程，让主线程去完成UI的刷新。2）：我们可以看到该类通过接受请求的字符串，创建了URLRequest以及NSURLConnection对象。从而去进行请求。3）：实现文件多次使用到了锁，可以保证数据的安全。当然他也实现了几个数据的NSCoping协议。4）：请求的创建、进行、取消、完成、暂停恢复、异常等问题及状态的控制。这里讲一下暂停和恢复。暂停实际上将网络请求取消掉了。但是由于实现了nscoping协议，已经下载到数据得以保存下来。下次进行相同请求的时候，我们会将已经下载到的数据的节点一起发送给服务器，告诉服务器这些部门的数据我们不需要了，服务器根据我发送的返回节点给我返回相应的数据即可。从而实现了暂停和恢复功能，也就是断点续传。5）：operation方法的重写。6）：状态的各种控制方法的实现以及发送状态改变的通知 3、接口文件.h接口文档中的属性方法，基本可以概括为以下几个方法 1）：只读的数据，让管理者可以接收到。2）：设置runloop的modes。不再使用类库默认设置的defaultmodes。3）：状态的控制方法4）：安全策略的设置总而言之，接口文件.h暴露的接口都是为了让manager可以去完全控制这个operation以及其中的网络请求。 AFHTTPRequestOperationManger2.0后，AFN将一些设置提取出来，线程了专门的类【AFSecurityPolicy、AFURLRequestSerialization、AFURLResponseSerialization】。现在看来，AFN整体的设计是非常完美的。耦合性变得非常低，一些1.0版本中存在的问题也得到了改善。 1、实现文件.m实现文件较为简单，可以看到他创建了一个队列。并将各个operation加入到队列中。在队列中，各个请求就可以设置依赖关系，并发的数量等等。 2、接口文件.h接口文件中，我们可以看到。这个类可以设置AFSecurityPolicy、AFURLRequestSerialization、AFURLResponseSerialization 等参数了。这就是综述所说的降低耦合性的方式。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"}],"tags":[]},{"title":"2015年总结","slug":"2015_Overview","date":"2016-02-03T09:03:44.000Z","updated":"2020-05-27T01:00:16.000Z","comments":true,"path":"2016/02/03/2015_Overview/","link":"","permalink":"https://www.littlewhale.xyz/2016/02/03/2015_Overview/","excerpt":"今天是2016年 2月 3号了，写这篇博文的时候，手脚冰冷冰冷的。回想起走过的2015年，虽然不是很顺利，好几次遇到困难都是在零界点快要放弃了，自己的最后坚持又让我重新看到希望。当然，我一直坚信答案是在最后才能得到。我的生活，思想 都在变化着。但我一直坚信所经历的一切都对的，虽然有时候回头想了一些事情的决定后，偶尔会有些遗憾，但我一直在跟着心走，想清楚了，决定了，就去做。用心去自己喜欢做得事，把更多的时间和精力花在上面我反而觉得更有意义。","text":"今天是2016年 2月 3号了，写这篇博文的时候，手脚冰冷冰冷的。回想起走过的2015年，虽然不是很顺利，好几次遇到困难都是在零界点快要放弃了，自己的最后坚持又让我重新看到希望。当然，我一直坚信答案是在最后才能得到。我的生活，思想 都在变化着。但我一直坚信所经历的一切都对的，虽然有时候回头想了一些事情的决定后，偶尔会有些遗憾，但我一直在跟着心走，想清楚了，决定了，就去做。用心去自己喜欢做得事，把更多的时间和精力花在上面我反而觉得更有意义。 工作缩影前8个月，我在一家社交公司担任ios开发一职。每周6天班，每天10点到晚上10点。当然我不是说工作时间很长，正真工作的时间也才5到6个多小时。这样长期下去，一：身体透支。 二：工作效率降低。三：生活上大部分时间被占用，有些事情处理得不是很好。 我喜欢工作和生活安排都适当的节奏。企业文化问题也无法一下子提建议就改变的。9月后入职一家P2P公司，负责IOS以及的开发。开发完后，老板一直没有上线的意思。工作2个月后，公司发展战略遇到瓶颈，15年很多P2P的公司跑路，发展得不是很好。后面公司转移方向做P2P的信息平台了。后面惨的就是员工了，本身公司很小，员工没几个。但都被降工资了。到1月19号，我也离职走了。 经历上半年过得特别充实，上班下班。租室 ，公司 。两点一线，每天这样，都沉浸在代码中。那段日子，师傅也比较喜欢我。积极向上，能够快速完成师傅分配的任务，和同事他们关系很融洽，玩得很好。也很有话题，每天中午服务器，android ,ios都是一些搞技术的人 一起去吃饭。聊聊技术，开开玩笑，哈。那段时间最开心了。自己也成长最快。工作快半年的样子，我就请了一趟假去杭州玩。因为伯伯在那边，去看看西湖，钱塘江。那段时间很美好，很怀念，很放松。短短的玩一星期。然后6月1号就坐飞机回来了。 波折的六月六月，那个月我生病了。花了8千块钱治疗。接着家里又出现一些事情，所以工作一直没有很专心。接着公司也来了一个新妹子，平静的生活一下子被打破了。后来遇到了那表述不清却很渴望的神圣东西名曰爱情。接着第七个月，很大一部分心思都没有认真花在工作上。每天都会开小差，然后趁她不注意多看她几眼。那段时间，写程序总是粗心，bug . 还有一个bug没解决 . 接着，随着相处。8月份我们就再一起了，后来七夕我送玫瑰给她了。但是半个月后，因为一个小误会，又让我沉浸在难过当中。接下来的一星期，异常难过。后来双方冷战。看到她难过，家里琐事重重，工作作息等不协调，也确实累了。当时冲动就离职了。。 关于爱情的想法爱情是双方的，有时候可能会吵架，但这也许就是小插曲吧。中间会出现很多磨合，正是因为这些，才让对方和自己变得慢慢理性成熟起来，只有相互地宽容对方，理解对方，才能更长久地走下去。燕儿，我爱你。 新的一年前做得事情虽然这一年曲折多变，但也让我成长不少。新的一年2016年一月，我为自己做了这些事情，1.20号离职了。21号到31号这十天：1、搭建了一个个人博客网站。2、模仿一个app做了一个Android版demo.(所有UI以及动效) 后期等完善服务器后台接口调通后，我会发博文剖析整个架构。3、坚持每天傍晚去跑3圈。从第一天的11分06秒 到 第九天的 9分 06 秒。4、准备好了年后的计划，以及要去做的事情。创业走起。相信生活会越来越好。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://www.littlewhale.xyz/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"手撕机-拆笔记本了解结构","slug":"openTheNotebook","date":"2016-01-24T12:41:11.000Z","updated":"2020-05-27T00:50:22.000Z","comments":true,"path":"2016/01/24/openTheNotebook/","link":"","permalink":"https://www.littlewhale.xyz/2016/01/24/openTheNotebook/","excerpt":"这几天今天广州的天气好冷，最低气温0度。离职后有几天了，在家里写代码，傍晚的时候就去跑步。今天是周末，就稍微休息了下。前几天刚好把博客搭建起来了，今天就跟大家大概讲一下笔记本的主板结构。以下图为仅今天动手拆卸后所拍。（注：亲，请勿冲动拆卸笔记本。） 主板拍摄图主板","text":"这几天今天广州的天气好冷，最低气温0度。离职后有几天了，在家里写代码，傍晚的时候就去跑步。今天是周末，就稍微休息了下。前几天刚好把博客搭建起来了，今天就跟大家大概讲一下笔记本的主板结构。以下图为仅今天动手拆卸后所拍。（注：亲，请勿冲动拆卸笔记本。） 主板拍摄图主板 CPU 内存条 主板正面 主板背面 技术从来就不是因为难而让我们停止，只有动手尝试，去做就对了。欢迎大家有关笔记本插解方面有关的讨论和反馈。","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"Hexo 搭建GithubPage 个人博客","slug":"hexoGithubPageBlog","date":"2016-01-22T03:15:54.000Z","updated":"2020-05-27T00:42:39.000Z","comments":true,"path":"2016/01/22/hexoGithubPageBlog/","link":"","permalink":"https://www.littlewhale.xyz/2016/01/22/hexoGithubPageBlog/","excerpt":"程序员都喜欢折腾，我也不列外。当然，用hexo 建博客也是当时碰巧在网上看到别人的博客，用来写技术，生活，读书，以及不一样的心情。当时我也很是好奇这样的博客是用什么搭建的。看到博尾有一行小字“Powered by Hexo.”, 于是，开始了自己的不断折腾。因为这段时间离职了，刚好也有空闲下来去做自己喜欢的事情。接下来，我大概按照我的思路记下来我搭建hexo的步骤。","text":"程序员都喜欢折腾，我也不列外。当然，用hexo 建博客也是当时碰巧在网上看到别人的博客，用来写技术，生活，读书，以及不一样的心情。当时我也很是好奇这样的博客是用什么搭建的。看到博尾有一行小字“Powered by Hexo.”, 于是，开始了自己的不断折腾。因为这段时间离职了，刚好也有空闲下来去做自己喜欢的事情。接下来，我大概按照我的思路记下来我搭建hexo的步骤。 下载node.js11) 在 Windows 环境下安装 Node.js 非常简单.到此处下载 [下载node.js](http://nodejs.org/) 下载 Git稳定版1由于git官网下载 可能比较缓慢，可通过其他途径如csdn下载。我下载的git版本是 2.6.2.windows.1 配置Git SSH key。本地与github服务器链接。123451)打开本地C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub文件。此文件里面内容为刚才生成人密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。2)登陆github系统。点击右上角的 Account Settings---&gt;SSH Public keys ---&gt; add another public keys3)把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了4)测试是否配置成功 $ ssh -T git@github.com 下载并安装 Hexo1234561) 在任意位置打开 git bash .2) 运行以下命令 $ npm install -g hexo3) 下载完成后，在你喜欢的位置 如D:/hexo 下打开git bash 运行 hexo init 这个命令的意思是 Hexo 即会自动在目标文件夹建立网站所需要的所有文件4) 安装hexo 相关的依赖包 npm install5) 运行hexo g 编译静态文件 ，然后再hexo s 启动本地服务。检查安装是否成功 在浏览器地址输入 localhost:4000 hexo config的基本配置1在hexo的根目录下配置 _config.yml 文件。 下载并使用其他主题，主题的配置1231) 我使用的是next主题。进入你的hexo文件夹下，下载可以使用$ git clone https://github.com/iissnan/hexo-theme-next themes/next2) 下载安装，主题设置可参考 [Next主题](http://theme-next.iissnan.com/five-minutes-setup.html) hexo 的使用，以及部署到你的github库12345在hexo 根目录 _config.yml 文件配置deploy: type: git repo: https://github.com/gaoyingqiu/gaoyingqiu.github.io branch: master hexo搭建遇到的相关问题解决办法12345678910111213141516171819#关于 hexo d 出现 ERROR Deployer not found : github 如何解决？1) deploy的type改成git，然后运行下npm install hexo-deployer-git --save2) 继续运行 hexo g 然后再hexo d# *** Please tell me who you are.Run git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\" 如何解决？1) 根据此错误可知，部署到github 库需要 输入邮箱和你的github的用户名。所以根据提示，运行相应的命令即可，再次部署一次。hexo d.#设置favicon。1)把favicon.icon图标拷贝到hexo 根目录的source文件夹下即可，如果这个时候没网页icon不显示可更改主题文件配置中的favicon属性 。把favicon.icon拷贝到images文件夹下。favicon的配置如 favicon: /images/favicon.icon#hexo 部署到github时候，怎样解决频繁地输入用户名 和密码？1) 在系统属性环境变量处 添加用户环境变量。变量名：HOME 变量值： %USERPROFILE%2) 在 C:\\Users\\Administrator 添加一个名为 “_netrc” 的文件，无后缀。在里面设置 machine github.com login 你的github用户名 password 你的github登录密码 购买域名，DNS解析","categories":[{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.littlewhale.xyz/tags/Hexo/"}]}],"categories":[{"name":"iOS","slug":"iOS","permalink":"https://www.littlewhale.xyz/categories/iOS/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.littlewhale.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"其他","slug":"其他","permalink":"https://www.littlewhale.xyz/categories/%E5%85%B6%E4%BB%96/"},{"name":"Web","slug":"Web","permalink":"https://www.littlewhale.xyz/categories/Web/"},{"name":"技术","slug":"技术","permalink":"https://www.littlewhale.xyz/categories/%E6%8A%80%E6%9C%AF/"},{"name":"杂谈","slug":"杂谈","permalink":"https://www.littlewhale.xyz/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.littlewhale.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"富文本","slug":"富文本","permalink":"https://www.littlewhale.xyz/tags/%E5%AF%8C%E6%96%87%E6%9C%AC/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.littlewhale.xyz/tags/HTTP/"},{"name":"软实力","slug":"软实力","permalink":"https://www.littlewhale.xyz/tags/%E8%BD%AF%E5%AE%9E%E5%8A%9B/"},{"name":"SKU","slug":"SKU","permalink":"https://www.littlewhale.xyz/tags/SKU/"},{"name":"Slider","slug":"Slider","permalink":"https://www.littlewhale.xyz/tags/Slider/"},{"name":"DatePicker","slug":"DatePicker","permalink":"https://www.littlewhale.xyz/tags/DatePicker/"},{"name":"抽奖","slug":"抽奖","permalink":"https://www.littlewhale.xyz/tags/%E6%8A%BD%E5%A5%96/"},{"name":"MVC","slug":"MVC","permalink":"https://www.littlewhale.xyz/tags/MVC/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://www.littlewhale.xyz/tags/HTTPS/"},{"name":"关系图","slug":"关系图","permalink":"https://www.littlewhale.xyz/tags/%E5%85%B3%E7%B3%BB%E5%9B%BE/"},{"name":"AndroidTableView","slug":"AndroidTableView","permalink":"https://www.littlewhale.xyz/tags/AndroidTableView/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.littlewhale.xyz/tags/Hexo/"}]}